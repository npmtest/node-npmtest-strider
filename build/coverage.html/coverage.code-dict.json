{"/home/travis/build/npmtest/node-npmtest-strider/test.js":"/* istanbul instrument in package npmtest_strider */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-strider/lib.npmtest_strider.js":"/* istanbul instrument in package npmtest_strider */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_strider = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_strider = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-strider/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-strider && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_strider */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_strider\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_strider.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_strider.rollup.js'] =\n            local.assetsDict['/assets.npmtest_strider.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_strider.__dirname + '/lib.npmtest_strider.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/main.js":"'use strict';\n\nvar path = require('path');\nvar passport = require('passport');\nvar async = require('async');\nvar Loader = require('strider-extension-loader');\nvar globalTunnel = require('global-tunnel');\n\nvar app = require('./lib/app');\nvar common = require('./lib/common');\nvar config = require('./lib/config');\nvar middleware = require('./lib/middleware');\nvar auth = require('./lib/auth');\nvar models = require('./lib/models');\nvar pluginTemplates = require('./lib/plugin-templates');\nvar upgrade = require('./lib/models/upgrade').ensure;\nvar loadExtensions = require('./lib/utils/load-extensions');\nvar killZombies = require('./lib/utils/kill-zombies');\nvar registerPanel = require('./lib/utils/register-panel');\n\nvar Job = models.Job;\nvar Config = models.Config;\n\ncommon.extensions = {};\n//\n// Use globa-tunnel to provide proxy support.\n// The http_proxy environment variable will be used if the first parameter to globalTunnel.initialize is null.\n//\nglobalTunnel.initialize();\n\nmodule.exports = function (extdir, c, callback) {\n  var appConfig = config;\n  var k;\n  // override with c\n  for (k in c) {\n    appConfig[k] = c[k];\n  }\n\n  // Initialize the (web) app\n  var appInstance = app.init(appConfig);\n  var cb = callback || defaultCallback;\n\n  function defaultCallback(err) {\n    if (err) {\n      throw err;\n    }\n  }\n\n  if (typeof Loader !== 'function') {\n    throw new Error('Your version of strider-extension-loader is out of date');\n  }\n\n  var loader = new Loader([path.join(__dirname, 'client/styles')], true);\n  appInstance.loader = loader;\n  common.loader = loader;\n  //\n  // ### Strider Context Object\n  //\n  // Context object is passed to each extension.  It carries various config\n  // settings, as well as handles to enable functions to register things.\n  // Context can also be accessed as a singleton within Strider as\n  // common.context.\n  var context = {\n    serverName: appConfig.server_name,\n    config: appConfig,\n    enablePty: config.enablePty,\n    emitter: common.emitter,\n    extensionRoutes: [],\n    extensionPaths: extdir,\n    extdir: extdir,\n    loader: loader,\n    models: models,\n    logger: console,\n    middleware: middleware,\n    auth: auth, //TODO - may want to make this a subset of the auth module\n    passport: passport,\n    registerPanel: registerPanel(common),\n    registerBlock: pluginTemplates.registerBlock,\n    app: appInstance\n  };\n\n  // Make extension context available throughout application.\n  common.context = context;\n\n  var SCHEMA_VERSION = Config.SCHEMA_VERSION;\n\n  upgrade(SCHEMA_VERSION, function (err) {\n    if (err) {\n      return cb(err);\n    }\n\n    loadExtensions(loader, extdir, context, appInstance, function () {\n      // kill zombie jobs\n      killZombies(function () {\n        var tasks = [];\n\n        if (!common.extensions.runner || typeof common.extensions.runner !== 'object') {\n          console.error('Strider seems to have been misconfigured - there are no available runner plugins. ' +\n            'Please make sure all dependencies are up to date.');\n          process.exit(1);\n        }\n\n        Object.keys(common.extensions.runner).forEach(function (name) {\n          var runner = common.extensions.runner[name];\n\n          if (!runner) {\n            console.log('no runner', name);\n            return;\n          }\n\n          tasks.push(function (next) {\n            Job.find({\n              'runner.id': name,\n              finished: null\n            }, function (error, jobs) {\n              if (error) {\n                return next(error);\n              }\n\n              runner.findZombies(jobs, next);\n            });\n          });\n        });\n\n        async.parallel(tasks, function (err, zombies) {\n          if (err) return cb(err);\n\n          var ids = [].concat.apply([], zombies).map(function (job) {\n            return job._id;\n          });\n          var now = new Date();\n\n          Job.update({_id: {$in: ids}}, {\n            $set: {\n              finished: now,\n              errored: true,\n              error: {message: 'Job timeout', stack: ''}\n            }\n          }, function () {\n            Job.update({_id: {$in: ids}, started: null}, {$set: {started: now}}, function (err) {\n              cb(err, appInstance);\n            });\n          });\n        });\n      });\n    });\n  });\n\n  return appInstance;\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/main.js":"//\n// Loader for Strider extension modules.\n//\n\nmodule.exports = require('./lib')\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/lib/index.js":"\nvar job = require('./job')\n  , runner = require('./runner')\n  , provider = require('./provider')\n  , basic = require('./basic')\n  , utils = require('./utils')\n\n  , fs = require('fs')\n  , path = require('path')\n  , async = require('async')\n  , connect = require('connect')\n  , _ = require('underscore')\n\n  , RESERVED = ['provider', 'config', 'api']\n\n/*\nOn a grand scale, the things that plugins should be able to do:\n// app startup / plugin refresh\n- add routes\n- attach global listeners\n- extend models\n*/\n\nmodule.exports = Loader\n\nfunction Loader(lesspaths, isNamespaced) {\n  this.isNamespaced = isNamespaced;\n  this.types = {\n    'job': job,\n    'runner': runner,\n    'provider': provider,\n    'basic': basic\n  };\n  this.ids = {};\n  this.lesspaths = lesspaths || [];\n  this.extensions = {\n    job: {},\n    runner: {},\n    provider: {},\n    basic: {}\n  };\n}\n\nLoader.prototype = {\n  // find all extensions in dirs and organize them by type\n  // load from `strider.json` or package.json's `strider` section\n  collectExtensions: function (dirs, done) {\n    var self = this\n    utils.findExtensions(dirs, function (err, extensions) {\n      if (err) return done(err)\n      var type\n        , fname\n      for (var i=0; i<extensions.length; i++) {\n        extensions[i].type = extensions[i].type || 'basic'\n        extensions[i].id = extensions[i].id.toLowerCase()\n        if (RESERVED.indexOf(extensions[i].id) !== -1) {\n          return done(new Error('Extension id \"' + extensions[i].id + '\" is reserved. Your plugins are misconfigured.'))\n        }\n        if (self.ids[extensions[i].id]) {\n          // XXX should we die hard, ignore, or warn?\n          return done(new Error('Duplicate extension id! Your plugins are misconfigured.'))\n        }\n        self.ids[extensions[i].id] = true\n        self.extensions[extensions[i].type][extensions[i].id] = extensions[i]\n      }\n      done()\n    })\n  },\n\n  // initialize the \"webapp\" sections of all plugins.\n  // initialization depends on the plugin type. See job.js,\n  // provider.js, runner.js, basic.js\n  initWebAppExtensions: function (context, done) {\n    this.initExtensions('webapp', context, done)\n  },\n\n  // initialize the \"webapp\" sections of all plugins.\n  // initialization depends on the plugin type. See job.js,\n  // provider.js, runner.js, basic.js\n  initWorkerExtensions: function (context, done) {\n    this.initExtensions('worker', context, done)\n  },\n\n  // initTemplates(done) -> done(err, { \"tplname\": \"template text\", ... })\n  //\n  // find templates defined by plugins' strider.json config\n  // looks like:\n  // \"templates\": {\n  //    \"filetplname\": \"path/to/tpl.html\",\n  //    \"inlinetplname\": \"<div>Hi</div>\",\n  //    ...\n  // }\n  // Template values that end in \".html\" will be read from disk\n  // relative to the plugin directory\n  initTemplates: function (done) {\n    var templates = {}\n      , self = this\n    this.allExtensions(function (type, id, plugin, next) {\n      var tasks = []\n      if (!plugin.templates) return next()\n      var task = function (tpl, fname, next) {\n        fs.readFile(fname, 'utf8', function (err, data) {\n          if (err) return next(err)\n          templates[tpl] = data\n          next()\n        })\n      }\n      for (var tpl in plugin.templates) {\n        templates[tpl] = plugin.templates[tpl]\n        if (!/\\.html$/.test(plugin.templates[tpl])) continue;\n\n        var fname = path.join(plugin.dir, plugin.templates[tpl]);\n        tasks.push(task.bind(tpl, fname))\n      }\n      if (!tasks.length) return next()\n      async.parallel(tasks, next)\n    }, function (err) {\n      done(err, templates)\n    })\n  },\n\n  // initStaticDirs(app, done) -> done(err)\n  // go through webapp extensions and if `plugindir/static` is a\n  // directory, serve up files under the path `/ext/pluginid`\n  initStaticDirs: function (app, done) {\n    var self = this\n    this.allExtensions(function (type, id, plugin, next) {\n      var staticDir = path.join(plugin.dir, 'static')\n      fs.stat(staticDir, function (err, stat) {\n        if (err || !stat || !stat.isDirectory()) return next()\n        app.use('/ext/' + id, connect.static(staticDir))\n        next()\n      })\n    }, done)\n  },\n\n  // Collect html, css and js from all plugins and compile the css and\n  // js, writing it to @jspath and @csspath\n  // done(err)\n  initConfig: function (jspath, csspath, done) {\n    if (arguments.length === 1) {\n      done = jspath\n      jspath = csspath = null\n    }\n    var alljs = []\n      , allcss = []\n      , configs = {}\n      , self = this;\n\n    this.allExtensions(function (type, id, plugin, next) {\n      var namespace = self.isNamespaced ? 'Config.' : '';\n\n      if (!plugin.config) {\n        plugin.config = {}\n      }\n      if (!configs[type]) configs[type] = {}\n      if (plugin.config === true) {\n        plugin.config = {\n          savebtn: true\n        }\n      }\n      plugin.config = _.extend({\n        controller: namespace + type[0].toUpperCase() + type.slice(1) + 'Controller',\n        /* Defaults. If they don't exist, however, no error is thrown.\n        template: 'config/config.html',\n        script: 'config/config.js',\n        style: 'config/config.less',\n        */\n        icon: plugin.icon,\n        title: plugin.title || id,\n        id: id\n      }, plugin.config)\n\n      configs[type][id] = plugin.config\n      utils.getStatic(id, plugin.dir, plugin.config, self.lesspaths, function (err, html, css, js) {\n        if (err) return next(err)\n        plugin.config.html = html || '<h3>This plugin does not require any configuration</h3>'\n        alljs.push(js)\n        allcss.push(css)\n        next()\n      })\n    }, function (err) {\n      if (err) return done(err, configs)\n      // wrap our javascripts\n      var jstop = \"// GENERATED from the plugins' config files. Do not modify - go to the source.\\n\" +\n                  \"/* jshint undef: false */\\n\\n\"\n        , jspref = ';(function (angular) {\\n'\n        , jspost = '\\n})(angular);\\n'\n        , jstext = jstop + jspref + alljs.join(jspost + jspref) + jspost\n        , csstext = allcss.join('\\n\\n')\n      if (jspath === null && csspath === null) {\n        return done(null, jstext, csstext, configs)\n      }\n      fs.writeFile(jspath, jstext, 'utf8', function (err) {\n        fs.writeFile(csspath, csstext, 'utf8', function (cerr) {\n          done(err || cerr, configs)\n        })\n      })\n    })\n  },\n\n  initUserConfig: function (jspath, csspath, done) {\n    if (arguments.length === 1) {\n      done = jspath\n      jspath = csspath = null\n    }\n    var alljs = []\n      , allcss = []\n      , configs = {}\n      , types = this.types\n      , self = this\n    this.allExtensions(function (type, id, plugin, next) {\n      var namespace = self.isNamespaced ? 'Account.' : '';\n      var name = types[type].userConfig || 'user';\n      var config = name + 'Config';\n\n      if (!plugin[config]) return next();\n      if (!configs[type]) configs[type] = {}\n      if (plugin[config] === true) {\n        plugin[config] = {\n          savebtn: true\n        }\n      }\n      plugin[config] = _.extend({\n        controller: namespace + type[0].toUpperCase() + type.slice(1) + 'Controller',\n        /* Defaults. If they don't exist, however, no error is thrown.\n        template: 'config/user.html',\n        script: 'config/user.js',\n        style: 'config/user.less',\n        */\n        inline_icon: plugin.inline_icon,\n        title: plugin.title,\n        id: id\n      }, plugin[config])\n\n      configs[type][id] = plugin[config]\n      utils.getStatic(id, plugin.dir, plugin[config], name, self.lesspaths, function (err, html, css, js) {\n        if (err) return next(err)\n        plugin[config].html = html\n        alljs.push(js)\n        allcss.push(css)\n        next()\n      })\n    }, function (err) {\n      if (err) return done(err, configs)\n      // wrap our javascripts\n      var jstop = \"// GENERATED from the plugins' config files. Do not modify - go to the source.\\n\" +\n                  \"/* jshint undef: false */\\n\\n\"\n        , jspref = ';(function (angular) {\\n'\n        , jspost = '\\n})(angular);\\n'\n        , jstext = jstop + jspref + alljs.join(jspost + jspref) + jspost\n        , csstext = allcss.join('\\n\\n')\n      if (jspath === null && csspath === null) {\n        return done(null, jstext, csstext, configs)\n      }\n      fs.writeFile(jspath, jstext, 'utf8', function (err) {\n        fs.writeFile(csspath, csstext, 'utf8', function (cerr) {\n          done(err || cerr, configs)\n        })\n      })\n    })\n  },\n\n  initStatusBlocks: function (jspath, csspath, done) {\n    if (arguments.length === 1) {\n      done = jspath\n      jspath = csspath = null\n    }\n    var alljs = []\n      , allcss = []\n      , blocks = {}\n      , types = this.types\n      , self = this\n    this.allExtensions(function (type, id, plugin, next) {\n      var config = plugin['build-status']\n      if (!config) return next();\n      if (!blocks[type]) blocks[type] = {}\n\n      blocks[type][id] = config\n      config.id = id\n      if (type === 'runner') {\n        config.attrs['ng-show'] = \"job.runner.id === '\" + id + \"'\" + (config.attrs['ng-show'] ? ' && ( ' + config.attrs['ng-show'] + ')' : '')\n      }\n      config.attrs['ng-show'] = \"show\" + (config.attrs['ng-show'] ? ' && ' + config.attrs['ng-show'] : '')\n      utils.getStatic(id, plugin.dir, config, 'build', self.lesspaths, function (err, html, css, js) {\n        if (err) return next(err)\n        config.html = html\n        alljs.push(js)\n        allcss.push(css)\n        next()\n      })\n    }, function (err) {\n      if (err) return done(err, blocks)\n      // wrap our javascripts\n      var jstop = \"// GENERATED from the plugins' config files. Do not modify - go to the source.\\n\" +\n                  \"/* jshint undef: false */\\n\\n\"\n        , jspref = ';(function (angular) {\\n'\n        , jspost = '\\n})(angular);\\n'\n        , jstext = jstop + jspref + alljs.join(jspost + jspref) + jspost\n        , csstext = allcss.join('\\n\\n')\n      if (jspath === null && csspath === null) {\n        return done(null, jstext, csstext, blocks)\n      }\n      fs.writeFile(jspath, jstext, 'utf8', function (err) {\n        fs.writeFile(csspath, csstext, 'utf8', function (cerr) {\n          done(err || cerr, blocks)\n        })\n      })\n    })\n  },\n\n  // private\n\n  // initExtensions(subtype, context, done) -> done(err, {type: {id: retval, ...}, ...})\n  // For each plugin\n  //   this.types[type][subtype](id, plugin, context, next(err, retval))\n  initExtensions: function (subtype, context, done) {\n    var types = this.types\n      , loaded = {}\n    this.allExtensions(function (type, id, plugin, next) {\n      if (!plugin[subtype]) return next()\n      if ('string' === typeof plugin[subtype]) {\n        try {\n          plugin[subtype] = require(path.resolve(path.join(plugin.dir, plugin[subtype])))\n        } catch (e) {\n          console.log('failed to load plugin', id, e.message, e.stack)\n          e.message += '; error loading plugin ' + id\n          return next(e)\n        }\n      }\n\n      if (!loaded[type]) loaded[type] = {}\n      if (!types[type][subtype]) {\n        loaded[type][id] = plugin[subtype]\n        return next()\n      }\n      types[type][subtype](id, plugin[subtype], plugin, context, function (err, initialized) {\n        loaded[type][id] = initialized\n        next(err)\n      })\n    }, function (err) {\n      done(err, loaded)\n    })\n  },\n\n  // allExtensions(each, done) -> done(err, [val, ...])\n  // call `each(type, id, plugin, next(err, val))` for each plugin in parallel\n  allExtensions: function (each, done) {\n    var self = this\n      , tasks = []\n    Object.keys(this.extensions).forEach(function (type) {\n      Object.keys(self.extensions[type]).forEach(function (id) {\n        var plugin = self.extensions[type][id]\n        tasks.push(function (next) {\n          each(type, id, plugin, next)\n        })\n      })\n    })\n    async.parallel(tasks, done)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/lib/job.js":"\nvar namespace = require('./namespace')\n\nmodule.exports = {\n  webapp: webapp\n}\n\nfunction defExtend(dest, src) {\n  for (var key in src) {\n    if (!src[key]) continue;\n    dest[key] = src[key]\n  }\n}\n\n// schema\n// {\n//    routes: function (app, context) {}\n//    globalRoutes: function (app, context) {}\n//    listen: function (io, context) {}\n// }\nfunction webapp(id, plugin, striderjson, context, done) {\n  if (plugin.appConfig) {\n    defExtend(plugin.appConfig, context.config.plugins[id] || {})\n  }\n  // setup routes\n  if (plugin.routes) {\n    jobRoutes(id, plugin, context)\n  }\n  if (plugin.globalRoutes) {\n    globalRoutes(id, plugin, context)\n  }\n  if (plugin.auth) {\n    plugin.auth(context.passport, context)\n  }\n  // listen to global events; most job plugins shouldn't need this\n  if (plugin.listen) {\n    plugin.listen(context.emitter, context)\n  }\n  done(null, plugin.config)\n}\n\nfunction jobRoutes(id, plugin, context) {\n  var mid = context.middleware\n  var app = namespace(context.app, '/:org/:repo/api/' + id, mid.project, mid.projectPlugin.bind(null, id))\n  app.anon = namespace(context.app, '/:org/:repo/api/' + id, mid.anonProject, mid.projectProvider)\n  plugin.routes(app, context)\n}\n\nfunction globalRoutes(id, plugin, context) {\n  var mid = context.middleware\n    , app = namespace(context.app, '/ext/' + id)\n  plugin.globalRoutes(app, context)\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/lib/namespace.js":"\nvar methods = require('methods').concat(['del'])\n\nmodule.exports = namespace\n\nfunction join(one, two) {\n  if (one[one.length - 1] === '/') one = one.slice(0, -1)\n  if (two[0] !== '/') two = '/' + two\n  return one + two\n}\n\nfunction namespace(app, prefix) {\n  var middleware = [].slice.call(arguments, 2)\n  function route(method) {\n    if (method === 'del') {\n      method = 'delete';\n    }\n    \n    var args = [].slice.call(arguments, 1)\n    return app[method].apply(app, [join(prefix, args.shift())].concat(middleware.concat(args)))\n  }\n  var rep = {}\n  for (var i=0; i<methods.length; i++) {\n    rep[methods[i]] = route.bind(null, methods[i])\n  }\n  return rep\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/node_modules/methods/index.js":"\nmodule.exports = [\n    'get'\n  , 'post'\n  , 'put'\n  , 'head'\n  , 'delete'\n  , 'options'\n  , 'trace'\n  , 'copy'\n  , 'lock'\n  , 'mkcol'\n  , 'move'\n  , 'propfind'\n  , 'proppatch'\n  , 'unlock'\n  , 'report'\n  , 'mkactivity'\n  , 'checkout'\n  , 'merge'\n  , 'm-search'\n  , 'notify'\n  , 'subscribe'\n  , 'unsubscribe'\n  , 'patch'\n];","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/lib/runner.js":"\nvar namespace = require('./namespace')\n\nmodule.exports = {\n  webapp: webapp\n}\n\nfunction webapp(id, plugin, striderjson, context, done) {\n  var config = context.config.runners && context.config.runners[id]\n    , schema = context.models.StriderSchema\n\n  /*\n  if (plugin.appConfig) {\n    schema.plugin(function (schema, options) {\n      schema.add(plugin.appConfig, 'runners.' + id)\n    })\n  }\n  */\n  // setup routes\n  if (plugin.globalRoutes) {\n    globalRoutes(id, plugin, context)\n  }\n  // passport authentication\n  if (plugin.auth) {\n    plugin.auth(context.passport, context)\n  }\n  plugin.create(context.emitter, config, context, done)\n}\n\nfunction globalRoutes(id, plugin, context) {\n  var app = namespace(context.app, '/ext/' + id)\n  plugin.globalRoutes(app, context)\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/lib/provider.js":"\nvar namespace = require('./namespace')\n\nmodule.exports = {\n  webapp: webapp,\n  worker: worker,\n  userConfig: 'account'\n}\n\nfunction worker(id, plugin, striderjson, context, done) {\n  plugin.hosted = striderjson.hosted\n  done(null, plugin)\n}\n\nfunction defExtend(dest, src) {\n  for (var key in src) {\n    if (!src[key]) continue;\n    dest[key] = src[key]\n  }\n}\n\n// routes, globalRoutes\nfunction webapp(id, plugin, striderjson, context, done) {\n  if (plugin.appConfig) {\n    defExtend(plugin.appConfig, context.config.plugins[id] || {})\n  }\n  if (plugin.routes) {\n    providerRoutes(id, plugin, context)\n  }\n  if (plugin.globalRoutes) {\n    globalRoutes(id, plugin, context)\n  }\n  if (plugin.auth) {\n    plugin.auth(context.passport, context)\n  }\n  plugin.hosted = striderjson.hosted\n  return done(null, plugin)\n}\n\nfunction providerRoutes(id, plugin, context) {\n  var mid = context.middleware\n  var app = namespace(context.app, '/:org/:repo/api/' + id, mid.project, mid.projectProvider)\n  app.anon = namespace(context.app, '/:org/:repo/api/' + id, mid.anonProject, mid.projectProvider)\n  plugin.routes(app, context)\n}\n\nfunction globalRoutes(id, plugin, context) {\n  var mid = context.middleware\n    , app = namespace(context.app, '/ext/' + id)\n  plugin.globalRoutes(app, context)\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/lib/basic.js":"\nmodule.exports = {\n  webapp: webapp\n}\n\nfunction webapp(id, plugin, striderjson, context, done) {\n  if ('function' !== typeof plugin) {\n    throw new Error('Invalid basic plugin: ' + id + ' ' + plugin)\n  }\n  plugin(context, done)\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/lib/utils.js":"\nvar path = require('path')\n  , fs = require('fs')\n\n  , less = require('less')\n  , async = require('async')\n\nmodule.exports = {\n  checkStatFile: checkStatFile,\n  checkStrider: checkStrider,\n  checkPackageJson: checkPackageJson,\n  checkModule: checkModule,\n  readDirAbs: readDirAbs,\n  readDirsParallel: readDirsParallel,\n  readDirs: readDirs,\n  checkModules: checkModules,\n  parseModules: parseModules,\n  findExtensions: findExtensions,\n  findAndSortExtensions: findAndSortExtensions,\n  getStatic: getStatic\n}\n\n// config: {template: , style: , script: }\n// done(html, css, js)\nfunction getStatic(id, basedir, config, name, lesspaths, done) {\n  if (arguments.length === 5) {\n    done = lesspaths\n    lesspaths = name\n    name = 'config'\n  }\n  async.parallel({\n    html: function (next) {\n      var failhard = !!config.template\n      if (config.template && !config.template.match(/\\.html$/)) return next(null, config.template)\n      fs.readFile(path.join(basedir, config.template || 'config/' + name + '.html'), 'utf8', function (err, data) {\n        next(failhard && err, data)\n      })\n    },\n    js: function (next) {\n      var failhard = !!config.script\n      fs.readFile(path.join(basedir, config.script || 'config/' + name + '.js'), 'utf8', function (err, text) {\n        if (!failhard && err) return next(null, '')\n        next(err, text + '\\n//# sourceUrl=' + id + '/' + path.join(basedir, config.script || 'config/' + name + '.js') + '\\n')\n      })\n    },\n    css: function (next) {\n      var failhard = !!config.style\n      fs.readFile(path.join(basedir, config.style || 'config/' + name + '.less'), 'utf8', function (err, text) {\n        if (!failhard && err) return next(null, '')\n        var source = '\\n/** source: ' + id + '/' + (config.style || 'config/' + name + '.less') + ' **/\\n'\n        if (err) return next(err)\n        if (config.style && config.style.slice(-5) !== '.less') {\n          return next(null, text + source)\n        }\n        var fpath = path.join(basedir, config.style || name + '.less')\n        \n        less.render(text, {\n          paths: [path.dirname(fpath)].concat(lesspaths || []),\n          filename: fpath\n        }).then(function(output) {\n          next(null, output.css + source)\n        }, function(error) {\n          next(error)\n        })\n      })\n    }\n  }, function (err, data) {\n    return done(err, data.html, data.css, data.js)\n  })\n}\n\n// p is file ? return json content : false\nfunction checkStatFile(p, cb) {\n  var fullPath = path.resolve(p)\n    , json\n  try {\n    json = require(fullPath)\n  } catch (e) {\n    if (e.code == \"MODULE_NOT_FOUND\") {\n      return cb(null,false);\n    } else {\n      console.error('require(\"' + fullPath + '\") failed', e)\n      return cb(e)\n    }\n  }\n  return cb(null, json)\n}\n\n// checkStrider(pth, cb) -> cb(err, config)\n// Check for strider.json. config === false if the file is not present\nfunction checkStrider(pth, cb) {\n  checkStatFile(path.join(pth, 'strider.json'), function(err, config){\n    if (err) return cb(err);\n    if (!config) return cb(null, false);\n    if (!config.id){\n      console.error(\"Error in module: \", pth, \" : strider.json must include an 'id'\")\n      return cb(null, false)\n    }\n    cb(null, config)\n  })\n}\n\n// checkPackageJson(pth, cb) -> cb(err, config)\n// config is the strider section of the package.json or false\n// config.id defaults to the name of the package\nfunction checkPackageJson(pth, cb) {\n  var p = path.join(pth, \"package.json\")\n  checkStatFile(p, function(err, pack){\n    if (err) return cb(err);\n    if (!pack || !pack.strider) return cb(null, false)\n    if (!pack.strider.id) {\n      pack.strider.id = pack.name\n    }\n    return cb(null, pack.strider);\n  })\n}\n\n// check for strider extension config in either strider.json or package.json\nfunction checkModule(pth, cb) {\n  checkStrider(pth, function(err, config){\n    if (err) return cb(err);\n    if (config){\n      config.dir = pth\n      return cb(null, config)\n    }\n    checkPackageJson(pth, function(err, config){\n      if (err) return cb(err);\n      if (config){\n        config.dir = pth\n        return cb(null, config)\n      }\n      return cb(null, false)\n    })\n  })\n}\n\n// return abs paths\nfunction readDirAbs(dir, cb) {\n  fs.readdir(dir, function(err, entries) {\n    if (err || !entries) {\n      return cb(err, null);\n    }\n    var items = [];\n    entries.forEach(function(entry) {\n      items.push(path.join(dir, entry))\n    });\n    return cb(null, items);\n  });\n}\n\n// fs.readdir list of paths in parallel.\n// used when `dir` arg is an array.\nfunction readDirsParallel(dirs, cb) {\n  var funcs = []\n  dirs.forEach(function(dir) {\n    funcs.push(readDirAbs.bind(null, dir));\n  })\n  async.parallel(funcs, function(err, results) {\n      if (err) {\n        return cb(err, null);\n      }\n      // Flatten results and return\n      var flat = [].concat.apply([], results);\n      cb(null, flat);\n    }\n  );\n}\n\n// Get the contents of one or more directories\n// if dir is an array, do this in parrallel.\nfunction readDirs(dir, cb)  {\n  // find top-level module dirs\n  if (Array.isArray(dir)) {\n    // dir is a list of paths\n    readDirsParallel(dir, cb)\n  } else {\n    // dir is a single path value\n    readDirAbs(dir, cb)\n  }\n}\n\nfunction checkModules(modules, cb) {\n  async.map(modules || [], checkModule, cb);\n}\n\nfunction parseModules(modules, cb) {\n  var extensions = []\n  modules.forEach(function(module){\n    if (module){\n      module.weight = module.weight || -1\n      // what does this do?\n      module.typ = \"json\"\n      extensions.push(module)\n    }\n  })\n  return cb(null, extensions)\n}\n\n//\n// ### Locate Strider Extensions\n//\n// Under a specified path **dir** look for directories containing file\n// 'strider.json'.  These are considered Strider modules. **dir** may be either a string or a list of strings.\n//\n// Or look for package.json with a \"strider\" key inside. (Preferred way now)\n//\n// **cb** is a function of signature cb(err, extensions) where extensions is an\n// {id : config} mapping on success and err is an error on failure.\n//\nfunction findExtensions(dir, cb) {\n  readDirs(dir, function(err, modules){\n    checkModules(modules, function(err, extensions){\n      parseModules(extensions, cb);\n    })\n  })\n}\n\nfunction findAndSortExtensions(dir, cb) {\n  findExtensions(dir, function(err, loaded){\n    if (err) return cb(err);\n\n    // Sort by weight\n    loaded = loaded.sort(function (a, b) { return a.weight - b.weight; });\n    cb(null, loaded);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/node_modules/async/lib/async.js":"/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-extension-loader/node_modules/underscore/underscore.js":"//     Underscore.js 1.5.2\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.5.2';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, length = obj.length; i < length; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results.push(iterator.call(context, value, index, list));\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? void 0 : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed > result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array, using the modern version of the \n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sample **n** random values from an array.\n  // If **n** is not specified, returns a single random element from the array.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (arguments.length < 2 || guard) {\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, value, context) {\n      var result = {};\n      var iterator = value == null ? _.identity : lookupIterator(value);\n      each(obj, function(value, index) {\n        var key = iterator.call(context, value, index, obj);\n        behavior(result, key, value);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, key, value) {\n    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, key, value) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, key) {\n    _.has(result, key) ? result[key]++ : result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n == null) || guard ? array[0] : slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) {\n      return array[array.length - 1];\n    } else {\n      return slice.call(array, Math.max(array.length - n, 0));\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    each(input, function(value) {\n      if (_.isArray(value) || _.isArguments(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var length = _.max(_.pluck(arguments, \"length\").concat(0));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, '' + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(length);\n\n    while(idx < length) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) throw new Error(\"bindAll must be passed function names\");\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = new Date();\n      var later = function() {\n        var last = (new Date()) - timestamp;\n        if (last < wait) {\n          timeout = setTimeout(later, wait - last);\n        } else {\n          timeout = null;\n          if (!immediate) result = func.apply(context, args);\n        }\n      };\n      var callNow = immediate && !timeout;\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] === void 0) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(Math.max(0, n));\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/app.js":"'use strict';\n// The Strider (web) app.\n\nvar debug = require('debug')('strider');\nvar chalk = require('chalk');\nvar express = require('express');\nvar EventEmitter = require('events').EventEmitter;\nrequire('everypaas');\n\nvar cors = require('cors');\nvar path = require('path');\nvar swig = require('swig');\n\n// middleware\nvar morganDebug = require('morgan-debug');\nvar bodyParser = require('body-parser');\nvar cookieParser = require('cookie-parser');\nvar compression = require('compression');\nvar expressSession = require('express-session');\nvar serveFavicon = require('serve-favicon');\nvar errorHandler = require('errorhandler');\nvar methodOverride = require('method-override');\nvar connectFlash = require('connect-flash');\nvar connectMongo = require('connect-mongo');\n\nvar mongoose = require('./mongoose-shim');\nvar Backchannel = require('./backchannel');\nvar common = require('./common');\nrequire('./logging');\nvar middleware = require('./middleware');\nvar routes = require('./routes');\nvar providerRouter = require('./routes/provider');\nvar websockets = require('./websockets');\nvar models = require('./models');\nvar auth = require('./auth');\nvar pluginTemplates = require('./plugin-templates');\nvar pjson = require('../package.json');\n\nvar routesAdmin = require('./routes/admin');\nvar routesJobs = require('./routes/jobs');\nvar api = require('./routes/api');\nvar collaboratorsRouter = require('./routes/collaborators');\nvar apiBranches = require('./routes/api/branches');\nvar apiJobs = require('./routes/api/jobs');\nvar apiRepo = require('./routes/api/repo');\nvar apiConfig = require('./routes/api/config');\n\nvar mongoStore = connectMongo(expressSession);\nvar MONTH_IN_MILLISECONDS = 2629743000;\nvar env = process.env.NODE_ENV || 'development';\nvar isDevelopment = env === 'development';\nvar isProduction = env === 'production';\nvar isTest = env === 'test';\nvar sessionStore;\n\nexports.init = function (config) {\n  var mongodbUrl = config.db_uri;\n  debug('Using MongoDB URL: %s', mongodbUrl);\n\n  mongoose.connect(mongodbUrl, function (error) {\n    if (error) {\n      console.log('Could not connect to DB: %s', error);\n      process.exit(1);\n    }\n  });\n\n  mongoose.connection.on('error', function (error) {\n    debug('MongoDB connection error: %s', error);\n  });\n\n  sessionStore = new mongoStore({\n    mongooseConnection: mongoose.connection\n  });\n\n  swig.init({\n    root: config.viewpath,\n    // allows errors to be thrown and caught by express instead of suppressed by Swig\n    allowErrors: true,\n    cache: false,\n    filters: require('./swig-filters'),\n    tags: require('./swig-tags').tags,\n    extensions: {plugin: pluginTemplates}\n  });\n\n  var app = express();\n\n  if (isDevelopment) {\n    app.use(morganDebug('strider:http', 'dev'));\n  }\n\n  if (isTest) {\n    // awesome view testingness\n    require('./views-test')(app);\n  }\n\n  app.set('views', path.join(__dirname, 'views'));\n  app.engine('html', pluginTemplates.engine);\n\n  if (config.cors) {\n    app.use(cors(config.cors));\n  }\n\n  app.use(middleware.bodySetter);\n  // parse application/x-www-form-urlencoded\n  app.use(bodyParser.urlencoded({extended: false, limit: config.body_parser_limit}));\n  // parse application/json\n  app.use(bodyParser.json({limit: config.body_parser_limit}));\n  app.use(cookieParser());\n  app.use(compression());\n  app.use(methodOverride());\n  app.use(serveFavicon(path.join(__dirname, '..', 'public', 'favicon.ico'), {maxAge: 2592000000}));\n\n  app.use(expressSession({\n    secret: config.session_secret, store: sessionStore,\n    cookie: {maxAge: MONTH_IN_MILLISECONDS},\n    resave: false,\n    saveUninitialized: true\n  }));\n  app.use(connectFlash());\n\n  app.use(function (req, res, next) {\n    res.locals.models = models;\n    next();\n  });\n\n  auth.setup(app); // app.use(passport) is included\n\n  app.use('/vendor', express.static(path.join(__dirname, '..', 'vendor'), {maxAge: MONTH_IN_MILLISECONDS}));\n  app.use(express.static(path.join(__dirname, '..', 'dist'), {maxAge: MONTH_IN_MILLISECONDS}));\n  app.use(express.static(path.join(__dirname, '..', 'public'), {maxAge: MONTH_IN_MILLISECONDS}));\n\n  if (!config.smtp) {\n    debug('No SMTP creds - forgot password flow will not work');\n  }\n\n  // Routes\n  app.get('/', routes.index);\n  app.get('/about', function (req, res) {\n    res.render('about');\n  });\n\n  app.get('/status', routes.status);\n  app.post('/login', function (req, res, next) {\n    if (!req.user) {\n      return next();\n    }\n\n    res.redirect('/');\n  }, auth.authenticate);\n  app.get('/logout', auth.logout);\n  app.get('/forgot', function (req, res) {\n    res.render('forgot.html', {\n      user: req.user,\n      messages: req.flash('error')\n    });\n  });\n  app.post('/forgot', auth.forgot);\n  app.get('/reset/:token', auth.reset);\n  app.post('/reset/:token', auth.resetPost);\n\n  // Compiled plugin config assets\n  app.get('/scripts/plugin-config-compiled.js', apiConfig.server('config', 'js'));\n  app.get('/styles/plugin-config-compiled.css', apiConfig.server('config', 'css'));\n  app.get('/scripts/account-plugins-compiled.js', apiConfig.server('account', 'js'));\n  app.get('/styles/account-plugins-compiled.css', apiConfig.server('account', 'css'));\n  app.get('/scripts/plugin-status-compiled.js', apiConfig.server('status', 'js'));\n  app.get('/styles/plugin-status-compiled.css', apiConfig.server('status', 'css'));\n\n  app.get('/admin/projects', auth.requireAdminOr401, routesAdmin.projects);\n  app.get('/admin/users', auth.requireAdminOr401, routesAdmin.users);\n  app.get('/admin/jobs', auth.requireAdminOr401, function (req, res) {\n    res.render('admin/jobs.html', {\n      version: pjson.version\n    });\n  });\n  app.get('/admin/make_admin', auth.requireAdminOr401, routesAdmin.makeAdmin);\n  app.post('/admin/remove_user', auth.requireAdminOr401, routesAdmin.removeUser);\n  app.get('/admin/invites', auth.requireAdminOr401, routesAdmin.invites);\n  app.get('/admin/:org/:repo/job/:job_id', auth.requireAdminOr401, routesAdmin.job);\n  app.get('/admin/plugins', auth.requireAdminOr401, routesAdmin.plugins.get);\n  app.put('/admin/plugins', auth.requireAdminOr401, routesAdmin.plugins.put);\n\n  app.use('/account', auth.requireUser, require('./routes/account'));\n  app.use('/projects', auth.requireUser, require('./routes/projects'));\n\n  // Requires at least read-only access to the repository in the path\n  app.get('/:org/:repo/', middleware.project, routesJobs.html);\n  app.put('/:org/:repo/', auth.requireUser, apiRepo.createProject);\n  app.get('/:org/:repo/job/:job_id?', middleware.project, routesJobs.multijob);\n  app.get('/:org/:repo/jobs/', middleware.project, routesJobs.jobs);\n  app.post('/:org/:repo/start', auth.requireUser, middleware.project, auth.requireProjectAdmin, apiJobs.jobsStart);\n  app.delete('/:org/:repo/cache', auth.requireUser, middleware.project, auth.requireProjectAdmin, apiRepo.clearCache);\n\n  app.delete('/:org/:repo/', middleware.project, auth.requireProjectAdmin, apiRepo.deleteProject);\n\n  // provider\n  app.use(providerRouter);\n\n  // collaborators\n  app.use(collaboratorsRouter);\n\n  // branches\n  app.use('/:org/:repo/branches/',\n    auth.requireUserOr401,\n    middleware.project,\n    auth.requireProjectAdmin,\n    apiBranches\n  );\n\n  // keygen\n  app.post('/:org/:repo/keygen/', auth.requireUser, middleware.project, auth.requireProjectAdmin, apiConfig.keygen);\n\n  /* Requires admin access to the repository in the path */\n  if ('development' === app.get('env')) {\n    app.get('/:org/:repo/config(/*)', auth.requireUser, middleware.project, auth.requireProjectAdmin, routes.reloadConfig, routes.config);\n  } else {\n    app.get('/:org/:repo/config(/*)', auth.requireUser, middleware.project, auth.requireProjectAdmin, routes.config);\n  }\n\n  app.put('/:org/:repo/config', auth.requireUser, middleware.project, auth.requireProjectAdmin, routes.setConfig);\n\n  app.all(\n    '/:org/:repo/config/branch/runner(/*)',\n    auth.requireUser,\n    middleware.project,\n    auth.requireProjectAdmin\n  );\n  app.get('/:org/:repo/config/branch/runner', routes.getRunnerConfig);\n  app.put('/:org/:repo/config/branch/runner', routes.setRunnerConfig);\n  app.put('/:org/:repo/config/branch/runner/id', routes.setRunnerId);\n  app.all(\n    '/:org/:repo/config/branch/:plugin',\n    auth.requireUser,\n    middleware.project,\n    auth.requireProjectAdmin,\n    middleware.projectPlugin\n  );\n  app.get('/:org/:repo/config/branch/:plugin', routes.getPluginConfig);\n  app.put('/:org/:repo/config/branch/:plugin', routes.setPluginConfig);\n  app.put('/:org/:repo/config/branch/', auth.requireUser, middleware.project, auth.requireProjectAdmin, routes.configureBranch);\n\n  // app.get('/api/job/:id', apiJobs.raw);\n  app.use('/api', api);\n  app.get('/api/jobs', auth.requireUserOr401, apiJobs.jobs);\n  // app.get('/api/jobs/:org/:repo', middleware.project, apiJobs.repoJobs);\n\n  app.use(function (req, res, next) {\n    var userCreatedTimestamp = 0;\n    if (req.user !== undefined) {\n      userCreatedTimestamp = parseInt(req.user.id.substr(0, 8), 16);\n    }\n    res.locals.user_created_timestamp = userCreatedTimestamp;\n    next();\n  });\n\n  common.app = app;\n  common.session_store = sessionStore;\n  //\n  // ### Strider Webapp Event Emitter\n  //\n  // Strider has a Node.Js Event Emitter which emits many events.  This can be\n  // used by extensions to add extremely flexible custom handling for just about\n  // anything.\n  //\n  common.emitter = new EventEmitter();\n\n  return app;\n};\n\nexports.run = function (app) {\n  var config = require('./config');\n\n  if (isDevelopment) {\n    app.use(errorHandler({dumpExceptions: true, showStack: true}));\n  }\n\n  if (isProduction) {\n    app.use(errorHandler({dumpExceptions: true, showStack: false}));\n  }\n\n  // Custom 404 handler.\n  // Run after extensions, which might load static middlewares.\n  app.use(middleware.custom404);\n\n  // Initialize socket.io\n  var server = app.listen(config.port, config.host);\n  var sockets = websockets.init(server, sessionStore);\n  new Backchannel(common.emitter, sockets);\n\n  console.log(chalk.green('Express server listening on port %s in %s mode'), config.port, app.settings.env);\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/mongoose-shim.js":"'use strict';\n\nvar Promise = require('bluebird');\nvar mongoose = require('mongoose');\n\nmongoose.Promise = Promise;\n\nmodule.exports = mongoose;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/backchannel.js":"'use strict';\n\n/*\n * Backchannel server allows workers to stream messages back to the Node server\n * in a line-buffered way. Uses SSL.\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar common = require('./common');\nrequire('./config');\nvar debug = require('debug')('strider:backchannel');\nvar jobs = require('./jobs');\nvar models = require('./models');\nvar utils = require('./utils');\n\nvar Job = models.Job;\nvar User = models.User;\nvar Project = models.Project;\n\nfunction striderJson(provider, project, ref, done) {\n  function finished(err, contents) {\n    if (err || !contents) return done(err);\n\n    var data = {};\n\n    try {\n      data = JSON.parse(contents);\n    } catch (e) {\n      debug('Strider config is invalid JSON for', project, ref);\n      debug(contents);\n    }\n\n    done(undefined, data);\n  }\n\n  if (!provider.hosted) {\n    return provider.getFile('strider.json', ref, project.provider.config, project, finished);\n  }\n\n  var account = project.creator.account(project.provider.id, project.provider.account);\n\n  provider.getFile('strider.json', ref, account.config, project.provider.config, project, finished);\n}\n\n/**\n * Prepare the job for execution, save to database, and fire off a `job.new` event.\n *\n * job is expected to be populated with:\n * - a trigger\n * - a ref\n * - the project name\n * - the user id (if applicable)\n * - type\n * - created timestamp\n *\n * XXX: should this function go in a different file? idk. We'll\n * definitely move it around when we make strider OO.\n */\nfunction prepareJob(emitter, job) {\n  Project.findOne({ name: job.project }).populate('creator').exec(function (err, project) {\n    if (err || !project) return debug('job.prepare - failed to get project', job.project, err);\n    // ok so the project is real, we can go ahead and save this job\n    var provider = common.extensions.provider[project.provider.id];\n\n    if (!provider) {\n      return debug('job.prepare - provider not found for project', job.project, project.provider.id);\n    }\n\n    Job.create(job, function (err, mjob) {\n      if (err) return debug('job.prepare - failed to save job', job, err);\n\n      var jjob = mjob.toJSON();\n\n      jjob.project = project;\n      jjob.providerConfig = project.provider.config;\n      jjob.fromStriderJson = true;\n\n      striderJson(provider, project, job.ref, function (err, config) {\n        if (err) {\n          if (err.status === 403 || err.statusCode === 403) {\n            debug('job.prepare - access to strider.json is forbidden, skipping config merge');\n            config = {};\n            jjob.fromStriderJson = false;\n          } else if (err.status === 404 || err.statusCode === 404) {\n            debug('job.prepare - strider.json not found, skipping config merge');\n            config = {};\n            jjob.fromStriderJson = false;\n          } else {\n            debug('job.prepare - error opening/processing project\\'s `strider.json` file: ', err);\n            config = {};\n            jjob.fromStriderJson = false;\n          }\n        } else {\n          debug('Using configuration from \"strider.json\".');\n        }\n\n        var branch = project.branch(job.ref.branch || 'master');\n\n        if (!branch) {\n          return debug('job.prepare - branch not found', job.ref.branch || 'master', project.name);\n        }\n\n        branch = branch.mirror_master ? project.branch('master') : branch;\n        jjob.providerConfig = _.extend({}, project.provider.config, config.provider || {});\n        config.runner = config.runner || branch.runner;\n\n        if (!common.extensions.runner[config.runner.id]) {\n          debug(`Error: A job was registered for a runner that doesn't exist, i.e. \"${config.runner.id}\". This job will never run!`);\n        }\n\n        if (config) {\n          delete config.provider;\n          config = utils.mergeConfigs(branch, config);\n        }\n\n        emitter.emit('job.new', jjob, config);\n\n        if (!mjob.runner) mjob.runner = {};\n\n        mjob.runner.id = config.runner.id;\n        mjob.save()\n          .then(() => debug('job saved'))\n          .catch(e => debug(e));\n      });\n    });\n  });\n}\n\nfunction BackChannel(emitter, ws) {\n  this.ws = ws;\n  this.users = {};\n  this.public = {};\n  this.waiting = {};\n\n  emitter.on('job.prepare', prepareJob.bind(null, emitter));\n  emitter.on('job.new', this.newJob.bind(this));\n  emitter.on('browser.update', this.onUpdate.bind(this));\n  emitter.on('job.done', this.jobDone.bind(this, emitter));\n}\n\nBackChannel.prototype = {\n  send: function (project, event, args) {\n    if (this.users[project]) {\n      this.ws.send(this.users[project], [event, args, 'yours']);\n    }\n    if (this.public[project]) {\n      this.ws.sendPublic(this.users[project], [event, args, 'public']);\n    }\n  },\n\n  sendJobs: function (project, event, args) {\n    if (this.users[project]) {\n      this.ws.sendEach(this.users[project], function (user) {\n        return [event, args.map(function (job) {\n          job = _.assign({}, job);\n          job.project = _.assign({}, job.project);\n          job.project.access_level = User.projectAccessLevel(user, job.project);\n          return job;\n        }), 'yours'];\n      });\n    }\n    if (this.public[project]) {\n      this.ws.sendPublic(this.users[project], [event, args.map(function (job) {\n        job = _.assign({}, job);\n        job.project = _.assign({}, job.project);\n        job.project.access_level = 0;\n        return job;\n      }), 'public']);\n    }\n  },\n\n  newJob: function (job) {\n    debug('new job was created');\n    var self = this;\n    var name = job.project.name;\n\n    this.waiting[name] = [];\n    this.public[name] = job.project.public;\n\n    async.parallel({\n      collaborators: function (paraCallback) {\n        User.collaborators(name, 0, function (err, users) {\n          paraCallback(err, users);\n        });\n      },\n\n      admins: function (paraCallback) {\n        User.admins(paraCallback);\n      }\n    }, function (err, users) {\n      if (err) return debug('new job: Failed to query for users');\n      if (!users.collaborators) return debug('new job: no users found');\n      self.users[name] = [];\n\n      users.collaborators.forEach(function (user) {\n        self.users[name].push(user._id.toString());\n      });\n      // also send to system admins\n      users.admins.forEach(function (user) {\n        self.users[name].push(user._id.toString());\n      });\n\n      // Admins maybe collaborators, so unique the array\n      self.users[name] = _.uniq(self.users[name]);\n\n      var njob = jobs.small(job);\n\n      njob.project = utils.sanitizeProject(job.project);\n      self.sendJobs(name, 'job.new', [njob]);\n\n      var waiting = self.waiting[name];\n      if (Array.isArray(waiting)) {\n        waiting.forEach(function (item) {\n          self.send.apply(self, [name].concat(item));\n        });\n      }\n      delete self.waiting[name];\n    });\n  },\n  // [project name, event name, [list of arguments]]\n  onUpdate: function (project, event, args) {\n    if (this.waiting[project]) {\n      return this.waiting[project].push([event, args]);\n    }\n    this.send(project, event, args);\n    if (event === 'job.status.started') {\n      Job.findById(args[0], function (err, job) {\n        if (err) return debug('[backchannel][job.status.started] error getting job', args[0], err);\n        if (!job) return debug('[backchannel][job.status.started] job not found', args[0]);\n        job.started = args[1];\n        job.save();\n      });\n    }\n  },\n  jobDone: function (emitter, data) {\n    var self = this;\n    Job.findById(data.id, function (err, job) {\n      if (err) return debug('Error finding job', err.message);\n      if (!job) return debug('job.done but job not found:', data.id);\n      _.extend(job, data);\n      try {\n        job.duration = data.finished.getTime() - data.started.getTime();\n      } catch (ignore) {\n        job.duration = 1;\n      }\n      job.markModified('phases');\n      job.markModified('plugin_data');\n      job.test_exitcode = job.phases.test && job.phases.test.exitCode;\n      job.deploy_exitcode = job.phases.deploy && job.phases.deploy.exitCode;\n      job.save();\n      job = job.toJSON();\n\n      Project.findOne({name: job.project}).lean().exec(function (err, project) {\n        if (err) return debug('Error finding project for job', err.message, job.project);\n        if (!project) return debug('Project for job.done not found', job.project);\n\n        job.project = utils.sanitizeProject(project);\n        job.status = jobs.status(job);\n        self.sendJobs(project.name, 'job.done', [job]);\n        emitter.emit('job.doneAndSaved', job);\n      });\n    });\n  }\n};\n\nmodule.exports = BackChannel;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/common.js":"'use strict';\n\n// Object for storing common state between modules.\nmodule.exports = {\n  project_types: {\n    'node.js': {\n      description: 'nave, npm install, npm test',\n      plugins: ['node']\n    },\n    python: {\n      description: 'virtualenv, pip install, ./setup.py test or py.test',\n      plugins: ['python']\n    },\n    ruby: {\n      description: 'bundle install, bundle exec rake test',\n      plugins: ['ruby']\n    },\n    go: {\n      description: 'go get, go test',\n      plugins: ['go']\n    },\n    web: {\n      description: 'sauce, qunit, and jelly to test your javascript in a browser.',\n      plugins: ['sauce', 'qunit', 'jelly']\n    },\n    custom: {\n      description: 'Don\\'t auto-enable any plugins.',\n      plugins: []\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/config.js":"'use strict';\n\nmodule.exports = require('./libconfig').getConfig();\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/libconfig.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar everypaas = require('everypaas');\nvar _ = require('lodash');\nvar debug = require('debug')('strider:config');\nvar pjson = require('../package.json');\nvar hasGithub = pjson && pjson.dependencies['strider-github'];\n\nvar envDefaults = {\n  host: process.env.HOST || '0.0.0.0',\n  port: process.env.PORT || 3000,\n  server_name: 'http://localhost',\n\n  db_uri: everypaas.getMongodbUrl() || 'mongodb://localhost/strider-foss',\n\n  smtp_host: '',\n  smtp_port: 587,\n  smtp_user: '',\n  smtp_pass: '',\n  smtp_from: 'Strider <noreply@stridercd.com>',\n  smtp_secure: '',\n\n  enablePty: false,\n  extpath: 'node_modules',\n  session_secret: '8L8BudMkqBUqrz',\n\n  github_app_id: '',\n  github_secret: '',\n\n  cors: false,\n  body_parser_limit: false,\n  ldap: false\n};\n\nenvDefaults.server_name = `${envDefaults.server_name}:${envDefaults.port}`;\n\nvar defaults = _.extend({\n  // Logging configuration\n  logging: {\n    exitOnError: true,\n    file_enabled: false,\n    console: {\n      // Log everything\n      level: 0,\n      colorize: true,\n      timestamp: true\n    },\n    console_enabled: true\n  },\n  viewpath: path.join(__dirname, 'views')\n}, envDefaults);\n\nmodule.exports = {\n  defaults: defaults,\n  deprecated: deprecated,\n  smtp: smtp,\n  filterEnv: filterEnv,\n  addPlugins: addPlugins,\n  camel: camel,\n  getConfig: getConfig\n};\n\n// main function. Get the config, using rc\nfunction getConfig() {\n  process.env = filterEnv(deprecated(process.env), envDefaults);\n  var rc = require('rc')('strider', defaults);\n\n  if (!rc.smtp) rc.smtp = smtp(rc);\n  if (!rc.smtp) rc.stubSmtp = true;\n\n  rc.ldap = getConfigByName('ldap');\n\n  addPlugins(rc, process.env);\n\n  // BACK COMPAT until we get strider config into plugins...\n  if (hasGithub) {\n    rc.plugins.github = rc.plugins.github || {};\n    rc.plugins.github.hostname = rc.server_name;\n  }\n\n  debug(rc);\n\n  return rc;\n}\n\nfunction getConfigByName(filname) {\n  var configPath = path.join(__dirname, '..', `${filname}.json`);\n  if (fs.existsSync(configPath)) {\n    return require(configPath);\n  } else {\n    return false;\n  }\n}\n\nfunction camel(words) {\n  return words[0] + words.slice(1)\n    .map(function (word) {\n      return word[0].toUpperCase() + word.slice(1);\n    }).join('');\n}\n\nfunction addPlugins(rc, env) {\n  var parts;\n  if (!rc.plugins) rc.plugins = {};\n  for (var key in env) {\n    if (!key.match(/^plugin_/i)) continue;\n    parts = key.toLowerCase().split('_');\n    if (parts.length === 2) {\n      try {\n        rc.plugins[parts[1]] = JSON.parse(env[key]);\n      } catch (e) {\n        console.warn('Ignoring config because it\\'s not valid JSON: ', key, env[key]);\n      }\n      continue;\n    }\n    if (!rc.plugins[parts[1]]) rc.plugins[parts[1]] = {};\n    rc.plugins[parts[1]][camel(parts.slice(2))] = env[key];\n  }\n}\n\n// Filter process.env.FOO to process.env.strider_foo for rc's benefit\nfunction filterEnv(env, defaults) {\n  var res = {};\n  for (var k in env) {\n    if (defaults[k.toLowerCase()] !== undefined) {\n      res[`strider_${k.toLowerCase()}`] = env[k];\n    } else {\n      res[k] = env[k];\n    }\n  }\n  return res;\n}\n\nfunction deprecated(env) {\n  var nenv = _.extend({}, env);\n  if (env.APP_ID) {\n    console.warn('WARNING: You are using APP_ID to configure Github OAuth application id.');\n    console.warn('This name has been deprecated. Please use PLUGIN_GITHUB_APP_ID instead.\\n');\n    nenv.PLUGIN_GITHUB_APP_ID = env.APP_ID;\n  }\n  if (env.APP_SECRET) {\n    console.warn('WARNING: You are using APP_SECRET to configure Github OAuth application secret.');\n    console.warn('This name has been deprecated. Please use PLUGIN_GITHUB_APP_SECRET instead.\\n');\n    nenv.PLUGIN_GITHUB_APP_SECRET = env.APP_SECRET;\n  }\n  if (env.GITHUB_APP_ID) {\n    console.warn('WARNING: You are using GITHUB_APP_ID to configure Github OAuth application id.');\n    console.warn('This name has been deprecated. Please use PLUGIN_GITHUB_APP_ID instead.\\n');\n    nenv.PLUGIN_GITHUB_APP_ID = env.GITHUB_APP_ID;\n  }\n  if (env.GITHUB_SECRET) {\n    console.warn('WARNING: You are using GITHUB_SECRET to configure Github OAuth application secret.');\n    console.warn('This name has been deprecated. Please use PLUGIN_GITHUB_APP_SECRET instead.\\n');\n    nenv.PLUGIN_GITHUB_APP_SECRET = env.GITHUB_SECRET;\n  }\n  if (env.GITHUB_API_ENDPOINT) {\n    console.warn('WARNING: You are using GITHUB_API_ENDPOINT to configure Github API base URL.');\n    console.warn('This name has been deprecated. Please use PLUGIN_GITHUB_API_BASE instead.\\n');\n    nenv.PLUGIN_GITHUB_API_BASE = env.GITHUB_API_ENDPOINT;\n  }\n  return nenv;\n}\n\nfunction smtp(rc) {\n  if (!rc.smtp_host) {\n    return;\n  }\n\n  var options = {\n    host: rc.smtp_host,\n    port: rc.smtp_port,\n    from: rc.smtp_from,\n    secure: rc.smtp_secure\n  };\n\n  if (rc.smtp_user) {\n    options.auth = {\n      user: rc.smtp_user,\n      pass: rc.smtp_pass\n    };\n  }\n\n  return options;\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/jobs.js":"'use strict';\n\nmodule.exports = {\n  latestJobs: latestJobs,\n  jobProject: jobProject,\n  sort: jobSort,\n  status: status,\n  small: small\n};\n\nvar async = require('async');\nvar Job = require('./models').Job;\nvar User = require('./models').User;\nvar Project = require('./models').Project;\nvar utils = require('./utils');\n\nvar TEST_ONLY = 'TEST_ONLY';\n\n/**\n * user: user object\n * small: if true, \"phases\" and \"std\" will not be fetched for the jobs\n *  - dramatically reducing the size of the object.\n * TODO: add paging\n * done(err, {yours: [...], public: [...]})\n * \n * @param {Object} user\n * @param {Boolean} small\n * @param {Function} done\n */\nfunction latestJobs(user, small, done) {\n  if (arguments.length === 2) {\n    done = small;\n    small = false;\n  }\n  var tasks = { public: latestPublicJobs.bind(null, user, small) };\n  if (user) {\n    tasks.yours = latestUsersJobs.bind(null, user, small);\n  }\n  async.parallel(tasks, done);\n}\n\n// failed, passed, errored, running, submitted\nfunction status(job) {\n  if (job.errored) return 'errored';\n  if (!job.started) return 'submitted';\n  if (!job.finished) return 'running';\n  if (job.test_exitcode !== 0) return 'failed';\n  if (job.type !== TEST_ONLY && job.deploy_exitcode !== 0) return 'failed';\n  return 'passed';\n}\n\nfunction small(job) {\n  var big = ['phases', 'plugin_data', 'std', 'stderr', 'stdout', 'stdmerged'];\n  var njob = {};\n  if (job.toJSON) job = job.toJSON();\n  for (var name in job) {\n    if (big.indexOf(name) !== -1) continue;\n    njob[name] = job[name];\n  }\n  njob.status = status(job);\n  return njob;\n}\n\nfunction jobProject(project, prev, user) {\n  prev.forEach(function (job) {\n    job.status = status(job);\n  });\n\n  project = utils.sanitizeProject(project);\n  project.prev = prev;\n\n  if (user) {\n    project.access_level = User.projectAccessLevel(user, project);\n  }\n\n  return project;\n}\n\nfunction latestJob(project, user, small, done) {\n  var query = Job.find({project: project.name.toLowerCase(), archived: null})\n    .sort({finished: -1})\n    .limit(6)\n    .lean();\n\n  if (small) {\n    query = query.select('-phases -std');\n  }\n\n  query.exec(function (err, jobs) {\n    if (!jobs || !jobs.length) {\n      return done(err, { nojobs: true, project: jobProject(project, [], user) });\n    }\n    var job = jobs[0];\n    job.project = jobProject(project, jobs.slice(1));\n    job.project.access_level = User.projectAccessLevel(user, project);\n    job.status = status(job);\n    done(err, job);\n  });\n}\n\nfunction projectJobs(projects, user, small, done) {\n  if (arguments.length === 2) {\n    done = small;\n    small = false;\n  }\n  var tasks = [];\n  projects.forEach(function (project) {\n    tasks.push(latestJob.bind(null, project, user, small));\n  });\n  async.parallel(tasks, function (err, jobs) {\n    if (err) return done(err);\n    jobs.sort(jobSort);\n    done(null, jobs);\n  });\n}\n\nfunction latestPublicJobs(user, small, done) {\n  // If we are an admin, all projects will be returned in UserJobs\n  if (user && user.account_level > 0) return done(null, []);\n  if (arguments.length === 2) {\n    done = small;\n    small = false;\n  }\n  var query = Project.find({public: true}).lean();\n  if (user) {\n    var userProjects = user.projects.map(function (p) {\n      return p.name.toLowerCase();\n    });\n    query = query.where('name', {$not: {$in: userProjects || []}});\n  }\n  query.exec(function (err, projects) {\n    if (err) return done(err);\n    projectJobs(projects, user, small, function (err, jobs) {\n      if (err) return done(err);\n      done(null, jobs.map(function (job) {\n        job.project.access_level = 0;\n        return job;\n      }));\n    });\n  });\n}\n\nfunction latestUsersJobs(user, small, done) {\n  if (arguments.length === 2) {\n    done = small;\n    small = false;\n  }\n  Project.forUser(user, function (err, projects) {\n    if (err) return done(err);\n    projectJobs(projects, user, small, done);\n  });\n}\n\nfunction jobSort(a, b) {\n  if (a.nojobs) {\n    if (b.nojobs) return 0;\n    return -1;\n  }\n  if (b.nojobs) return 1;\n  if (a.status === 'running') {\n    if (b.status === 'running') return 0;\n    return -1;\n  }\n  if (b.status === 'running') return 1;\n  if (a.status === 'submitted') {\n    if (b.status === 'submitted') return 0;\n    return -1;\n  }\n  if (b.status === 'submitted') return 1;\n  if (!a.finished || !a.finished.getTime) return -1;\n  if (!b.finished || !b.finished.getTime) return 1;\n  return b.finished.getTime() - a.finished.getTime();\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/models/index.js":"'use strict';\n\nvar mongoose = require('../mongoose-shim');\n\nmongoose.models = {};\n\nmodule.exports = {\n  InviteCode: require('./invite'),\n  Job: require('./job'),\n  User: require('./user'),\n  Project: require('./project'),\n  Config: require('./config')\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/models/invite.js":"'use strict';\n\nvar mongoose = require('../mongoose-shim');\nvar Schema = mongoose.Schema;\n\nvar InviteCodeSchema = new Schema({\n  code: {type: String, unique: true},\n  created_timestamp: Date,\n  consumed_timestamp: Date,\n  emailed_to: {type: String, index: true},\n  consumed_by_user: {type: Schema.ObjectId, ref: 'user'},\n  collaborations: [\n    {\n      project: String,\n      access_level: Number,\n      invited_by: {type: Schema.ObjectId, ref: 'user'}\n    }\n  ]\n});\n\nmodule.exports = mongoose.model('InviteCode', InviteCodeSchema);\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/models/job.js":"'use strict';\n\nvar mongoose = require('../mongoose-shim');\nvar Schema = mongoose.Schema;\n\nvar TriggerNotSchema = {\n  type: {type: String},\n  author: {\n    id: {type: Schema.ObjectId, ref: 'user'},\n    url: String,\n    name: String,\n    email: String,\n    image: String,\n    username: String\n  },\n  message: String,\n  timestamp: Date,\n  url: String,\n  source: {}\n  // source looks like:\n  // { type: \"plugin\", plugin: \"github\" } ||\n  // { type: \"UI\", page: \"dashboard\" } ||\n  // { type: \"API\", app: \"MyApp\" }\n};\n\nvar PhaseNotSchema = {\n  duration: Number,\n  finished: Date,\n  exitCode: Number,\n  commands: [{\n    started: Date,\n    duration: Number,\n    command: String,\n    comment: Boolean,\n    plugin: String,\n    out: String,\n    err: String,\n    merged: String\n  }]\n};\n\nvar JobSchema = new Schema({\n  type: {type: String},\n  user_id: {type: Schema.ObjectId, ref: 'user'},\n  project: {type: String, index: true}, // should always be lower case\n  ref: {\n    // not every job is on a branch, and want arbitrary stuff here.\n    // so we can't specify branch, but we still want an index on it\n    // branch: { type: String, index: true, sparse: true }\n  },\n  trigger: TriggerNotSchema,\n  phases: {\n    environment: PhaseNotSchema,\n    prepare: PhaseNotSchema,\n    test: PhaseNotSchema,\n    deploy: PhaseNotSchema,\n    cleanup: PhaseNotSchema\n  },\n  // plugins can store any extra data here\n  plugin_data: {},\n  warnings: [{\n    plugin: String,\n    title: String,\n    description: String,\n    severity: {type: String, default: 'major', enum: ['major', 'minor']}\n  }],\n  std: {\n    out: String,\n    err: String,\n    merged: String\n  },\n  duration: Number,\n  created: {type: Date, index: true},\n  queued: Date,\n  started: Date,\n  finished: {type: Date, index: true},\n  archived: {type: Date, index: true},\n  test_exitcode: Number,\n  deploy_exitcode: Number,\n  errored: {type: Boolean, default: false},\n  error: {\n    message: String,\n    stack: String\n  },\n  runner: {\n    id: String,\n    data: {}\n  }\n});\n\nJobSchema.index({archived: 1, project: 1, finished: -1});\n\nmodule.exports = mongoose.model('Job', JobSchema);\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/models/user.js":"'use strict';\n\nvar bcrypt = require('bcryptjs');\nvar Activedirectory = require('activedirectory');\nvar config = require('../config');\nvar mongoose = require('../mongoose-shim');\nvar InviteCode = require('./invite');\n\nvar Schema = mongoose.Schema;\nvar User;\n\n// active directory schema\nvar AdSchema = config.ldap ? new Activedirectory(config.ldap) : null;\n\nvar UserSchema = new Schema({\n  email: {type: String, required: true, index: true, unique: true},\n  salt: {type: String, required: true},\n  hash: {type: String, required: true},\n  resetPasswordToken: String,\n  resetPasswordExpires: Date,\n  // Is login by active directory, default false\n  isAdUser: { type: Boolean, default: false },\n  // 0 = normal user, 1 = strider admin\n  account_level: Number,\n  // defined by provider plugins\n  accounts: [{\n    provider: String, // name of the provider plugin\n    id: String,       // account id, defined by the provider\n    title: String,    // human readable account name\n    display_url: String, // url to view your account on the hosted site\n    // cache for provided repos\n    cache: [{\n      id: String,          // unique ID, saved as \"repo_id\" in the provider section of the created project\n      name: String,        // human readable, displayed to the user\n      display_name: String,\n      config: {},\n      display_url: String, // a url where the user can view the repo in a browser\n      group: String        // a string for grouping the repos. In github, this would be the \"organization\"\n    }],\n    last_updated: Date,\n    config: {}\n  }],\n  // user-level config\n  jobplugins: {},\n  // array of objects {name: \"projectname\", access_level: (int), display_name: (string)}\n  projects: [\n    {\n      name: {type: String, index: true}, // lower-case canonical name\n      display_name: String, // could be mixed case\n      access_level: Number  // 0 - view jobs, 1 - start jobs, 2 - configure/admin\n    }\n  ],\n  jobs: [{type: Schema.ObjectId, ref: 'Job'}],\n  created: Date\n});\n\nUserSchema.virtual('password')\n  .get(function () {\n    return this._password;\n  })\n  .set(function (password) {\n    this._password = password;\n    var salt = this.salt = bcrypt.genSaltSync(10);\n    this.hash = bcrypt.hashSync(password, salt);\n  });\n\n// User.collaborators(project, [accessLevel,] done(err, [user, ...]))\n//\n// project: String name of the project\n// accessLevel: int minimum access level. Defaults to 1\nUserSchema.static('collaborators', function (project, accessLevel, done) {\n  if (arguments.length === 2) {\n    done = accessLevel;\n    accessLevel = 1;\n  }\n\n  var query = {\n    'projects': {\n      '$elemMatch': {\n        'name': project.toLowerCase(),\n        'access_level': {$gte: accessLevel}\n      }\n    }\n  };\n\n  this.find(query, done);\n});\n\n// User.admins(done(err, [user, ...]))\nUserSchema.static('admins', function (done) {\n  var query = {'account_level': 1};\n\n  this.find(query, done);\n});\n\n// User.account(providerconfig)\n// User.account(providerid, accountid)\n// --> the account config that matches\n// Throws an error if the account cannot be found.\nUserSchema.method('account', function (provider, account) {\n  if (arguments.length === 1) {\n    account = provider.account;\n    provider = provider.id;\n  }\n\n  for (var i = 0; i < this.accounts.length; i++) {\n    if (this.accounts[i].provider == provider &&\n      this.accounts[i].id == account) {\n      return this.accounts[i];\n    }\n  }\n\n  return false;\n});\n\nUserSchema.method('verifyPassword', function (password, callback) {\n  bcrypt.compare(password, this.get('hash'), callback);\n});\n\nUserSchema.method('jobPluginData', function (name, config, done) {\n  if (!this.jobplugins) {\n    this.jobplugins = {};\n  }\n\n  if (arguments.length === 1) {\n    return this.jobplugins[name];\n  }\n\n  this.jobplugins[name] = config;\n  this.markModified('jobplugins');\n  this.save(done);\n});\n\nUserSchema.static('getUserInfoFromActiveDirectory', function (email, callback) {\n  AdSchema.findUser(email, function (err, user) {\n    if (err) {\n      return callback(err, true);\n    }\n\n    if (!user) {\n      return callback('No User', false);\n    }\n\n    return callback(null, user);\n  });\n});\n\n// Login by active directory\nUserSchema.static('loginByActiveDirectory', function (email, password, callback) {\n  AdSchema.authenticate(email, password, function (err, auth) {\n    if (err) {\n      return callback(err, true);\n    }\n\n    if (!auth) {\n      return callback('No User', false);\n    }\n\n    return this.getUserInfoFromActiveDirectory(email, callback);\n  }.bind(this));\n});\n\nUserSchema.static('authenticate', function (email, password, callback) {\n  // Has ad config\n  if (config.ldap) {\n\n    this.loginByActiveDirectory(email, password, function (err, adUser) {\n      console.log(`Active directory login msg: ${err},  User info`, adUser);\n      if (err && !adUser) {\n        this.findOne({email: email, isAdUser: false}, function (err, user) {\n          if (err) {\n            return callback(err);\n          }\n\n          if (!user) {\n            return callback('No User', false);\n          }\n\n          user.verifyPassword(password, function (err, passwordCorrect) {\n            if (err) {\n              return callback(err);\n            }\n\n            if (!passwordCorrect) {\n              return callback('Incorrect Password', false);\n            }\n\n            return callback(null, user);\n          });\n        });\n      } else if(err) {\n        return callback(err);\n      }\n\n      this.findOne({email: email, isAdUser: true}, function (err, user) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!user) {\n          var isAdmin = false;\n          if (config.ldap.adminDN && adUser.dn.indexOf(config.ldap.adminDN) !== -1) {\n            isAdmin = true;\n          }\n          // register and return new user\n          return this.register({\n            isAdUser: true,\n            isAdmin: isAdmin,\n            email: adUser.mail\n          }, callback);\n        }\n\n        return callback(null, user);\n      }.bind(this));\n    }.bind(this));\n\n  } else {\n    // Normal login\n    this.findOne({email: email}, function (err, user) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (!user) {\n        return callback('No User', false);\n      }\n\n      user.verifyPassword(password, function (err, passwordCorrect) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!passwordCorrect) {\n          return callback('Incorrect Password', false);\n        }\n\n        return callback(null, user);\n      });\n    });\n  }\n});\n\nUserSchema.static('findByEmail', function (email, cb) {\n  this.find({email: {$regex: new RegExp(email, 'i')}}, cb);\n});\n\nUserSchema.static('register', function (u, callback) {\n  // Create User\n  var user = new User();\n  user.isAdUser = !!u.isAdUser;\n  user.account_level = u.isAdmin ? 1 : 0;\n  user.email = u.email.toLowerCase();\n  user.created = new Date();\n  user.set('password', u.isAdUser ? '' : u.password);\n  user.projects = u.projects || [];\n\n  user.save(function (error, user) {\n    if (error) {\n      return callback(`Error Creating User:${error}`);\n    }\n    callback(null, user);\n  });\n});\n\n\nUserSchema.static('registerWithInvite', function (inviteCode, email, password, cb) {\n  // Check Invite Code\n  InviteCode.findOne({\n    code: inviteCode,\n    emailed_to: email,\n    consumed_timestamp: null\n  }, function (err, invite) {\n    if (err || !invite) {\n      return cb('Invalid Invite');\n    }\n\n    var projects = [];\n    // For each collaboration in the invite, add permissions to the repo_config\n    if (invite.collaborations !== undefined && invite.collaborations.length > 0) {\n      invite.collaborations.forEach(function (item) {\n        projects.push({\n          name: item.project.toLowerCase(),\n          access_level: item.access_level,\n          display_name: item.project.toLowerCase()\n        });\n      });\n    }\n\n    this.register({\n      isAdUser: false,\n      email: email,\n      password: password,\n      projects: projects\n    }, function (err, user) {\n      if (err) {\n        return cb(err);\n      }\n      // Mark Invite Code as used.\n      InviteCode.update({\n        code: inviteCode\n      }, {\n        '$set': {\n          consumed_timestamp: new Date(),\n          consumed_by_user: user._id\n        }\n      }, {}, function (err) {\n        if (err) {\n          return cb(`Error updating invite code, user was created: ${err}`);\n        } else {\n          return cb(null, user);\n        }\n      });\n    });\n\n  }.bind(this));\n});\n\n\n\nUserSchema.method('projectAccessLevel', function (project) {\n  if (this.account_level > 0) {\n    return 2;\n  }\n\n  if (this.projects) {\n    for (var i = 0; i < this.projects.length; i++) {\n      if (this.projects[i].name === project.name) {\n        return this.projects[i].access_level;\n      }\n    }\n  }\n\n  if (project.public) {\n    return 0;\n  }\n\n  return -1;\n});\n\nUserSchema.static('projectAccessLevel', function (user, project) {\n  if (user) {\n    return user.projectAccessLevel(project);\n  }\n\n  if (project.public) {\n    return 0;\n  }\n\n  return -1;\n});\n\nUser = module.exports = mongoose.model('user', UserSchema);\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/models/project.js":"'use strict';\n\nvar _ = require('lodash');\nvar mongoose = require('../mongoose-shim');\nvar findBranch = require('../utils').findBranch;\nvar Schema = mongoose.Schema;\n\nvar PluginConfig = new Schema({\n  id: String,\n  config: {},\n  showStatus: {\n    type: Boolean,\n    default: true\n  },\n  enabled: Boolean\n});\n\nvar BranchConfig = new Schema({\n  active: {\n    type: Boolean,\n    default: true\n  },\n  name: { type: String },\n  mirror_master: {\n    type: Boolean,\n    default: true\n  },\n  deploy_on_green: {\n    type: Boolean,\n    default: true\n  },\n  deploy_on_pull_request: {\n    type: Boolean,\n    default: false\n  },\n  // ssh keypair\n  pubkey: String,\n  privkey: String,\n  // add the ssh keys to the ENV\n  envKeys: Boolean,\n  // job & runner plugins\n  plugins: [PluginConfig],\n  runner: {\n    id: String,\n    config: {}\n  },\n  // for persistance, not configuration\n  plugin_data: {}\n});\n\nvar ProjectSchema = new Schema({\n  // name is always lower case!\n  name: {\n    type: String,\n    unique: true,\n    index: true\n  },\n  display_name: { type: String }, // display name can be mixed case, for display\n  public: {\n    type: Boolean,\n    default: false,\n    index: true\n  },\n  display_url: String,\n  // grab the `.strider.json` in advance - could be expensive for some\n  // providers (like raw git). This allows runner configuration in the\n  // .strider.json file.\n  prefetch_config: {\n    type: Boolean,\n    default: true\n  },\n  // used for user-level provider & plugin config.\n  creator: {\n    type: Schema.ObjectId,\n    ref: 'user',\n    index: true\n  },\n  // looks like:\n  // { master: BranchConfig, otherbranch: 'master' || BranchConfig, ... }\n  // if a branch maps to 'master', it has all of the same configuration, but 'deploy_on_green' is false\n  branches: [BranchConfig],\n  provider: {\n    id: String,      // plugin id of the provider\n    account: String, // account id\n    repo_id: String, // id of the repository\n    config: {        // decided by the provider\n      // url: String\n    }\n  }\n});\n\n// name: the name of the new branch\n// done(err)\nProjectSchema.method('addBranch', function (name, done) {\n  var branch = {\n    name: name,\n    mirror_master: true\n  };\n\n  this.branches.push(branch);\n  this.collection.update({ _id: this._id }, {\n    $push: { branches: branch }\n  }, function (err, changed) {\n    if (err) {\n      return done(err);\n    }\n\n    if (!changed) {\n      return done(new Error('no projects affected by adding the branch'));\n    }\n\n    done(null, branch);\n  });\n});\n\nProjectSchema.method('cloneBranch', function (name, cloneName, done) {\n  var clone;\n\n  this.branches.forEach(function (branch) {\n    if (branch.name === name) {\n      clone = _.merge({}, branch);\n    }\n  });\n\n  if (!clone) {\n    return done(new Error('source branch can not be found'));\n  }\n\n  clone.name = cloneName;\n  this.branches.push(clone);\n\n  this.collection.update({ _id: this._id }, {\n    $push: { branches: clone }\n  }, function (err, changed) {\n    if (err) {\n      return done(err);\n    }\n\n    if (!changed) {\n      return done(new Error('no projects affected by cloning the branch'));\n    }\n    done(null, clone);\n  });\n});\n\nProjectSchema.method('branch', function (name) {\n  return findBranch(this.branches, name);\n});\n\nProjectSchema.static('forUser', function (user, done) {\n  // Default to all projects\n  var query = {};\n\n  // If we are not an admin i.e account level is not set or < 1, show only user projects\n  if (!user.account_level || user.account_level < 1) {\n    if (!user.projects) {\n      return done(null, []);\n    }\n\n    var names = user.projects.map(function (p) {\n      return p.name.toLowerCase();\n    });\n\n    if (!names.length) {\n      return done(null, []);\n    }\n\n    query = {\n      name: { $in: names }\n    };\n  }\n\n  this.find(query, done);\n});\n\nmodule.exports = mongoose.model('Project', ProjectSchema);\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/utils/index.js":"'use strict';\n\nvar _ = require('lodash');\nvar common = require('../../lib/common');\nvar debug = require('debug')('strider:utils');\nvar gravatar = require('gravatar');\n\nmodule.exports = {\n  gravatar: gravatarDefault,\n  sanitizeProject: sanitizeProject,\n  sanitizeBranch: sanitizeBranch,\n  sanitizeUser: sanitizeUser,\n  timeFromId: timeFromId,\n  defaultSchema: defaultSchema,\n  validateAgainstSchema: validateAgainstSchema,\n  mergePlugins: mergePlugins,\n  mergeConfigs: mergeConfigs,\n  findBranch: findBranch\n};\n\nfunction findBranch(branches, name) {\n  var foundBranch = false;\n  branches.some(function (branch) {\n    if (branch.name) {\n      var regEx = new RegExp(`^${branch.name.replace(/\\*/g, '.*')}$`);\n      if (regEx.test(name)) {\n        foundBranch = branch;\n        return true;\n      }\n    }\n  });\n  return (function discreteBranchFn(name, branch, branches) {\n    //console.log('findBranch('+name+') wants to return '+branch.name);\n    if (branch.name !== name) {\n      //console.warn('Possibly returning unintended branch (expected '+name+' but got '+branch.name+'). attempting to locate discretely named branch '+name+' if it exists.');\n      var discreteBranch = _.find(branches, {name: name});\n      if (discreteBranch) {\n        branch = discreteBranch;\n        //console.info(\"Located discrete branch, instead returning \"+branch.name)\n      } else {\n        //console.warn(\"Unable to find discrete branch \"+name+\", still returning \"+branch.name);\n      }\n    }\n    return branch;\n  }(name, foundBranch, branches));\n}\n\n// merge plugins from the DB with ones from strider.json. The latter overrides the former\nfunction mergePlugins(branch, sjson) {\n  if (!branch) return sjson;\n  if (!sjson) return branch;\n  // if strict_plugins is not turned on, we merge each plugin config instead of overwriting.\n  var plugins = [];\n  var pluginMap = {};\n\n  for (var pluginIndex = 0; pluginIndex < sjson.length; pluginIndex++) {\n    plugins.push(sjson[pluginIndex]);\n    pluginMap[sjson[pluginIndex].id] = true;\n  }\n  for (var branchIndex = 0; branchIndex < branch.length; branchIndex++) {\n    if (!pluginMap[branch[branchIndex].id]) plugins.push(branch[branchIndex]);\n  }\n  return plugins;\n}\n\nfunction mergeConfigs(branch, striderJson) {\n  // Is this still a mongoose document?\n  if (typeof branch.toObject === 'function') {\n    branch = branch.toObject();\n  }\n\n  // Copy all properties of the branch configuration to a new object (inherited properties are ignored, there\n  // shouldn't be any anyway). Then override all values with what is defined in the strider.json.\n  // Note that this overrides all plugin configuration.\n  const config = _.assign({}, branch, striderJson);\n\n  // Get a list of all plugins and their default configuration schemas.\n  // We can find these in common.extensions, which contains separate objects for every type of extension that exists.\n  // In those objects we find keys which are the IDs of the plugin and the value is the configuration schema of that\n  // plugin.\n  // We recursively traverse this data structure and merge it into a single hash, while generating an instance of the\n  // default configuration, so we can access the configurations for each extension easily.\n  const allSchemas = _.keys(common.extensions).reduce((allSchemas, extensionType) => {\n    _.keys(common.extensions[extensionType]).reduce((allSchemas, pluginId) => {\n      if(extensionType === 'runner') return allSchemas;\n      allSchemas[pluginId] = defaultSchema(common.extensions[extensionType][pluginId]);\n      return allSchemas;\n    }, allSchemas);\n    return allSchemas;\n  }, {});\n\n  // For every plugin, merge the default configuration into a new object and then assign the user configuration\n  // over it.\n  if(config.plugins && config.plugins.length) {\n    config.plugins.forEach(plugin => {\n      if(!allSchemas[plugin.id]) return plugin.config;\n      plugin.config = _.assign({}, allSchemas[plugin.id], plugin.config);\n    });\n  }\n\n  // If the user requests to have plugin configurations merged (through the merge_plugins setting in the strider.json)\n  // merge the plugin configurations.\n  // Here, we do not need to care about the default configuration of a plugin, as the web UI will always have the\n  // full configuration schema populated.\n  if (!striderJson.merge_plugins) return config;\n  debug('Merging plugin configurations');\n  config.plugins = mergePlugins(branch.plugins, striderJson.plugins);\n\n  return config;\n}\n\nfunction validateVal(val, schema) {\n  if (schema === String) return `${val}`;\n  if (schema === Number) {\n    val = parseFloat(schema);\n    return isNaN(val) ? 0 : val;\n  }\n  if (schema === Boolean) return !!val;\n  if (Array.isArray(schema)) {\n    var ret = [];\n    if (!Array.isArray(val)) return [];\n    for (var i = 0; i < val.length; i++) {\n      ret.push(validateVal(val[i], schema[0]));\n    }\n    return ret;\n  }\n  if (schema.type && !schema.type.type) {\n    val = validateVal(val, schema.type);\n    if (schema.enum && schema.enum.indexOf(val) === -1) {\n      return;\n    }\n    return val;\n  }\n  if ('object' !== typeof schema) return;\n  if ('object' !== typeof val) return {};\n  // if schema is {}, it's unchecked.\n  if (Object.keys(schema).length === 0) return val;\n  return validateAgainstSchema(val, schema);\n}\n\nfunction defaultVal(val) {\n  if (val === String) return '';\n  if (val === Number) return 0;\n  if (val === Boolean) return false;\n  if (!val) return null;\n  if (Array.isArray(val)) return [];\n  if (val.type && !val.type.type) {\n    if (val.default) return val.default;\n    if (val.enum) return val.enum[0];\n    return defaultVal(val.type);\n  }\n  if ('object' === typeof val) return defaultSchema(val);\n  return null;\n}\n\nfunction defaultSchema(schema) {\n  var data = {};\n  for (var key in schema) {\n    data[key] = defaultVal(schema[key]);\n  }\n  return data;\n}\n\nfunction validateAgainstSchema(obj, schema) {\n  var data = {};\n  for (var key in obj) {\n    if (!schema[key]) continue;\n    data[key] = validateVal(obj[key], schema[key]);\n  }\n  return data;\n}\n\nfunction timeFromId(id) {\n  return new Date(parseInt(id.toString().substring(0, 8), 16) * 1000);\n}\n\nfunction sanitizeBranch(branch) {\n  var plugins = [];\n  for (var i = 0; i < branch.plugins; i++) {\n    plugins.push({id: branch.plugins[i].id, enabled: branch.plugins[i].enabled});\n  }\n  return {\n    plugins: plugins,\n    public: branch.public,\n    active: branch.active,\n    deploy_on_green: branch.deploy_on_green,\n    deploy_on_pull_request: branch.deploy_on_pull_request,\n    runner: {\n      id: branch.runner && branch.runner.id\n    }\n  };\n}\n\nfunction sanitizeUser(user) {\n  for (var i = 0; i < user.accounts.length; i++) {\n    delete user.accounts[i].cache;\n  }\n  return user;\n}\n\nfunction sanitizeProject(project) {\n  return {\n    _id: project._id,\n    name: project.name,\n    branches: project.branches.map(sanitizeBranch),\n    public: project.public,\n    display_url: project.display_url,\n    display_name: project.display_name,\n    provider: {\n      id: project.provider.id\n    }\n  };\n}\n\nfunction gravatarDefault(email) {\n  return gravatar.url(email, {\n    d: 'identicon'\n  }, true);\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/models/config.js":"'use strict';\n\nvar mongoose = require('../mongoose-shim');\nvar Schema = mongoose.Schema;\n\nvar Config = new Schema({\n  version: Number\n  // is there any other configuration we want?\n});\n\nmodule.exports = mongoose.model('Config', Config);\n\nmodule.exports.SCHEMA_VERSION = 2;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/logging.js":"'use strict';\n\nvar util = require('util');\nvar winston = require('winston');\nvar config = require('./config');\n\nvar transports = [];\nvar logger;\n\nif (config.logging.console_enabled) {\n  transports.push(new winston.transports.Console(config.logging.console));\n}\n\nif (config.logging.file_enabled) {\n  transports.push(new winston.transports.File(config.logging.file));\n}\n\nlogger = new winston.Logger({\n  transports: transports,\n  exitOnError: config.logging.exitOnError\n});\n\nfunction formatArgs(args){\n  return [util.format.apply(util.format, Array.prototype.slice.call(args))];\n}\n\nconsole.log = function (){\n  logger.info.apply(logger, formatArgs(arguments));\n};\n\nconsole.debug = function (){\n  logger.debug.apply(logger, formatArgs(arguments));\n};\nconsole.info = function (){\n  logger.info.apply(logger, formatArgs(arguments));\n};\nconsole.warn = function (){\n  logger.warn.apply(logger, formatArgs(arguments));\n};\nconsole.error = function (){\n  logger.error.apply(logger, formatArgs(arguments));\n};\n\nmodule.exports = logger;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/middleware.js":"'use strict';\n\nrequire('./logging');\nvar auth = require('./auth');\nvar utils = require('./utils');\nvar common = require('./common');\nvar Project = require('./models').Project;\nvar User = require('./models').User;\n\nmodule.exports = {\n  bodySetter: bodySetter,\n  requireBody: requireBody,\n  custom404: custom404,\n\n  anonProject: anonProject,\n  project: project,\n  projectPlugin: projectPlugin,\n  projectProvider: projectProvider,\n\n  // Legacy aliases - don't use these:\n  require_auth: auth.requireUserOr401,\n  require_auth_browser: auth.requireUser,\n  require_admin: auth.requireAdminOr401,\n  require_project_admin: auth.requireProjectAdmin\n};\n\n// Custom middleware to save unparsed request body to req.content\nfunction bodySetter(req, res, next) {\n  if (req._post_body) {\n    return next();\n  }\n\n  req.post_body = req.post_body || '';\n\n  if ('POST' !== req.method) {\n    return next();\n  }\n\n  req._post_body = true;\n\n  req.on('data', function (chunk) {\n    req.post_body += chunk;\n  });\n\n  next();\n}\n\n// Require the specified req.body parameters, or else return a 400 with a descriptive JSON body\nfunction requireBody(paramsList) {\n  return function (req, res, next) {\n    var errors = [];\n    var status = 'ok';\n\n    for (var i = 0; i < paramsList.length; i++) {\n      var val = req.body[paramsList[i]];\n\n      if (!val) {\n        errors.push(`required parameter \\`${paramsList[i]}\\` not found.`);\n        status = 'error';\n      }\n    }\n\n    if (errors.length === 0) {\n      next();\n    } else {\n      return res.status(400).json({\n        errors: errors,\n        status: status\n      });\n    }\n  };\n}\n\nfunction custom404(req, res, next) {\n  if (req.method !== 'GET') {\n    return next();\n  }\n\n  res.statusCode = 404;\n  res.render('doesnotexist.html');\n}\n\n// Create helper function to get or set the provifer config. Expects req.project\n// `req.providerConfig` function\n//   providerConfig() -> return the config\n//   providerConfig(config, next(err)). save the config\n//\n// For hosted providers, the following function is also available\n//   accountConfig() -> return the account confi\n//   acountConfig(config, next(err)). save the account config\nfunction projectProvider(req, res, next) {\n  var project = req.project;\n\n  req.providerConfig = function (config, next) {\n    if (arguments.length === 0) {\n      return project.provider.config;\n    }\n\n    project.provider.config = config;\n    project.markModified('provider');\n    project.save(next);\n  };\n  // make this conditional?\n  if (project.provider.account) {\n    var account = project.creator.account(project.provider.id, project.provider.account);\n\n    req.accountConfig = function (config, next) {\n      if (arguments.length === 0) {\n        return account.config;\n      }\n\n      account.config = config;\n      project.creator.markModified('accounts');\n      project.creator.save(next);\n    };\n  }\n\n  next();\n}\n\n// Get plugin config. Expects req.project\n// Sets `req.pluginConfig` function\n//   pluginConfig() -> return the config\n//   pluginConfig(config, next(err)). save the config\nfunction projectPlugin(req, res, next) {\n  var pluginid;\n  // if only 3 args, then get pluginid from params \":plugin\"\n  if (arguments.length === 4) {\n    pluginid = req;\n    req = res;\n    res = next;\n    next = arguments[3];\n  } else {\n    pluginid = req.params.plugin;\n  }\n\n  var branch = req.project.branch(req.query.branch);\n  var plugin = null;\n\n  if (!branch) {\n    return res.status(404).send('Specified branch not found for the project');\n  }\n  // if it's just mirroring master\n  if (branch.mirror_master) {\n    return res.status(400).send('Branch not individually configurable');\n  }\n\n  for (var i = 0; i < branch.plugins.length; i++) {\n    if (branch.plugins[i].id === pluginid) {\n      plugin = branch.plugins[i];\n      break;\n    }\n  }\n\n  if (plugin === null) {\n    return res.status(404).send('Plugin not enabled for the specified project');\n  }\n\n  req.pluginConfig = function (config, next) {\n    if (arguments.length === 0) {\n      return plugin.config;\n    }\n\n    plugin.config = config;\n    req.project.markModified('branches');\n    req.project.save(function (err) {\n      next(err, config);\n    });\n  };\n\n  req.userConfig = function (config, next) {\n    if (!req.user.isProjectCreator) {\n      if (arguments.length === 0) {\n        return false;\n      }\n\n      return next(new Error('Current user is not the creator - cannot set the creator config'));\n    }\n\n    if (arguments.length === 0) {\n      return req.project.creator.jobplugins[pluginid];\n    }\n\n    var schema = common.userConfigs.job && common.userConfigs.job[pluginid];\n\n    if (!schema) {\n      return next(new Error(`Plugin ${pluginid} doesn't define any user config`));\n    }\n\n    config = utils.validateAgainstSchema(config, schema);\n    // TODO: validation\n    req.project.creator.jobplugins[pluginid] = config;\n    req.project.creator.markModified('jobplugins');\n\n    req.project.creator.save(function (err) {\n      next(err, config);\n    });\n  };\n\n  next();\n}\n\n// just link project but doesn't fail if there's no auth\nfunction anonProject(req, res, next) {\n  var name = `${req.params.org}/${req.params.repo}`;\n\n  name = name.toLowerCase();\n\n  Project.findOne({name: name})\n    .populate('creator')\n    .exec(function (err, project) {\n      if (err) {\n        return res.status(500).send({\n          error: 'Failed to find project',\n          info: err\n        });\n      }\n\n      if (!project) {\n        return res.status(404).send('Project not found');\n      }\n\n      if (!project.creator) {\n        return res.status(400).send('Project malformed; project creator user is missing.');\n      }\n\n      req.project = project;\n      req.accessLevel = User.projectAccessLevel(req.user, project);\n\n      if (req.user && project.creator) {\n        req.user.isProjectCreator = project.creator._id.toString() === req.user._id.toString();\n      }\n\n      next();\n    });\n}\n\n// getProject Middleware\n// assumes two url parameters, :org and :repo, and req.user\n// checks user access level, and sets the following properties on the\n// request object.\n//\n// req.project = the project\n// req.accessLevel = -1 for no access, 0 for public, 1 for normal, 2 for admin\n//\n// Errors:\n//   404: not found\n//   401: not public and you don't have access\n//   500: something strange happened w/ the DB lookup\nfunction project(req, res, next) {\n  if (req.params.org === 'auth') {\n    return next();\n  }\n\n  anonProject(req, res, function () {\n    if (req.accessLevel > -1) {\n      return next();\n    }\n\n    if (!req.user) {\n      req.session.return_to = req.url;\n      return res.redirect('/login');\n    }\n\n    res.status(401).send('Not authorized');\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/auth.js":"'use strict';\n\nvar crypto = require('crypto');\nvar BluebirdPromise = require('bluebird');\nvar passport = require('passport');\nvar LocalStrategy = require('passport-local').Strategy;\nvar utils = require('./utils');\nvar mailer = require('./email');\nrequire('./config');\nrequire('./logging');\nvar User = require('./models').User;\nvar randomBytes = BluebirdPromise.promisify(crypto.randomBytes);\n\nfunction setupPasswordAuth() {\n  passport.use(new LocalStrategy({\n    usernameField: 'email'\n  }, function (username, password, done) {\n    console.log('username: %s', username);\n\n    User.authenticate(username, password, function (err, user) {\n      if (err || !user) {\n        console.log('no user');\n        return done(null, false, {message: 'Incorrect username.'});\n      }\n\n      return done(null, user);\n    });\n  }));\n}\n\nfunction registerRoutes(app) {\n  app.get('/register', function (req, res) {\n    return res.render('register.html', {});\n  });\n\n  app.post('/register', function (req, res) {\n\n    // Quick and dirty validation\n    var errors = [];\n\n    if (!req.body.invite_code) errors.push('No invite code specified');\n    if (!req.body.email) errors.push('Missing email');\n    if (!req.body.password) errors.push('Missing password');\n\n    if (errors.length) {\n      return res.render('register.html', {errors: errors});\n    }\n\n    User.registerWithInvite(\n      req.body.invite_code, req.body.email, req.body.password\n      , function (err, user) {\n        if (err) {\n          return res.render('register.html', {\n            errors: [err],\n            invite_code: req.body.invite_code,\n            email: req.body.email,\n            password: req.body.password\n          });\n        }\n\n        // Registered success:\n        req.login(user, function () {\n          res.redirect('/');\n        });\n      });\n  });\n\n  app.get('/login', function (req, res) {\n    if (req.user) {\n      return res.redirect('/');\n    }\n\n    var failed = Boolean(req.query.failed);\n    var errors = [];\n\n    if (failed) {\n      errors.push('Authentication failed, please supply a valid email/password.');\n    }\n\n    return res.render('login.html', {\n      errors: errors\n    });\n  });\n}\n\nfunction setup(app) {\n  app.registerAuthStrategy = function (strategy) {\n    passport.use(strategy);\n  };\n\n  app.authenticate = function () {\n    console.log('AUTHENTICATE', arguments);\n\n    var res = passport.authenticate.apply(passport, arguments);\n    console.log('!!!', res);\n\n    return function (req) {\n      console.log('>>>> AUTHENTICATE', req._passport, req._passport.instance._strategies.github);\n      res.apply(this, arguments);\n    };\n  };\n\n  setupPasswordAuth(app);\n\n  // serialize user on login\n  passport.serializeUser(function (user, done) {\n    done(null, user.id);\n  });\n\n  // deserialize user on logout\n  passport.deserializeUser(function (id, done) {\n    User.findById(id, function (err, user) {\n      done(err, user);\n    });\n  });\n\n  app.use(passport.initialize());\n  app.use(passport.session());\n  app.use(basicAuth);\n\n  // Middleware to setup view parameters with user\n  app.use(function (req, res, next) {\n    if (req.user) {\n      req.user.gravatar = utils.gravatar(req.user.email);\n    }\n\n    res.locals.currentUser = req.user || null;\n    next();\n  });\n\n  registerRoutes(app);\n}\n\nfunction basicAuth(req, res, next) {\n  var auth = req.get('authorization');\n  if (!auth) return next();\n\n  var parts = auth.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'basic') return next();\n\n  var plain;\n  try {\n    plain = new Buffer(parts[1], 'base64').toString().split(':');\n  } catch (e) {\n    console.error('Invalid base64 in auth header');\n    return next();\n  }\n  if (plain.length < 2) {\n    console.error('Invalid auth header');\n    return next();\n  }\n\n  User.authenticate(plain[0], plain.slice(1).join(':'), function (err, user) {\n    if (err || !user) {\n      console.log('basic auth: user not found');\n      return res.status(401).send('Invalid username/password in basic auth');\n    }\n\n    req.user = user;\n\n    return next();\n  });\n}\n\nvar _authenticate = passport.authenticate('local', {\n  successRedirect: '/',\n  failureRedirect: '/login?failed=true'\n});\n\nfunction logout(req, res) {\n  req.logout();\n  res.redirect('/');\n}\n\nfunction forgot(req, res) {\n  var email = req.body.email.toLowerCase();\n\n  User.findOne({email: {$regex: new RegExp(email, 'i')}}, function (error, user) {\n    if (error) {\n      req.flash('error', 'An error occured while attempting to reset your password.');\n      return res.redirect('/forgot');\n    }\n\n    if (user) {\n      randomBytes(20).then(function (buffer) {\n        return buffer.toString('hex');\n      }).then(function (token) {\n        user.resetPasswordToken = token;\n        user.resetPasswordExpires = Date.now() + 3600000; // 1 hour\n\n        return new BluebirdPromise(function (resolve, reject) {\n          user.save(function (err, u) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(u);\n            }\n          });\n        });\n      }).then(function (user) {\n        mailer.sendPasswordReset(user);\n        req.flash('info', 'Please check your email for the password reset url. Thank you!');\n        res.redirect('/');\n      }).catch(function (error) {\n        console.error('Password reset error: ', error);\n      });\n    } else {\n      req.flash('error', 'We could not find a user with that email.');\n      return res.redirect('/forgot');\n    }\n  });\n}\n\nfunction reset(req, res) {\n  var token = req.params.token;\n\n  User.findOne({\n    resetPasswordToken: token,\n    resetPasswordExpires: {$gt: Date.now()}\n  }, function (err, user) {\n    if (!user) {\n      req.flash('error', 'Password reset token is invalid or has expired.');\n      return res.redirect('/forgot');\n    }\n\n    res.render('reset.html', {\n      token: token,\n      user: user\n    });\n  });\n}\n\nfunction resetPost(req, res) {\n  var password = req.body.password;\n  var confirmation = req.body.passwordConfirmation;\n\n  if (password === confirmation) {\n    User.findOne({\n      resetPasswordToken: req.params.token,\n      resetPasswordExpires: {$gt: Date.now()}\n    }, function (err, user) {\n      if (!user) {\n        req.flash('error', 'Password reset token is invalid or has expired.');\n        return res.redirect('back');\n      }\n\n      user.password = password;\n      user.resetPasswordToken = undefined;\n      user.resetPasswordExpires = undefined;\n\n      user.save(function (err) {\n        if (err) {\n          req.flash('error', 'Couldn\\'t save changes with new password.');\n          return res.redirect('/');\n        }\n\n        req.login(user, function (err) {\n          if (err) {\n            req.flash('error', 'You\\'r user authentication was not successful.');\n          }\n\n          res.redirect('/');\n        });\n      });\n    });\n  } else {\n    res.redirect(req.header('Referer'));\n  }\n}\n\n// Require a logged in session\nfunction requireUser(req, res, next) {\n  if (req.user) {\n    next();\n  } else {\n    req.session.return_to = req.url;\n    res.redirect('/login');\n  }\n}\n\nfunction requireUserOr401(req, res, next) {\n  if (req.user) {\n    next();\n  } else {\n    res.status(401).send('not authorized');\n  }\n}\n\n// Require admin privileges\nfunction requireAdminOr401(req, res, next) {\n  if (!req.user || !req.user['account_level'] || req.user.account_level < 1) {\n    res.status(401).send('not authorized');\n  } else {\n    next();\n  }\n}\n\n// Require the logged-in user to have admin access to the repository in the\n// URI path.\n// E.g. http://striderapp.com/beyondfog/strider/latest_build\nfunction requireProjectAdmin(req, res, next) {\n  if (!req.project) return res.status(404).send('Project not loaded');\n  if (!req.user) return res.status(401).send('No user');\n  var isAdmin = req.user.account_level && req.user.account_level > 0;\n  var notAuthed = (!req.accessLevel || req.accessLevel < 2) && !isAdmin;\n  if (notAuthed) return res.status(401).send('Not authorized for configuring this project');\n  next();\n}\n\nmodule.exports = {\n  setup: setup,\n  authenticate: _authenticate,\n  logout: logout,\n  forgot: forgot,\n  reset: reset,\n  resetPost: resetPost,\n\n  // Auth middleware\n  requireUser: requireUser,\n  requireUserOr401: requireUserOr401,\n  requireAdminOr401: requireAdminOr401,\n  requireProjectAdmin: requireProjectAdmin\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/email.js":"'use strict';\n\nvar striderMailer = require('strider-mailer');\nvar pug = require('pug');\nvar fs = require('fs');\nvar path = require('path');\nvar config = require('./config');\n\nvar mailer = striderMailer(config);\nvar templateBasePath = path.join(__dirname, 'views/email_templates');\nvar templates = [\n  'invite',\n  'revoke_invite',\n  'notify_password_change',\n  'send_password_reset',\n  'notify_email_change',\n  'collaborator_invite_new_user',\n  'collaborator_invite_existing_user'\n];\nvar html = loadTemplates(templates, 'html');\nvar text = loadTemplates(templates, 'plaintext');\n\n/*\n * loading all of the email templates at server start\n */\nfunction loadTemplates(list, type) {\n  if (!list) {\n    return;\n  }\n\n  var result = {};\n\n  type = type || 'plaintext';\n\n  list.forEach(function (name) {\n    var templatePath = path.join(templateBasePath, type, `${name}.pug`);\n    result[name] = renderPug(templatePath);\n  });\n\n  return result;\n}\n\nfunction renderPug(filepath) {\n  return pug.compile(fs.readFileSync(filepath, 'utf8'), { filename: filepath });\n}\n\nexports.sendInvite = function (code, email) {\n  var subject = 'Strider Invitation';\n  var bodyHtml = html.invite({code: code, strider_server_name: config.server_name});\n  var bodyText = text.invite({code: code, strider_server_name: config.server_name});\n\n  mailer.send(email, subject, bodyText, bodyHtml);\n};\n\nexports.revokeInvite = function (code, email) {\n  var subject = 'Strider Invitation';\n  var bodyHtml = html.revoke_invite({code: code, strider_server_name: config.server_name});\n  var bodyText = text.revoke_invite({code: code, strider_server_name: config.server_name});\n\n  mailer.send(email, subject, bodyText, bodyHtml);\n};\n\nexports.notifyPasswordChange = function (user) {\n  var currentTime = new Date();\n  var subject = `[STRIDER] - Password Change Notification - ${currentTime.getHours()}:${currentTime.getMinutes()}`;\n  var bodyText = text.notify_password_change();\n  var bodyHtml = html.notify_password_change();\n  var to = user.email;\n\n  mailer.send(to, subject, bodyText, bodyHtml);\n};\n\nexports.sendPasswordReset = function (user) {\n  var currentTime = new Date();\n  var templateOptions = {\n    token: user.resetPasswordToken,\n    strider_server_name: config.server_name\n  };\n  var subject = `[STRIDER] - Password Reset - ${currentTime.getHours()}:${currentTime.getMinutes()}`;\n  var bodyText = text.send_password_reset(templateOptions);\n  var bodyHtml = html.send_password_reset(templateOptions);\n  var to = user.email;\n\n  mailer.send(to, subject, bodyText, bodyHtml);\n};\n\nexports.notifyEmailChange = function (user, oldEmail) {\n  var currentTime = new Date();\n  var subject = `[STRIDER] - Email Address Change Notification - ${currentTime.getHours()}:${currentTime.getMinutes()}`;\n  var to = user.email;\n  var bodyText = text.notify_email_change({ old_email: oldEmail, user: user });\n  var bodyHtml = html.notify_email_change({ old_email: oldEmail, user: user });\n\n  mailer.send(to, subject, bodyText, bodyHtml);\n  mailer.send(oldEmail, subject, bodyText, bodyHtml);\n\n  console.log(`send email change notification to ${oldEmail} and ${to}`);\n};\n\nexports.sendInviteCollaboratorNewUser = function (inviter, email, code, url) {\n  // not actually properly capitalized right now\n  var displayName = url.replace(/^.*com\\//gi, '');\n  var subject = `[STRIDER] Invite to ${displayName}`;\n  var to = email;\n  var pugVariables = {\n    inviter: inviter.email,\n    display_name: displayName,\n    code: code,\n    strider_server_name: config.server_name\n  };\n\n  var bodyText = text.collaborator_invite_new_user(pugVariables);\n  var bodyHtml = html.collaborator_invite_new_user(pugVariables);\n\n  mailer.send(to, subject, bodyText, bodyHtml);\n\n  console.log(`send collaborator invite to new user ${email} for ${displayName}`);\n};\n\n\nexports.sendInviteCollaboratorExistingUser = function (req, email, url) {\n  // not actually properly capitalized right now\n  var displayName = url.replace(/^.*com\\//gi, '');\n  var subject = `[STRIDER] Invite to ${displayName}`;\n  var to = email;\n  var pugVariables = {\n    inviter: req.user.email,\n    display_name: displayName,\n    strider_server_name: config.server_name\n  };\n  var bodyText = text.collaborator_invite_existing_user(pugVariables);\n  var bodyHtml = html.collaborator_invite_existing_user(pugVariables);\n\n  mailer.send(to, subject, bodyText, bodyHtml);\n\n  console.log(`send collaborator invite to existing user ${email} for ${displayName}`);\n};\n\nexports.notifyNewAdmin = function (user, email) {\n  var currentTime = new Date();\n  var subject = `[STRIDER] - New Admin  - ${user} - ${currentTime.getHours()}:${currentTime.getMinutes()}`;\n  var body = `Hello Core,\\n\\nYou have a new admin colleague: ${user}\\n\\nHopefully this isn't unexpected.\\n\\nRegards,\\n - StriderCD.com\\n   Brilliant Continuous Delivery`;\n\n  mailer.send(email, subject, body, body);\n  console.log(`Sending admin notification for new admin ${user}`);\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-mailer/mailer.js":"var debug = require('debug')('strider-mailer');\nvar each = require('lodash.foreach');\nvar everypaas = require('everypaas');\nvar nodemailer = require('nodemailer');\n\nmodule.exports = function (config) {\n  /*\n   * opening smtp connection\n   */\n  // Default to printing a warning\n  var smtpTransport = {\n    sendMail: function (opts, cb) {\n      debug('WARNING: no SMTP transport detected nor configured. Cannot send email.');\n      cb(null, {message: null});\n    }\n  };\n\n  // Try using SendGrid / Mailgun\n  if (everypaas.getSMTP() !== null) {\n    debug('Using SMTP transport: %j', everypaas.getSMTP());\n    smtpTransport = nodemailer.createTransport.apply(null, everypaas.getSMTP());\n  } else {\n    if (config.sendgrid) {\n      debug('Using Sendgrid transport from config');\n      smtpTransport = nodemailer.createTransport('SMTP', {\n        service: 'SendGrid',\n        auth: {\n          user: config.sendgrid.username,\n          pass: config.sendgrid.password\n        }\n      });\n    } else if (config.smtp) {\n      debug('Using SMTP transport from config');\n      var smtp = config.smtp;\n      var smtpConfig = {\n        host: smtp.host,\n        port: parseInt(smtp.port, 10)\n      };\n\n      // enable secureConnection is port is 465 to use encrypted handshake\n      if (smtpConfig.port == 465) {\n        smtpConfig.secureConnection = true;\n      }\n\n      // allow anonymous SMTP login if user and pass are not defined\n      if (smtp.auth && smtp.auth.user && smtp.auth.pass) {\n        smtpConfig.auth = {\n          user: smtp.auth.user,\n          pass: smtp.auth.pass\n        };\n      }\n\n      smtpTransport = nodemailer.createTransport('SMTP', smtpConfig);\n    } else if (config.stubSmtp) {\n      debug('stubbing smtp..');\n      smtpTransport = nodemailer.createTransport('Stub');\n    }\n  }\n\n  function send(to, subject, textBody, htmlBody, from, callback) {\n    from = from || (config.smtp ? config.smtp.from : null);\n\n    var mailOptions = {\n      from: from, // sender address\n      to: to, // list of receivers\n      subject: subject, // Subject line\n      text: textBody, // plaintext body_template\n      html: htmlBody // html body\n    };\n    // send mail with defined transport object\n    smtpTransport.sendMail(mailOptions, function (error, response) {\n      if (error) {\n        debug('Error sending email: ', error);\n      }\n\n      if (config.stubSmtp) {\n        debug(response.message);\n      }\n\n      if (callback) {\n        callback(error, response);\n      }\n    });\n  }\n\n  /*\n   * format_stdmerged()\n   *\n   * Format the stdmerged property (test std stream output) for sendgrid consumption.\n   * <stdmerged> - Job's stdmerged property.\n   */\n  function format_stdmerged(stdmerged, emailFormat) {\n    // 4k\n    var start = stdmerged.length - 1 - 4096;\n\n    if (start < 0) {\n      start = 0;\n    }\n\n    var tlog = stdmerged.slice(start, stdmerged.length - 1).replace(/^\\s+|\\s+$/g, '');\n    // Start each line with a space\n    var tlines = tlog.split('\\n');\n    var b = new Buffer(8192);\n    var offset = 0;\n\n    each(tlines, function (l) {\n      var towrite;\n\n      if (emailFormat === 'plaintext') {\n        towrite = ' ' + l.replace(/\\[(\\d)?\\d*m/gi, '') + '\\n';\n      } else {\n        towrite = ' ' + l.replace(/\\[(\\d)?\\d*m/gi, '') + '<br>\\n';\n      }\n\n      b.write(towrite, offset, towrite.length);\n      offset += towrite.length;\n    });\n\n    return b.toString('utf8', 0, offset);\n  }\n\n  function elapsed_time(start, finish) {\n    var inSeconds = (finish - start) / 1000;\n\n    if (inSeconds > 60) {\n      return (Math.floor(inSeconds / 60) + 'm ' + Math.round(inSeconds % 60) + 's');\n    } else {\n      return (Math.round(inSeconds) + 's');\n    }\n  }\n\n  return {\n    send: send,\n    format_stdmerged: format_stdmerged,\n    elapsed_time: elapsed_time\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-mailer/node_modules/everypaas/index.js":"var fs = require('fs')\n\nfunction EveryPaaS() {\n  this.DOTCLOUD = \"dotcloud\"\n  this.HEROKU = \"heroku\"\n  this.NODEJITSU = \"nodejitsu\"\n  this.NONE = \"none\"\n  this.STRIDER = \"strider\"\n\n  this.detect()\n}\n\nEveryPaaS.prototype.detect = function(env, dcf) {\n  var env = env || process.env\n  var dotCloudFilename = dcf || \"/home/dotcloud/environment.json\"\n  this.paas = this.NONE\n  this.herokuEnvironment = undefined\n  this.striderEnvironment = undefined\n  try {\n    this.getDotCloud(dotCloudFilename)\n    this.paas = this.DOTCLOUD\n    return this.paas\n  } catch(e) {\n    if (this.isHeroku(env)) {\n      this.herokuEnvironment = env\n      this.paas = this.HEROKU\n      return this.paas\n    }\n    if (this.isStrider(env)) {\n      this.striderEnvironment = env\n      this.paas = this.STRIDER\n      return this.paas\n    }\n    if (this.isNodejitsu()) {\n      this.paas = this.NODEJITSU\n      return this.paas\n    }\n    return this.paas\n  }\n}\n\nEveryPaaS.prototype.isHeroku = function (env) {\n  var env = env || this.herokuEnvironment\n\n  return (env && (env.PORT !== undefined && env.PAAS_NAME !== \"strider\"))\n}\n\nEveryPaaS.prototype.getDotCloud = function(filename) {\n  if (this.dotCloudEnvironment !== undefined) return this.dotCloudEnvironment\n  try {\n    var data = fs.readFileSync(filename)\n    this.dotCloudEnvironment = JSON.parse(data)\n    return this.dotCloudEnvironment\n  } catch(e) {\n    throw new Error(\"could not get dotcloud environment\")\n  }\n}\n\nEveryPaaS.prototype.isDotCloud = function() {\n  return (this.dotCloudEnvironment !== undefined)\n}\n\nEveryPaaS.prototype.isNodejitsu = function() {\n\n}\n\nEveryPaaS.prototype.isStrider = function(env) {\n  var env = env || this.striderEnvironment\n\n  return (env && env.PAAS_NAME !== undefined\n    && env.PAAS_NAME.toLowerCase() === \"strider\")\n}\n\nEveryPaaS.prototype.getMongodbUrl = function() {\n\n  if (this.isDotCloud()) {\n    return getDotCloudVar(this.dotCloudEnvironment, \"MONGODB_URL\")\n  }\n\n  if (this.isHeroku()) {\n    if (this.herokuEnvironment.MONGOLAB_URI)\n      return this.herokuEnvironment.MONGOLAB_URI\n    if (this.herokuEnvironment.MONGOHQ_URL)\n      return this.herokuEnvironment.MONGOHQ_URL\n    return null\n  }\n\n  if (this.isStrider()) {\n    if (this.striderEnvironment.MONGODB_URL)\n      return this.striderEnvironment.MONGODB_URL\n    return null\n  }\n\n  return null\n}\n\n//\n// ## Return an argument list which can be applied to nodemailer's createTransport function\n// \nEveryPaaS.prototype.getSMTP = function() {\n\n  if (this.isHeroku()) {\n    var res = {}\n    if (this.herokuEnvironment.SENDGRID_USERNAME && this.herokuEnvironment.SENDGRID_PASSWORD) {\n      return [\"SMTP\",{\n        service: \"SendGrid\",\n        auth: {\n          user: this.herokuEnvironment.SENDGRID_USERNAME,\n          pass: this.herokuEnvironment.SENDGRID_PASSWORD\n        }\n      }]\n    }\n\n    if (this.herokuEnvironment.MAILGUN_SMTP_SERVER) {\n      return [\"SMTP\",{\n        host:this.herokuEnvironment.MAILGUN_SMTP_SERVER,\n        port:parseInt(this.herokuEnvironment.MAILGUN_SMTP_PORT),\n        auth: {\n          user: this.herokuEnvironment.MAILGUN_SMTP_LOGIN,\n          pass: this.herokuEnvironment.MAILGUN_SMTP_PASSWORD\n        }\n      }]\n    }\n\n    return null\n  }\n  return null\n}\n\nEveryPaaS.prototype.getMysqlUrl = function() {\n\n  if (this.isDotCloud()) {\n    return getDotCloudVar(this.dotCloudEnvironment, \"MYSQL_URL\")\n  }\n\n  if (this.isHeroku()) {\n    if (this.herokuEnvironment.CLEARDB_DATABASE_URL)\n      return this.herokuEnvironment.CLEARDB_DATABASE_URL\n    if (this.herokuEnvironment.XEROUND_DATABASE_INTERNAL_URL)\n      return this.herokuEnvironment.XEROUND_DATABASE_INTERNAL_URL\n    return null\n  }\n\n  if (this.isStrider()) {\n    if (this.striderEnvironment.MYSQL_URL)\n      return this.striderEnvironment.MYSQL_URL\n    return null\n  }\n\n  return null\n}\n\nfunction getDotCloudVar(dotCloudEnvironment, key) {\n  for (var k in dotCloudEnvironment) {\n    if (k.indexOf(\"DOTCLOUD_\") === 0\n      && k.lastIndexOf(key) !== -1) {\n        return dotCloudEnvironment[k]\n    }\n  }\n\n  return null\n}\n\n// Run detection when module loaded.\nvar ep = new EveryPaaS()\n\nmodule.exports = ep\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/index.js":"'use strict';\n\nvar _ = require('lodash');\nvar common = require('../common');\nvar config = require('../config');\nvar debug = require('debug')('strider:routes');\nvar jobs = require('../jobs');\nvar models = require('../models');\nvar path = require('path');\nvar pjson = require('../../package.json');\nvar User = models.User;\nvar utils = require('../utils');\n\n/*\n * GET home page dashboard\n */\nexports.index = function (req, res) {\n  // Work-around for Safari/Express etags bug on cookie logout.\n  // Without it, Safari will cache the logged-in version despite logout!\n  // See https://github.com/Strider-CD/strider/issues/284\n  req.headers['if-none-match'] = 'no-match-for-this';\n\n  if (req.session.return_to) {\n    var return_to = req.session.return_to;\n    req.session.return_to = null;\n    return res.redirect(return_to);\n  }\n\n  var code = '';\n\n  if (req.query.code !== undefined) {\n    code = req.query.code;\n\n    return res.render('register.html', {\n      invite_code: code,\n      version: pjson.version\n    });\n  }\n\n  jobs.latestJobs(req.user, true, function (err, jobs) {\n    var availableProviders = Object.keys(common.userConfigs.provider).map(function (k) {\n      return common.userConfigs.provider[k];\n    });\n\n    res.render('index.html', {\n      jobs: jobs,\n      availableProviders: availableProviders,\n      flash: req.flash(),\n      version: pjson.version\n    });\n  });\n};\n\nexports.setConfig = function (req, res) {\n  var attrs = ['public'];\n\n  applyAttrs(req.project, attrs, req.body);\n\n  req.project.save(function (err) {\n    if (err) return res.status(500).send('failed to save project');\n    res.send('saved');\n  });\n};\n\nexports.getRunnerConfig = function (req, res) {\n  var branch = req.project.branch(req.query.branch);\n\n  if (!branch) {\n    return res.status(400).send('Invalid branch');\n  }\n\n  res.send(branch.runner);\n};\n\nexports.setRunnerConfig = function (req, res) {\n  var branch = req.project.branch(req.query.branch);\n  branch.runner.config = req.body;\n\n  req.project.save(function (err, project) {\n    if (err) {\n      return res.status(500).send({\n        error: 'Failed to save runner config'\n      });\n    }\n\n    res.send(project.branch(req.query.branch).runner.config);\n  });\n};\n\nexports.setRunnerId = function (req, res) {\n  var branch = req.project.branch(req.query.branch);\n\n  branch.runner.id = req.body.id;\n  branch.runner.config = req.body.config;\n\n  req.project.save(function (err, project) {\n    if (err) {\n      return res.status(500).send({\n        error: 'Failed to save runner config'\n      });\n    }\n\n    res.send(project.branch(req.query.branch).runner.id);\n  });\n};\n\n// GET /:org/:repo/config/branch/:pluginname/?branch=:branch\n// Output: the config\nexports.getPluginConfig = function (req, res) {\n  res.send(req.pluginConfig());\n};\n\n// POST /:org/:repo/config/branch/:plugin/?branch=:branch\n// Set the configuration for a plugin on a branch. Output: the new config.\nexports.setPluginConfig = function (req, res) {\n  req.pluginConfig(req.body, function (err, config) {\n    if (err) {\n      return res.status(500).send({\n        error: 'Failed to save plugin config'\n      });\n    }\n\n    res.send(config);\n    common.emitter.emit('branch.plugin_config', req.project, req.query.branch, req.params.plugin, req.body);\n  });\n};\n\nexports.configureBranch = function (req, res) {\n  var branch = req.project.branch(req.query.branch);\n\n  if (!branch) {\n    return res.status(400).send('Invalid branch');\n  }\n\n  if (req.body.plugin_order) {\n    return setPluginOrder(req, res, branch);\n  }\n\n  // TODO: move this somewhere else?\n  var attrs = [\n    'active',\n    'privkey',\n    'pubkey',\n    'envKeys',\n    'mirror_master',\n    'deploy_on_green',\n    'deploy_on_pull_request',\n    'runner',\n    'plugins'\n  ];\n\n  applyAttrs(branch, attrs, req.body);\n\n  req.project.save(function (err) {\n    if (err) {\n      return res.status(500).send('failed to save project');\n    }\n\n    res.status(200).send('saved');\n  });\n};\n\nfunction setPluginOrder(req, res, branch) {\n  var plugins = req.body.plugin_order;\n  var oldPlugins = branch.plugins || [];\n  var map = {};\n\n  oldPlugins.forEach(function (plugin) {\n    map[plugin.id] = plugin;\n  });\n\n  plugins.forEach(function (plugin) {\n    if (map[plugin.id]) {\n      plugin.config = map[plugin.id].config;\n    } else {\n      plugin.config = {};\n    }\n  });\n\n  branch.plugins = plugins;\n  req.project.markModified('branches');\n\n  req.project.save(function (err) {\n    if (err) {\n      return res.status(500).send('Failed to save plugin config');\n    }\n\n    res.send({success: true});\n    common.emitter.emit('branch.plugin_order', req.project, branch.name, plugins);\n  });\n}\n\nexports.reloadConfig = function (req, res, next) {\n  common.loader.initConfig(\n    path.join(__dirname, 'public/javascripts/pages/config-plugins-compiled.js'),\n    path.join(__dirname, 'public/stylesheets/css/config-plugins-compiled.css'),\n    function (err, configs) {\n      debug('loaded config pages');\n      common.pluginConfigs = configs;\n\n      common.loader.initUserConfig(\n        path.join(__dirname, 'public/javascripts/pages/account-plugins-compiled.js'),\n        path.join(__dirname, 'public/stylesheets/css/account-plugins-compiled.css'),\n        function (err, configs) {\n          debug('loaded account config pages');\n          common.userConfigs = configs;\n          next();\n        }\n      );\n    });\n};\n\n\n/*\n * GET /:org/:repo/config - project config page\n */\nexports.config = function (req, res) {\n  User.collaborators(req.project.name, 0, function (err, users) {\n    if (err) {\n      throw err;\n    }\n\n    var data = {\n      version: pjson.version,\n      collaborators: [],\n      serverName: config.server_name,\n      project: req.project.toJSON(),\n      statusBlocks: common.statusBlocks,\n      userIsCreator: req.user.isProjectCreator\n    };\n\n    if (req.user.isProjectCreator) {\n      data.userConfigs = req.user.jobplugins;\n    }\n\n    delete data.project.creator;\n\n    users.forEach(function (user) {\n      var p = _.find(user.projects, function (p) {\n        return p.name === req.project.name;\n      });\n\n      data.collaborators.push({\n        email: user.email,\n        access: p.access_level,\n        gravatar: utils.gravatar(user.email),\n        owner: user._id.toString() === req.project.creator._id.toString(),\n        yourself: req.user._id.toString() === user._id.toString()\n      });\n    });\n\n    data.provider = common.pluginConfigs.provider[req.project.provider.id];\n    data.runners = common.pluginConfigs.runner;\n    data.plugins = common.pluginConfigs.job;\n\n    data.collaborators.sort(function (a, b) {\n      if (a.owner) return -1;\n      if (b.owner) return 1;\n      return 0;\n    });\n\n    var provider = common.extensions.provider[req.project.provider.id];\n    var creator_creds = req.project.creator.account(req.project.provider).config;\n\n    if (!provider) {\n      // TODO: alert the user through the UI\n      debug('Provider plugin not installed!', req.project.provider.id);\n      return respond(data);\n    }\n\n    if (typeof provider.getBranches === 'function' && (!provider.hosted || creator_creds)) {\n      provider.getBranches(creator_creds, req.project.provider.config, req.project, function (err, branches) {\n        data.allBranches = branches;\n        respond(data);\n      });\n    } else {\n      respond(data);\n    }\n  });\n\n  function respond(data) {\n    res.format({\n      html: function () {\n        res.render('project_config.html', data);\n      },\n      json: function () {\n        res.send(data);\n      }\n    });\n  }\n};\n\n/*\n * /status endpoint\n * Executes a simple database query to verify that system is operational.\n * Assumes there is at least 1 user in the system.\n * Returns 200 on success.\n *\n * This is for use by Pingdom and similar monitoring systems.\n */\nexports.status = function (req, res) {\n  function error(message) {\n    res.statusCode = 500;\n\n    var resp = {\n      status: 'error',\n      version: `StriderCD (http://stridercd.com) ${pjson.version}`,\n      results: [],\n      errors: [{message: message}]\n    };\n\n    return res.jsonp(resp);\n  }\n\n  function ok() {\n    res.statusCode = 200;\n\n    var resp = {\n      status: 'ok',\n      version: `StriderCD (http://stridercd.com) ${pjson.version}`,\n      results: [{message: 'system operational'}],\n      errors: []\n    };\n\n    return res.jsonp(resp);\n  }\n\n  User.findOne(function (err, user) {\n    if (err) {\n      return error(`error retrieving user from DB: ${err}`);\n    }\n\n    if (!user) {\n      return error('no users found in DB - mis-configured?');\n    }\n\n    return ok();\n  });\n};\n\nfunction applyAttrs(obj, attrs, source) {\n  attrs.forEach(function (attr) {\n    if (typeof source[attr] !== 'undefined') {\n      obj[attr] = source[attr];\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/provider.js":"'use strict';\n\nvar _ = require('lodash');\nvar express = require('express');\nvar debug = require('debug')('strider:routes:provider');\nvar auth = require('../auth');\nvar middleware = require('../middleware');\nvar common = require('../common');\nvar utils = require('../utils');\nvar router = new express.Router();\nvar rootRoute = router.route('/:org/:repo/provider');\n\nrootRoute.all(\n  auth.requireUserOr401,\n  middleware.project,\n  auth.requireProjectAdmin\n);\n\n/**\n * @api {get} /:org/:repo/provider Get Project Provider\n * @apiUse ProjectReference\n * @apiDescription Get the provider config for the specified project\n * @apiName GetProjectProvider\n * @apiGroup Provider\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X GET http://localhost:3000/strider-cd/strider/provider\n */\nrootRoute.get(function (req, res) {\n  res.send(req.project.provider.config);\n});\n\n/**\n * @api {post} /:org/:repo/provider Update Project Provider\n * @apiUse ProjectReference\n * @apiDescription Update a project's provider\n * @apiName UpdateProjectProvider\n * @apiGroup Provider\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X POST http://localhost:3000/strider-cd/strider/provider\n */\nrootRoute.post(function (req, res) {\n  var providerId = req.project.provider.id;\n\n  debug(`Provider Id: ${providerId}`);\n\n  var providerConfig = common.extensions.provider[providerId].config;\n  var config = utils.validateAgainstSchema(req.body, providerConfig);\n\n  // Update project's provider config\n  _.extend(req.project.provider.config, config);\n  debug(`New provider config: ${JSON.stringify(req.project.provider.config)}`);\n  req.project.markModified('provider.config');\n\n  req.project.save(function (err, project) {\n    if (err) {\n      debug(`Save error: ${err.message}`);\n      return res.status(500).send({\n        error: 'Failed to save provider config'\n      });\n    }\n\n    res.send(project.provider.config);\n  });\n});\n\nmodule.exports = router;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/websockets.js":"'use strict';\n\nvar io = require('socket.io');\nvar cookieParser = require('cookie-parser');\nvar config = require('./config');\nvar common = require('./common');\nvar UserSocket = require('./utils/user-socket');\nvar expressParser = cookieParser(config.session_secret);\n\n/*\n * websockets.init()\n *\n * Initialize the Socket.io server.\n */\n// sio: socketio server. ex: io.listen(server)\nfunction UserSockets(sio, sessionStore) {\n  this.sio = sio;\n  this.sockets = {};\n  this.sessionStore = sessionStore;\n  //sio.enable('browser client minification');  // send minified client\n  //sio.enable('browser client etag');          // apply etag caching logic based on version number\n  //sio.enable('browser client gzip');\n  //sio.set('log level', 1);\n  //sio.set('authorization', authorize.bind(this, sessionStore))\n  sio.use(authorize.bind(this, sessionStore));\n  sio.sockets.on('connection', this.connected.bind(this));\n}\n\nmodule.exports = UserSockets;\n\nUserSockets.prototype = {\n  addSocket: function (uid, socket) {\n    if (!this.sockets[uid]) {\n      this.sockets[uid] = new UserSocket(uid);\n    }\n    this.sockets[uid].add(socket);\n  },\n  // -> true if the socket was found and removed. false if it wasn't found\n  removeSocket: function (uid, socket) {\n    var socks = this.sockets[uid];\n    if (!socks) return false;\n    return socks.remove(socket);\n  },\n  // socket callback. Adds a new socket\n  connected: function (socket) {\n    var session = socket.handshake.session;\n\n    if (session && session.passport) {\n      this.addSocket(session.passport.user, socket);\n    } else {\n      console.debug('Websocket connection does not have authorization - nothing to do.');\n    }\n  },\n  // send a message to a number of users\n  // send([uid, uid, ...], arguments)\n  send: function (users, args) {\n    for (var i = 0; i < users.length; i++) {\n      if (!this.sockets[users[i]]) continue;\n      this.sockets[users[i]].emit(args);\n    }\n  },\n  // send a message to a number of users running callback to get args\n  // send([uid, uid, ...], callback)\n  sendEach: function (users, fn) {\n    for (var i = 0; i < users.length; i++) {\n      if (!this.sockets[users[i]] || !this.sockets[users[i]].user) continue;\n      this.sockets[users[i]].emit(fn(this.sockets[users[i]].user));\n    }\n  },\n  // send a public message - to all /but/ the specified users\n  sendPublic: function (users, args) {\n    for (var id in this.sockets) {\n      if (users.indexOf(id) !== -1) continue;\n      this.sockets[id].emit(args);\n    }\n  }\n};\n\nfunction authorize(sessionStore, data, next) {\n  if (data.handshake.headers.cookie) {\n    var req = data.handshake;\n    expressParser(req, {}, function () {\n      var sessionID = req.signedCookies['connect.sid'];\n      sessionStore.get(sessionID, function (err, session) {\n        if (err || !session) {\n          next(new Error('not authorized'));\n        } else {\n          req.session = session;\n          next();\n        }\n      });\n    });\n  } else {\n    return next(new Error('not authorized'));\n  }\n}\n\nmodule.exports.init = function (server, sessionStore) {\n  return common.ws = new UserSockets(io.listen(server), sessionStore);\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/utils/user-socket.js":"'use strict';\n\nvar gravatar = require('gravatar');\nvar models = require('../models');\nvar common = require('../common');\nvar jobs = require('../jobs');\nvar utils = require('../utils');\nvar Project = models.Project;\nvar User = models.User;\nvar Job = models.Job;\n\nfunction UserSocket(userid) {\n  this.userid = userid;\n  this.sockets = [];\n}\n\nmodule.exports = UserSocket;\n\nUserSocket.prototype = {\n  add: function (socket) {\n    var waiters = {};\n    var self = this;\n\n    for (var name in this.events) {\n      socket.on(name, (waiters[name] = waiter(socket, name)).handler);\n    }\n\n    this.getUser(function () {\n      for (var name in self.events) {\n        unWait(socket, waiters[name], self.events[name].bind(self));\n      }\n    });\n\n    this.sockets.push(socket);\n  },\n\n  remove: function (socket) {\n    var idx = this.sockets.indexOf(socket);\n    if (idx === -1) return false;\n    this.sockets.splice(idx, 1);\n    return true;\n  },\n\n  /**\n   * Emit an even on all sockets\n   */\n  emit: function (args) {\n    this.sockets.forEach(function (socket) {\n      socket.emit.apply(socket, args);\n    });\n  },\n\n  /**\n   * Apply handlers for all sockets\n   */\n  on: function () {\n    this.sockets.forEach(function (socket) {\n      socket.on.apply(socket, arguments);\n    });\n  },\n\n  getUser: function (done) {\n    if (!this.userid) return done();\n    var self = this;\n\n    User.findById(this.userid, function (err, user) {\n      if (err) console.error('failed to get user - socket', err);\n      if (!user) {\n        console.error('user not found for the websocket - there\\'s something strange going on w/ websocket auth. User Id: ', self.userid);\n        self.emit(['auth.failed']);\n        return;\n      }\n      self.user = user;\n      done();\n    });\n  },\n\n  events: {\n    'dashboard:jobs': function (done) {\n      jobs.latestJobs(this.user, function (err, jobs) {\n        done(jobs);\n      });\n    },\n\n    'dashboard:unknown': function (id, done) {\n      var user = this.user;\n\n      Job.findById(id).lean().exec(function (err, job) {\n        if (err || !job) return console.error('[unknownjob] error getting job', id, err);\n        Project.findOne({name: job.project.toLowerCase()}).lean().exec(function (err, project) {\n          if (err || !project) return console.error('[unknownjob] error getting project', id, err);\n          var njob = jobs.small(job);\n          njob.project = utils.sanitizeProject(project);\n          njob.project.access_level = User.projectAccessLevel(user, project);\n          // this will be filled in\n          njob.project.prev = [];\n          done(njob);\n        });\n      });\n    },\n\n    'build:job': function (id, done) {\n      var user = this.user;\n\n      Job.findById(id).lean().exec(function (err, job) {\n        if (err) return console.error('Error retrieving job', id, err.message, err.stack);\n        if (!job) return console.error('Job not found', id);\n\n        Project.findOne({name: job.project.toLowerCase()}).lean().exec(function (err, project) {\n          if (err || !project) return console.error('Error getting project', job.project, err);\n          job.status = jobs.status(job);\n          job.project = utils.sanitizeProject(project);\n          job.project.access_level = User.projectAccessLevel(user, project);\n          job.project.prev = [];\n          done(job);\n        });\n      });\n    },\n\n    'build:unknown': function () {\n      // TODO: query the responsible runner to get the current output, etc.\n    },\n\n    'test': function (project, branch) {\n      var user = this.user;\n\n      startJob(project, user, branch, 'TEST_ONLY');\n    },\n\n    'deploy': function (project, branch) {\n      var user = this.user;\n\n      startJob(project, user, branch, 'TEST_AND_DEPLOY');\n    },\n\n    'cancel': function (id) {\n      console.log('Got a request to cancel', id);\n      var self = this;\n\n      Job.findById(id).lean().exec(function (err, job) {\n        if (err || !job) return console.error('[canceljob] error getting job', id, err);\n        Project.findOne({name: job.project.toLowerCase()}).lean().exec(function (err, project) {\n          if (err || !project) return console.error('[canceljob] error getting project', id, err);\n          if (!job) return console.error('[canceljob] Job not found', id);\n          if (User.projectAccessLevel(self.user, project) > 0) {\n            common.emitter.emit('job.cancel', id);\n          }\n        });\n      });\n    },\n\n    'restart': function () {\n      console.log('Implementation needed');\n    }\n  }\n};\n\nfunction waiter(socket, event) {\n  var wait = {\n    event: event,\n    calls: [],\n    handler: function () {\n      wait.calls.push(arguments);\n    }\n  };\n  return wait;\n}\n\nfunction unWait(socket, waiter, handler) {\n  socket.removeListener(waiter.event, waiter.handler);\n  socket.on(waiter.event, handler);\n  for (var i = 0; i < waiter.calls.length; i++) {\n    handler.apply(null, waiter.calls[i]);\n  }\n}\n\nfunction kickoffJob(user, project, type, branch) {\n  var now = new Date();\n  var trigger;\n  var job;\n\n  branch = branch || 'master';\n\n  trigger = {\n    type: 'manual',\n    author: {\n      id: user._id,\n      email: user.email,\n      image: gravatar.url(user.email, {}, true)\n    },\n    message: type === 'TEST_AND_DEPLOY' ? 'Manually Redeploying' : 'Manually Retesting',\n    timestamp: now,\n    source: {type: 'UI', page: 'unknown'}\n  };\n\n  if (branch !== 'master') {\n    trigger.message += ` ${branch}`;\n  }\n\n  job = {\n    type: type,\n    user_id: user._id,\n    project: project,\n    ref: {branch: branch},\n    trigger: trigger,\n    created: now\n  };\n\n  common.emitter.emit('job.prepare', job);\n}\n\nfunction startJob(projectName, user, branch, jobType) {\n  Project.findOne({name: projectName}).lean().exec(function (err, project) {\n    if (User.projectAccessLevel(user, project) > 0) {\n      kickoffJob(user, project.name, jobType, branch);\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/plugin-templates.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar swig = require('swig');\nvar async = require('async');\n\n// TODO - better name - this is block:func plugin map\nvar cache = {};\n\n// Generate func for string template names\nfunction registerTemplate(name, template, dir) {\n  cache[name] = function (context, cb) {\n    if (/\\.html$/.test(template)){\n      dir = dir || '.';\n      template = fs.readFileSync(path.join(dir, template), 'utf8');\n    }\n\n    cb(null, template);\n  };\n}\n\n\nfunction registerBlock(block, render) {\n  cache[block] = render;\n}\n\n\n// This generates a generator that will\n// render the appropriate block in a form\n// suitable for async.parallel.\nfunction getPluginTemplate(name, context) {\n  return function (cb) {\n    if (cache[name]){\n      cache[name](context, function (err, res) {\n        if (err) return cb(err);\n        cb(null, [name, res]);\n      });\n    } else {\n      cb(null, null);\n    }\n  };\n}\n\n\n// Express 3 Template Engine\nfunction engine(path, options, fn) {\n  options.filename = path;\n\n  fs.readFile(path, 'utf8', function (err, str) {\n    if (err) return fn(err);\n    engine.render(str, options, fn);\n  });\n}\n\n// This Render function is a bit complicated, as we're essentially\n// monkeypatching swig.render to async collect the appropriate\n// extension blocks, render them, and then render them into the\n// template.\n//\n// Because we don't know which blocks are on which page, we actually\n// end up rendering the template twice - first to work out which\n// blocks are needed, and second, to actually insert them.\nengine.render = function (str, options, fn) {\n  try {\n    // Compile\n    options._striderRegister = []; // register of templates needed\n    options._striderBlocks = {}; // output of pluginblocks\n\n    var tmpl = swig.compile(str, options);\n\n    // Which plugins were needed?\n    // Render 1st pass\n    tmpl(options);\n\n    var exts = options._striderRegister.map(function (name) {\n      return getPluginTemplate(name, this);\n    }, options);\n\n    // Call each block of plugin\n    async.parallel(exts, function (err, blocks){\n      if (err) return fn(err);\n\n      for (var i=0; i< blocks.length; i++){ \n        if (blocks[i]){\n          options._striderBlocks[blocks[i][0]] = blocks[i][1];\n        }\n      }\n\n      // Render template with the _striderBlocks\n      fn(null, tmpl(options));\n    });\n\n\n  } catch (err) {\n    fn(err);\n  }\n};\n\n\n\nmodule.exports = {\n  registerBlock: registerBlock,\n  registerTemplate: registerTemplate,\n  engine: engine\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/admin/index.js":"'use strict';\n\nvar base32 = require('thirty-two');\nvar crypto = require('crypto');\nvar debug = require('debug')('strider:routes:admin');\nvar humane = require('../../humane');\nvar InviteCode = require('../../models').InviteCode;\nvar Job = require('../../models').Job;\nvar pjson = require('../../../package.json');\nvar Project = require('../../models').Project;\nvar projects = require('../../projects');\nvar Step = require('step');\nvar User = require('../../models').User;\nvar users = require('../../users');\nvar utils = require('../../utils');\n\n/*\n * makeInviteCode()\n *\n * Generate a sweet BASE32 invite code\n */\nfunction makeInviteCode() {\n  var random = crypto.randomBytes(5).toString('hex');\n  return base32.encode(random);\n}\n\n/*\n * GET /admin/invites - admin interface for invites\n */\nexports.invites = function (req, res) {\n  InviteCode.find({}).populate('consumed_by_user').sort({'_id': -1}).exec(function (err, results) {\n    results.forEach(function (invite) {\n      invite.created = humane.humaneDate(invite.created_timestamp);\n      invite.consumed = humane.humaneDate(invite.consumed_timestamp);\n    });\n\n    res.render('admin/invites.html', {\n      invite_code: makeInviteCode(),\n      invite_codes: results,\n      version: pjson.version\n    });\n  });\n};\n\n/*\n * GET /admin/users - admin interface for users\n */\n\nexports.users = function (req, res) {\n  User.find({}).sort({'_id': -1}).exec(function (err, users) {\n    res.render('admin/users.html', {\n      flash: req.flash('admin'),\n      version: pjson.version,\n      users: users.map(function (user) {\n        user.created_date = humane.humaneDate(utils.timeFromId(user.id));\n        return user;\n      })\n    });\n  });\n};\n\nexports.makeAdmin = function (req, res) {\n  if (!req.query.user) {\n    return res.redirect('/admin/users');\n  }\n  users.makeAdmin(req.query.user, function (err) {\n    if (err) {\n      debug(err);\n      return res.send(500, 'Error making admin user');\n    }\n    res.redirect('/admin/users');\n  });\n};\n\nexports.removeUser = function (req, res) {\n  User.findOne({email: req.body.email}, function (err, user) {\n    if (err || !user) {\n      req.flash('admin', 'Failed to find user');\n      return res.redirect('/admin/users');\n    }\n    Project.collection.remove({\n      creator: user._id\n    }, function (err, number) {\n      if (err) req.flash('admin', 'Failed to remove projects');\n      req.flash('admin', `Removed ${number} projects owned by ${user.email}`);\n      user.remove(function (err) {\n        if (err) req.flash('admin', 'Failed to remove user');\n        res.redirect('/admin/users');\n      });\n    });\n  });\n};\n\n/*\n * GET /admin/projects - admin interface for projects\n */\n\nexports.projects = function (req, res) {\n  projects.allProjects(function (err, projects) {\n    if (err) return res.send(500, 'Error retrieving projects');\n    res.render('admin/projects.html', {\n      projects: projects,\n      version: pjson.version\n    });\n  });\n};\n\n/*\n * GET /admin/plugins\n * PUT /admin/plugins/:id */\nexports.plugins = require('./plugins');\n\n\n// XXX: what are we trying to do here??? - jaredly\n\n/*\n * index.admin_job - build the admin job detail page\n * this is very similar although slightly different from the job function above.\n * at some point they should be refactored to combine redundant func.\n */\nexports.job = function (req, res) {\n  res.statusCode = 200;\n  var org = req.params.org;\n  var repo = req.params.repo;\n  var jobId = req.params.job_id;\n  var repoUrl = `https://github.com/${org}/${repo}`;\n\n  repoUrl = repoUrl.toLowerCase();\n\n  Step(\n    function runQueries() {\n      debug(`Querying for job id: ${jobId}`);\n      Job.findById(jobId).populate('_owner').exec(this.parallel());\n\n      debug(`Querying for last 20 jobs for ${repoUrl}`);\n      Job.find()\n        .sort({'finished_timestamp': -1})\n        .where('finished_timestamp').ne(null)\n        .where('repo_url', repoUrl)\n        .where('type').in(['TEST_ONLY', 'TEST_AND_DEPLOY'])\n        .limit(20)\n        .populate('_owner')\n        .exec(this.parallel());\n    },\n    function processAndRender(err, resultsDetail, results) {\n      if (err) throw err;\n\n      results.forEach(function (job) {\n        job.duration = Math.round((job.finished_timestamp - job.created_timestamp) / 1000);\n        job.finished_at = humane.humaneDate(job.finished_timestamp);\n        if (job.github_commit_info.id !== undefined) {\n          job.triggered_by_commit = true;\n          job.gravatar_url = utils.gravatar(job.github_commit_info.author.email);\n\n          if (job.github_commit_info.author.username !== undefined) {\n            job.committer = job.github_commit_info.author.username;\n            job.committer_is_username = true;\n          } else {\n            job.committer = job.github_commit_info.author.name;\n            job.committer_is_username = false;\n          }\n        }\n        job.url = `/admin/${org}/${repo}/job/${job.id}`;\n      });\n\n      // if resultsDetail did not return, that means this is not a valid job id\n      if (resultsDetail === undefined) {\n        res.render(404, 'invalid job id');\n      } else {\n        resultsDetail.duration = Math.round((resultsDetail.finished_timestamp - resultsDetail.created_timestamp) / 1000);\n        resultsDetail.finished_at = humane.humaneDate(resultsDetail.finished_timestamp);\n\n        var triggeredByCommit = false;\n\n        if (resultsDetail.github_commit_info.id !== undefined) {\n          triggeredByCommit = true;\n          resultsDetail.gravatar_url = utils.gravatar(resultsDetail.github_commit_info.author.email);\n\n          if (resultsDetail.github_commit_info.author.username !== undefined) {\n            resultsDetail.committer = resultsDetail.github_commit_info.author.username;\n            resultsDetail.committer_is_username = true;\n          } else {\n            resultsDetail.committer = resultsDetail.github_commit_info.author.name;\n            resultsDetail.committer_is_username = false;\n          }\n        }\n\n        resultsDetail.output = resultsDetail.stdmerged.replace(/\\[(\\d)?\\d*m/gi, '');\n\n        var hasProdDeployTarget = false;\n        var adminView = true;\n\n        res.render('job.html', {\n          admin_view: adminView,\n          jobs: results,\n          results_detail: resultsDetail,\n          job_id: results[0].id.substr(0, 8),\n          triggered_by_commit: triggeredByCommit,\n          org: org,\n          repo: repo,\n          repo_url: repoUrl,\n          has_prod_deploy_target: hasProdDeployTarget,\n          version: pjson.version\n        });\n      }\n    }\n  );\n};\n\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/humane.js":"'use strict';\n\n/*\n * Javascript Humane Dates\n * Copyright (c) 2008 Dean Landolt (deanlandolt.com)\n * Re-write by Zach Leatherman (zachleat.com)\n *\n * Adopted from the John Resig's pretty.js\n * at http://ejohn.org/blog/javascript-pretty-date\n * and henrah's proposed modification\n * at http://ejohn.org/blog/javascript-pretty-date/#comment-297458\n *\n * Licensed under the MIT license.\n */\n\nexports.humaneDate = function humaneDate(date, compareTo) {\n  if (!date) {\n    return;\n  }\n\n  var lang = {\n    ago: 'Ago',\n    from: '',\n    now: 'Just Now',\n    minute: 'Minute',\n    minutes: 'Minutes',\n    hour: 'Hour',\n    hours: 'Hours',\n    day: 'Day',\n    days: 'Days',\n    week: 'Week',\n    weeks: 'Weeks',\n    month: 'Month',\n    months: 'Months',\n    year: 'Year',\n    years: 'Years'\n  };\n  var formats = [\n    [60, lang.now],\n    [3600, lang.minute, lang.minutes, 60], // 60 minutes, 1 minute\n    [86400, lang.hour, lang.hours, 3600], // 24 hours, 1 hour\n    [604800, lang.day, lang.days, 86400], // 7 days, 1 day\n    [2628000, lang.week, lang.weeks, 604800], // ~1 month, 1 week\n    [31536000, lang.month, lang.months, 2628000], // 1 year, ~1 month\n    [Infinity, lang.year, lang.years, 31536000] // Infinity, 1 year\n  ];\n  var isString = typeof date == 'string';\n  date = isString ?\n    new Date(date.replace(/-/g, '/').replace(/[TZ]/g, ' ')) :\n    date;\n\n  compareTo = compareTo || new Date;\n  var seconds = (compareTo - date +\n      (compareTo.getTimezoneOffset() -\n        // if we received a GMT time from a string, doesn't include time zone bias\n        // if we got a date object, the time zone is built in, we need to remove it.\n        (isString ? 0 : date.getTimezoneOffset())\n      ) * 60000\n    ) / 1000;\n\n  var token;\n  if (seconds < 0) {\n    seconds = Math.abs(seconds);\n    token = lang.from ? ` ${lang.from}` : '';\n  } else {\n    token = lang.ago ? ` ${lang.ago}` : '';\n  }\n\n  /*\n   * 0 seconds && < 60 seconds        Now\n   * 60 seconds                       1 Minute\n   * > 60 seconds && < 60 minutes     X Minutes\n   * 60 minutes                       1 Hour\n   * > 60 minutes && < 24 hours       X Hours\n   * 24 hours                         1 Day\n   * > 24 hours && < 7 days           X Days\n   * 7 days                           1 Week\n   * > 7 days && < ~ 1 Month          X Weeks\n   * ~ 1 Month                        1 Month\n   * > ~ 1 Month && < 1 Year          X Months\n   * 1 Year                           1 Year\n   * > 1 Year                         X Years\n   *\n   * Single units are +10%. 1 Year shows first at 1 Year + 10%\n   */\n\n  function normalize(val, single) {\n    var margin = 0.1;\n    if (val >= single && val <= single * (1 + margin)) {\n      return single;\n    }\n    return val;\n  }\n\n  for (var i = 0, format = formats[0]; formats[i]; format = formats[++i]) {\n    if (seconds < format[0]) {\n      if (i === 0) {\n        // Now\n        return format[1];\n      }\n\n      var val = Math.ceil(normalize(seconds, format[3]) / (format[3]));\n      return `${val} ${(val != 1 ? format[2] : format[1])}${(i > 0 ? token : '')}`;\n    }\n  }\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/projects.js":"'use strict';\n\nvar utils = require('./utils');\nvar models = require('./models');\n\nvar Project = models.Project;\nvar User = models.User;\n\nmodule.exports = {\n  allProjects: allProjects\n};\n\n// Get a sanitized listing of all projects, along with the users who have access\nfunction allProjects(done) {\n  User.find({}, function (err, users) {\n    if (err) return done(err);\n\n    Project.find()\n      .sort({_id: -1})\n      .exec(function (err, projects) {\n        if (err) return done(err);\n        done(null, projects.map(function (project) {\n          project = utils.sanitizeProject(project);\n          project.created_date = utils.timeFromId(project._id);\n          project.users = [];\n          for (var i = 0; i < users.length; i++) {\n            if ('undefined' !== typeof users[i].projects[project.name]) {\n              project.users.push({\n                email: users[i].email,\n                access: users[i].projects[project.name]\n              });\n            }\n          }\n          return project;\n        }));\n      });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/users.js":"'use strict';\n\nvar User = require('./models').User;\nvar email = require('./email');\nvar env = process.env.NODE_ENV;\n\nmodule.exports = {\n  makeAdmin: makeAdmin\n};\n\nfunction makeAdmin(user, done) {\n  if (typeof user !== 'string' && user.email) {\n    user = user.email;\n  }\n\n  User.update({ email: user }, { account_level: 1 }, {}, function (err, num) {\n    if (err) return done(err);\n    if (!num) return done();\n\n    console.log(`Admin status granted to: ${user}`);\n\n    // if in production, notify all other admins about new admin\n    if (env === 'production') {\n      getAdmins(function (err, admins) {\n        admins\n          .filter(function removeSelf(admin) {\n            return admin.email !== user.email;\n          })\n          .forEach(function notifyAdmin(admin) {\n            email.notifyNewAdmin(user, admin.email);\n          });\n      });\n    }\n\n    done(null, num);\n  });\n}\n\nfunction getAdmins(done) {\n  User.find({ account_level: 1 }, function (err, admins) {\n    done(err, admins);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/admin/plugins/index.js":"'use strict';\n\nvar restart = require('./restart');\nvar getPluginList = require('./get_plugin_list');\nvar pluginManager = require('./plugin_manager');\n\nmodule.exports = {\n  /**\n   * Render a plugin management web interface\n   * GET /admin/plugins\n   */\n  get: function (req, res, next) {\n    getPluginList(function (err, list) {\n      if (err) return next(err);\n\n      res.render('admin/plugins.html', {\n        plugins: list\n      });\n    });\n  },\n\n  /**\n   * Change a plugin (uninstall, install, upgrade)\n   * PUT /admin/plugins\n   */\n  put: function (req, res) {\n    pluginManager[req.body.action](req.body.id, function (err) {\n      if (err) return res.status(500).end(err.message);\n\n      res.json({ok: 'restarting strider'});\n      restart();\n    });\n  }\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/admin/plugins/restart.js":"'use strict';\n\nmodule.exports = require('strider-cli/lib/resilient')({\n  /**\n   * Path to file to touch to restart strider\n   */\n  restartFile: function () {\n    var path = require('path');\n    var dir = path.join(__dirname, '..', '..', '..', '..');\n\n    return path.join(dir, '.restart');\n  }\n}).restart;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-cli/lib/resilient.js":"'use strict';\n\nvar cluster = require('cluster');\nvar chokidar = require('chokidar');\nvar touch = require('touch');\n\nmodule.exports = function (deps) {\n  var flag = deps.restartFile();\n\n  return {\n    restart: function () {\n      touch.sync(flag);\n      console.log('touched ' + flag);\n    },\n    spawn: function (work, noCluster) {\n      if (noCluster) return work();\n      if (cluster.isMaster) {\n        var watcher = chokidar.watch(flag)\n\n        cluster.on('online', function(worker) {\n          console.log(worker.process.pid +' forked');\n          watcher.removeAllListeners().on('change', function() {\n            console.log('restart flag touched');\n            worker.kill();\n          });\n        });\n\n        cluster.on('exit', function(worker, code, signal) {\n          console.log(worker.process.pid + ' died', code, signal);\n          cluster.fork();\n        });\n\n        cluster.fork();\n      } else {\n        work();\n      }\n    }\n  };\n};","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/admin/plugins/get_plugin_list.js":"'use strict';\n\nvar _ = require('lodash');\nvar path = require('path');\nvar semver = require('semver');\nrequire('../../../common');\nvar pluginPath = require('../../../plugin-path')();\nvar localPlugins = require('strider-cli/lib/plugin_manager/local_plugins')(pluginPath);\nvar client = require('strider-ecosystem-client');\n\nmodule.exports = function getPluginList(cb) {\n  var plugins = {};\n\n  client.fetchPlugins().then(function (remotePlugins) {\n    Object.keys(remotePlugins).forEach(function (name) {\n      var remote = remotePlugins[name];\n\n      plugins[name] = {\n        id: name,\n        name: remote.name || name,\n        url: remote.repo,\n        type: remote.type,\n        description: remote.description,\n        latestVersion: remote.tag,\n        installedVersion: 'no',\n        installedPath: null,\n        installed: false\n      };\n    });\n\n    localPlugins.listAll(function (err, localPlugins) {\n      localPlugins.forEach(function (plugin) {\n        var known = false;\n\n        if (plugins[plugin.name]) {\n          known = true;\n        } else {\n          known = false;\n          var pkg = require(path.join(plugin.path, 'package.json'));\n\n          plugins[plugin.name] = {\n            id: plugin.name,\n            name: plugin.title || plugin.name,\n            description: pkg.description,\n            type: pkg.strider.type,\n            latestVersion: 'unknown'\n          };\n        }\n\n        plugins[plugin.name].installedVersion = plugin.version;\n        plugins[plugin.name].installedPath = plugin.path;\n        plugins[plugin.name].installed = true;\n\n        if (known) {\n          plugins[plugin.name].outdated = semver.lt(\n            plugins[plugin.name].installedVersion,\n            plugins[plugin.name].latestVersion\n          );\n        } else {\n          plugins[plugin.name].outdated = false;\n        }\n      });\n\n      plugins = _.sortBy(plugins, 'name');\n\n      cb(null, plugins);\n    });\n  }).error(cb).catch(cb);\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/plugin-path.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar config = require('./config');\nvar extpaths = config.extpath.split(':');\n\nmodule.exports = function (extpath) {\n  var extdir = [];\n\n  for (var i in extpaths) {\n    // Extensions are either in ../node_modules (if local)\n    // or __dirname/../\n    extdir.push(path.resolve(__dirname, '..', extpaths[i]));\n\n    try {\n      fs.statSync(extdir);\n    } catch (e) {\n      extdir.pop();\n      extdir.push(path.resolve(__dirname, '..', extpaths[i]));\n    }\n  }\n\n  if (extpath) {\n    extdir.push(path.resolve(extpath));\n  }\n  return extdir;\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-cli/lib/plugin_manager/local_plugins.js":"module.exports = function(pluginsPath) {\n  var Loader = require('strider-extension-loader')\n  var loader = new Loader();\n\n  var path = require('path')\n  var _ = require('lodash')\n\n  return {\n    path: fullPath,\n    listAll: listAll,\n    listAllZipped: listAllZipped\n  }\n\n  function zip(plugins) {\n    var ids = _.pluck(plugins, 'name')\n    return _.zipObject(ids, plugins)\n  }\n\n  function fullPath() {\n    return pluginsPath[0]\n  }\n\n  function getVersion(pluginPath) {\n    return require(path.join(pluginPath, 'package.json')).version\n  }\n\n  function listAll(cb) {\n    loader.collectExtensions(pluginsPath, function(err) {\n      var plugins = []\n      var extensions = loader.extensions;\n      for (var groupName in extensions) {\n        var group = extensions[groupName]\n        for (var pluginName in group) {\n          var plugin = group[pluginName]\n          plugins.push({\n            group: groupName,\n            name: pluginName,\n            path: plugin.dir,\n            version: getVersion(plugin.dir),\n            title: plugin.title\n          })\n        }\n      }\n      cb(err, plugins);\n    })\n  }\n\n  function listAllZipped(cb) {\n    listAll(function(err, plugins) {\n      cb(err, zip(plugins))\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-cli/node_modules/lodash/dist/lodash.js":"/**\n * @license\n * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern -o ./dist/lodash.js`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre ES5 environments */\n  var undefined;\n\n  /** Used to pool arrays and objects used internally */\n  var arrayPool = [],\n      objectPool = [];\n\n  /** Used to generate unique IDs */\n  var idCounter = 0;\n\n  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */\n  var keyPrefix = +new Date + '';\n\n  /** Used as the size when optimizations are enabled for large arrays */\n  var largeArraySize = 75;\n\n  /** Used as the max size of the `arrayPool` and `objectPool` */\n  var maxPoolSize = 40;\n\n  /** Used to detect and test whitespace */\n  var whitespace = (\n    // whitespace\n    ' \\t\\x0B\\f\\xA0\\ufeff' +\n\n    // line terminators\n    '\\n\\r\\u2028\\u2029' +\n\n    // unicode category \"Zs\" space separators\n    '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n  );\n\n  /** Used to match empty string literals in compiled template source */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /**\n   * Used to match ES6 template delimiters\n   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match regexp flags from their coerced string values */\n  var reFlags = /\\w*$/;\n\n  /** Used to detected named functions */\n  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n  /** Used to match \"interpolate\" template delimiters */\n  var reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match leading whitespace and zeros to be removed */\n  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');\n\n  /** Used to ensure capturing order of template delimiters */\n  var reNoMatch = /($^)/;\n\n  /** Used to detect functions containing a `this` reference */\n  var reThis = /\\bthis\\b/;\n\n  /** Used to match unescaped characters in compiled string literals */\n  var reUnescapedString = /['\\n\\r\\t\\u2028\\u2029\\\\]/g;\n\n  /** Used to assign default `context` object properties */\n  var contextProps = [\n    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',\n    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',\n    'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify */\n  var templateCounter = 0;\n\n  /** `Object#toString` result shortcuts */\n  var argsClass = '[object Arguments]',\n      arrayClass = '[object Array]',\n      boolClass = '[object Boolean]',\n      dateClass = '[object Date]',\n      funcClass = '[object Function]',\n      numberClass = '[object Number]',\n      objectClass = '[object Object]',\n      regexpClass = '[object RegExp]',\n      stringClass = '[object String]';\n\n  /** Used to identify object classifications that `_.clone` supports */\n  var cloneableClasses = {};\n  cloneableClasses[funcClass] = false;\n  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =\n  cloneableClasses[boolClass] = cloneableClasses[dateClass] =\n  cloneableClasses[numberClass] = cloneableClasses[objectClass] =\n  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;\n\n  /** Used as an internal `_.debounce` options object */\n  var debounceOptions = {\n    'leading': false,\n    'maxWait': 0,\n    'trailing': false\n  };\n\n  /** Used as the property descriptor for `__bindData__` */\n  var descriptor = {\n    'configurable': false,\n    'enumerable': false,\n    'value': null,\n    'writable': false\n  };\n\n  /** Used to determine if values are of the language type Object */\n  var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\t': 't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Used as a reference to the global object */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Detect free variable `exports` */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module` */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports` */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n  var freeGlobal = objectTypes[typeof global] && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches\n   * or `fromIndex` constraints.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value or `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    var index = (fromIndex || 0) - 1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * An implementation of `_.contains` for cache objects that mimics the return\n   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.\n   *\n   * @private\n   * @param {Object} cache The cache object to inspect.\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `0` if `value` is found, else `-1`.\n   */\n  function cacheIndexOf(cache, value) {\n    var type = typeof value;\n    cache = cache.cache;\n\n    if (type == 'boolean' || value == null) {\n      return cache[value] ? 0 : -1;\n    }\n    if (type != 'number' && type != 'string') {\n      type = 'object';\n    }\n    var key = type == 'number' ? value : keyPrefix + value;\n    cache = (cache = cache[type]) && cache[key];\n\n    return type == 'object'\n      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)\n      : (cache ? 0 : -1);\n  }\n\n  /**\n   * Adds a given value to the corresponding cache object.\n   *\n   * @private\n   * @param {*} value The value to add to the cache.\n   */\n  function cachePush(value) {\n    var cache = this.cache,\n        type = typeof value;\n\n    if (type == 'boolean' || value == null) {\n      cache[value] = true;\n    } else {\n      if (type != 'number' && type != 'string') {\n        type = 'object';\n      }\n      var key = type == 'number' ? value : keyPrefix + value,\n          typeCache = cache[type] || (cache[type] = {});\n\n      if (type == 'object') {\n        (typeCache[key] || (typeCache[key] = [])).push(value);\n      } else {\n        typeCache[key] = true;\n      }\n    }\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default callback when a given\n   * collection is a string value.\n   *\n   * @private\n   * @param {string} value The character to inspect.\n   * @returns {number} Returns the code unit of given character.\n   */\n  function charAtCallback(value) {\n    return value.charCodeAt(0);\n  }\n\n  /**\n   * Used by `sortBy` to compare transformed `collection` elements, stable sorting\n   * them in ascending order.\n   *\n   * @private\n   * @param {Object} a The object to compare to `b`.\n   * @param {Object} b The object to compare to `a`.\n   * @returns {number} Returns the sort order indicator of `1` or `-1`.\n   */\n  function compareAscending(a, b) {\n    var ac = a.criteria,\n        bc = b.criteria,\n        index = -1,\n        length = ac.length;\n\n    while (++index < length) {\n      var value = ac[index],\n          other = bc[index];\n\n      if (value !== other) {\n        if (value > other || typeof value == 'undefined') {\n          return 1;\n        }\n        if (value < other || typeof other == 'undefined') {\n          return -1;\n        }\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to return the same value for\n    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See http://code.google.com/p/v8/issues/detail?id=90\n    return a.index - b.index;\n  }\n\n  /**\n   * Creates a cache object to optimize linear searches of large arrays.\n   *\n   * @private\n   * @param {Array} [array=[]] The array to search.\n   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.\n   */\n  function createCache(array) {\n    var index = -1,\n        length = array.length,\n        first = array[0],\n        mid = array[(length / 2) | 0],\n        last = array[length - 1];\n\n    if (first && typeof first == 'object' &&\n        mid && typeof mid == 'object' && last && typeof last == 'object') {\n      return false;\n    }\n    var cache = getObject();\n    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;\n\n    var result = getObject();\n    result.array = array;\n    result.cache = cache;\n    result.push = cachePush;\n\n    while (++index < length) {\n      result.push(array[index]);\n    }\n    return result;\n  }\n\n  /**\n   * Used by `template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {string} match The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(match) {\n    return '\\\\' + stringEscapes[match];\n  }\n\n  /**\n   * Gets an array from the array pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Array} The array from the pool.\n   */\n  function getArray() {\n    return arrayPool.pop() || [];\n  }\n\n  /**\n   * Gets an object from the object pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Object} The object from the pool.\n   */\n  function getObject() {\n    return objectPool.pop() || {\n      'array': null,\n      'cache': null,\n      'criteria': null,\n      'false': false,\n      'index': 0,\n      'null': false,\n      'number': null,\n      'object': null,\n      'push': null,\n      'string': null,\n      'true': false,\n      'undefined': false,\n      'value': null\n    };\n  }\n\n  /**\n   * Releases the given array back to the array pool.\n   *\n   * @private\n   * @param {Array} [array] The array to release.\n   */\n  function releaseArray(array) {\n    array.length = 0;\n    if (arrayPool.length < maxPoolSize) {\n      arrayPool.push(array);\n    }\n  }\n\n  /**\n   * Releases the given object back to the object pool.\n   *\n   * @private\n   * @param {Object} [object] The object to release.\n   */\n  function releaseObject(object) {\n    var cache = object.cache;\n    if (cache) {\n      releaseObject(cache);\n    }\n    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;\n    if (objectPool.length < maxPoolSize) {\n      objectPool.push(object);\n    }\n  }\n\n  /**\n   * Slices the `collection` from the `start` index up to, but not including,\n   * the `end` index.\n   *\n   * Note: This function is used instead of `Array#slice` to support node lists\n   * in IE < 9 and to ensure dense arrays are returned.\n   *\n   * @private\n   * @param {Array|Object|string} collection The collection to slice.\n   * @param {number} start The start index.\n   * @param {number} end The end index.\n   * @returns {Array} Returns the new array.\n   */\n  function slice(array, start, end) {\n    start || (start = 0);\n    if (typeof end == 'undefined') {\n      end = array ? array.length : 0;\n    }\n    var index = -1,\n        length = end - start || 0,\n        result = Array(length < 0 ? 0 : length);\n\n    while (++index < length) {\n      result[index] = array[start + index];\n    }\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new `lodash` function using the given context object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns the `lodash` function.\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See http://es5.github.io/#x11.1.5.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references */\n    var Array = context.Array,\n        Boolean = context.Boolean,\n        Date = context.Date,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /**\n     * Used for `Array` method references.\n     *\n     * Normally `Array.prototype` would suffice, however, using an array literal\n     * avoids issues in Narwhal.\n     */\n    var arrayRef = [];\n\n    /** Used for native method references */\n    var objectProto = Object.prototype;\n\n    /** Used to restore the original `_` reference in `noConflict` */\n    var oldDash = context._;\n\n    /** Used to resolve the internal [[Class]] of values */\n    var toString = objectProto.toString;\n\n    /** Used to detect if a method is native */\n    var reNative = RegExp('^' +\n      String(toString)\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n        .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n    );\n\n    /** Native method shortcuts */\n    var ceil = Math.ceil,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        fnToString = Function.prototype.toString,\n        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n        hasOwnProperty = objectProto.hasOwnProperty,\n        push = arrayRef.push,\n        setTimeout = context.setTimeout,\n        splice = arrayRef.splice,\n        unshift = arrayRef.unshift;\n\n    /** Used to set meta data on functions */\n    var defineProperty = (function() {\n      // IE 8 only accepts DOM elements\n      try {\n        var o = {},\n            func = isNative(func = Object.defineProperty) && func,\n            result = func(o, o, o) && func;\n      } catch(e) { }\n      return result;\n    }());\n\n    /* Native method shortcuts for methods with the same name as other `lodash` methods */\n    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n        nativeIsFinite = context.isFinite,\n        nativeIsNaN = context.isNaN,\n        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used to lookup a built-in constructor by [[Class]] */\n    var ctorByClass = {};\n    ctorByClass[arrayClass] = Array;\n    ctorByClass[boolClass] = Boolean;\n    ctorByClass[dateClass] = Date;\n    ctorByClass[funcClass] = Function;\n    ctorByClass[objectClass] = Object;\n    ctorByClass[numberClass] = Number;\n    ctorByClass[regexpClass] = RegExp;\n    ctorByClass[stringClass] = String;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps the given value to enable intuitive\n     * method chaining.\n     *\n     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n     * and `unshift`\n     *\n     * Chaining is supported in custom builds as long as the `value` method is\n     * implicitly or explicitly included in the build.\n     *\n     * The chainable wrapper functions are:\n     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,\n     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,\n     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,\n     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,\n     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,\n     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,\n     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,\n     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,\n     * and `zip`\n     *\n     * The non-chainable wrapper functions are:\n     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,\n     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,\n     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,\n     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,\n     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,\n     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,\n     * `template`, `unescape`, `uniqueId`, and `value`\n     *\n     * The wrapper functions `first` and `last` return wrapped values when `n` is\n     * provided, otherwise they return unwrapped values.\n     *\n     * Explicit chaining can be enabled by using the `_.chain` method.\n     *\n     * @name _\n     * @constructor\n     * @category Chaining\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns a `lodash` instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(num) {\n     *   return num * num;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor\n      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))\n       ? value\n       : new lodashWrapper(value);\n    }\n\n    /**\n     * A fast path for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @param {boolean} chainAll A flag to enable chaining for all methods\n     * @returns {Object} Returns a `lodash` instance.\n     */\n    function lodashWrapper(value, chainAll) {\n      this.__chain__ = !!chainAll;\n      this.__wrapped__ = value;\n    }\n    // ensure `new lodashWrapper` is an instance of `lodash`\n    lodashWrapper.prototype = lodash.prototype;\n\n    /**\n     * An object used to flag environments features.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    /**\n     * Detect if functions can be decompiled by `Function#toString`\n     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);\n\n    /**\n     * Detect if `Function#name` is supported (all but IE).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcNames = typeof Function.name == 'string';\n\n    /**\n     * By default, the template delimiters used by Lo-Dash are similar to those in\n     * embedded Ruby (ERB). Change the following template settings to use alternative\n     * delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': /<%-([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': /<%([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The base implementation of `_.bind` that creates the bound function and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new bound function.\n     */\n    function baseBind(bindData) {\n      var func = bindData[0],\n          partialArgs = bindData[2],\n          thisArg = bindData[4];\n\n      function bound() {\n        // `Function#bind` spec\n        // http://es5.github.io/#x15.3.4.5\n        if (partialArgs) {\n          // avoid `arguments` object deoptimizations by using `slice` instead\n          // of `Array.prototype.slice.call` and not assigning `arguments` to a\n          // variable as a ternary expression\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        // mimic the constructor's `return` behavior\n        // http://es5.github.io/#x13.2.2\n        if (this instanceof bound) {\n          // ensure `new bound` is an instance of `func`\n          var thisBinding = baseCreate(func.prototype),\n              result = func.apply(thisBinding, args || arguments);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisArg, args || arguments);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.clone` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, callback, stackA, stackB) {\n      if (callback) {\n        var result = callback(value);\n        if (typeof result != 'undefined') {\n          return result;\n        }\n      }\n      // inspect [[Class]]\n      var isObj = isObject(value);\n      if (isObj) {\n        var className = toString.call(value);\n        if (!cloneableClasses[className]) {\n          return value;\n        }\n        var ctor = ctorByClass[className];\n        switch (className) {\n          case boolClass:\n          case dateClass:\n            return new ctor(+value);\n\n          case numberClass:\n          case stringClass:\n            return new ctor(value);\n\n          case regexpClass:\n            result = ctor(value.source, reFlags.exec(value));\n            result.lastIndex = value.lastIndex;\n            return result;\n        }\n      } else {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isDeep) {\n        // check for circular references and return corresponding clone\n        var initedStack = !stackA;\n        stackA || (stackA = getArray());\n        stackB || (stackB = getArray());\n\n        var length = stackA.length;\n        while (length--) {\n          if (stackA[length] == value) {\n            return stackB[length];\n          }\n        }\n        result = isArr ? ctor(value.length) : {};\n      }\n      else {\n        result = isArr ? slice(value) : assign({}, value);\n      }\n      // add array properties assigned by `RegExp#exec`\n      if (isArr) {\n        if (hasOwnProperty.call(value, 'index')) {\n          result.index = value.index;\n        }\n        if (hasOwnProperty.call(value, 'input')) {\n          result.input = value.input;\n        }\n      }\n      // exit for shallow clone\n      if (!isDeep) {\n        return result;\n      }\n      // add the source value to the stack of traversed objects\n      // and associate it with its clone\n      stackA.push(value);\n      stackB.push(result);\n\n      // recursively populate clone (susceptible to call stack limits)\n      (isArr ? forEach : forOwn)(value, function(objValue, key) {\n        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);\n      });\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    function baseCreate(prototype, properties) {\n      return isObject(prototype) ? nativeCreate(prototype) : {};\n    }\n    // fallback for browsers without `Object.create`\n    if (!nativeCreate) {\n      baseCreate = (function() {\n        function Object() {}\n        return function(prototype) {\n          if (isObject(prototype)) {\n            Object.prototype = prototype;\n            var result = new Object;\n            Object.prototype = null;\n          }\n          return result || context.Object();\n        };\n      }());\n    }\n\n    /**\n     * The base implementation of `_.createCallback` without support for creating\n     * \"_.pluck\" or \"_.where\" style callbacks.\n     *\n     * @private\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     */\n    function baseCreateCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      // exit early for no `thisArg` or already bound by `Function#bind`\n      if (typeof thisArg == 'undefined' || !('prototype' in func)) {\n        return func;\n      }\n      var bindData = func.__bindData__;\n      if (typeof bindData == 'undefined') {\n        if (support.funcNames) {\n          bindData = !func.name;\n        }\n        bindData = bindData || !support.funcDecomp;\n        if (!bindData) {\n          var source = fnToString.call(func);\n          if (!support.funcNames) {\n            bindData = !reFuncName.test(source);\n          }\n          if (!bindData) {\n            // checks if `func` references the `this` keyword and stores the result\n            bindData = reThis.test(source);\n            setBindData(func, bindData);\n          }\n        }\n      }\n      // exit early if there are no `this` references or `func` is bound\n      if (bindData === false || (bindData !== true && bindData[1] & 1)) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 2: return function(a, b) {\n          return func.call(thisArg, a, b);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n      }\n      return bind(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `createWrapper` that creates the wrapper and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new function.\n     */\n    function baseCreateWrapper(bindData) {\n      var func = bindData[0],\n          bitmask = bindData[1],\n          partialArgs = bindData[2],\n          partialRightArgs = bindData[3],\n          thisArg = bindData[4],\n          arity = bindData[5];\n\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          key = func;\n\n      function bound() {\n        var thisBinding = isBind ? thisArg : this;\n        if (partialArgs) {\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        if (partialRightArgs || isCurry) {\n          args || (args = slice(arguments));\n          if (partialRightArgs) {\n            push.apply(args, partialRightArgs);\n          }\n          if (isCurry && args.length < arity) {\n            bitmask |= 16 & ~32;\n            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);\n          }\n        }\n        args || (args = arguments);\n        if (isBindKey) {\n          func = thisBinding[key];\n        }\n        if (this instanceof bound) {\n          thisBinding = baseCreate(func.prototype);\n          var result = func.apply(thisBinding, args);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisBinding, args);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.difference` that accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {Array} [values] The array of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          isLarge = length >= largeArraySize && indexOf === baseIndexOf,\n          result = [];\n\n      if (isLarge) {\n        var cache = createCache(values);\n        if (cache) {\n          indexOf = cacheIndexOf;\n          values = cache;\n        } else {\n          isLarge = false;\n        }\n      }\n      while (++index < length) {\n        var value = array[index];\n        if (indexOf(values, value) < 0) {\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseObject(values);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` without support for callback\n     * shorthands or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.\n     * @param {number} [fromIndex=0] The index to start from.\n     * @returns {Array} Returns a new flattened array.\n     */\n    function baseFlatten(array, isShallow, isStrict, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n\n        if (value && typeof value == 'object' && typeof value.length == 'number'\n            && (isArray(value) || isArguments(value))) {\n          // recursively flatten arrays (susceptible to call stack limits)\n          if (!isShallow) {\n            value = baseFlatten(value, isShallow, isStrict);\n          }\n          var valIndex = -1,\n              valLength = value.length,\n              resIndex = result.length;\n\n          result.length += valLength;\n          while (++valIndex < valLength) {\n            result[resIndex++] = value[valIndex];\n          }\n        } else if (!isStrict) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isEqual`, without support for `thisArg` binding,\n     * that allows partial \"_.where\" style comparisons.\n     *\n     * @private\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `a` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `b` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {\n      // used to indicate that when comparing objects, `a` has at least the properties of `b`\n      if (callback) {\n        var result = callback(a, b);\n        if (typeof result != 'undefined') {\n          return !!result;\n        }\n      }\n      // exit early for identical values\n      if (a === b) {\n        // treat `+0` vs. `-0` as not equal\n        return a !== 0 || (1 / a == 1 / b);\n      }\n      var type = typeof a,\n          otherType = typeof b;\n\n      // exit early for unlike primitive values\n      if (a === a &&\n          !(a && objectTypes[type]) &&\n          !(b && objectTypes[otherType])) {\n        return false;\n      }\n      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior\n      // http://es5.github.io/#x15.3.4.4\n      if (a == null || b == null) {\n        return a === b;\n      }\n      // compare [[Class]] names\n      var className = toString.call(a),\n          otherClass = toString.call(b);\n\n      if (className == argsClass) {\n        className = objectClass;\n      }\n      if (otherClass == argsClass) {\n        otherClass = objectClass;\n      }\n      if (className != otherClass) {\n        return false;\n      }\n      switch (className) {\n        case boolClass:\n        case dateClass:\n          // coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal\n          return +a == +b;\n\n        case numberClass:\n          // treat `NaN` vs. `NaN` as equal\n          return (a != +a)\n            ? b != +b\n            // but treat `+0` vs. `-0` as not equal\n            : (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n        case regexpClass:\n        case stringClass:\n          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)\n          // treat string primitives and their corresponding object instances as equal\n          return a == String(b);\n      }\n      var isArr = className == arrayClass;\n      if (!isArr) {\n        // unwrap any `lodash` wrapped values\n        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),\n            bWrapped = hasOwnProperty.call(b, '__wrapped__');\n\n        if (aWrapped || bWrapped) {\n          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);\n        }\n        // exit for functions and DOM nodes\n        if (className != objectClass) {\n          return false;\n        }\n        // in older versions of Opera, `arguments` objects have `Array` constructors\n        var ctorA = a.constructor,\n            ctorB = b.constructor;\n\n        // non `Object` object instances with different constructors are not equal\n        if (ctorA != ctorB &&\n              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&\n              ('constructor' in a && 'constructor' in b)\n            ) {\n          return false;\n        }\n      }\n      // assume cyclic structures are equal\n      // the algorithm for detecting cyclic structures is adapted from ES 5.1\n      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)\n      var initedStack = !stackA;\n      stackA || (stackA = getArray());\n      stackB || (stackB = getArray());\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == a) {\n          return stackB[length] == b;\n        }\n      }\n      var size = 0;\n      result = true;\n\n      // add `a` and `b` to the stack of traversed objects\n      stackA.push(a);\n      stackB.push(b);\n\n      // recursively compare objects and arrays (susceptible to call stack limits)\n      if (isArr) {\n        // compare lengths to determine if a deep comparison is necessary\n        length = a.length;\n        size = b.length;\n        result = size == length;\n\n        if (result || isWhere) {\n          // deep compare the contents, ignoring non-numeric properties\n          while (size--) {\n            var index = length,\n                value = b[size];\n\n            if (isWhere) {\n              while (index--) {\n                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {\n                  break;\n                }\n              }\n            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {\n              break;\n            }\n          }\n        }\n      }\n      else {\n        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`\n        // which, in this case, is more costly\n        forIn(b, function(value, key, b) {\n          if (hasOwnProperty.call(b, key)) {\n            // count the number of properties.\n            size++;\n            // deep compare each property value.\n            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));\n          }\n        });\n\n        if (result && !isWhere) {\n          // ensure both objects have the same number of properties\n          forIn(a, function(value, key, a) {\n            if (hasOwnProperty.call(a, key)) {\n              // `size` will be `-1` if `a` has more properties than `b`\n              return (result = --size > -1);\n            }\n          });\n        }\n      }\n      stackA.pop();\n      stackB.pop();\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.merge` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     */\n    function baseMerge(object, source, callback, stackA, stackB) {\n      (isArray(source) ? forEach : forOwn)(source, function(source, key) {\n        var found,\n            isArr,\n            result = source,\n            value = object[key];\n\n        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {\n          // avoid merging previously merged cyclic sources\n          var stackLength = stackA.length;\n          while (stackLength--) {\n            if ((found = stackA[stackLength] == source)) {\n              value = stackB[stackLength];\n              break;\n            }\n          }\n          if (!found) {\n            var isShallow;\n            if (callback) {\n              result = callback(value, source);\n              if ((isShallow = typeof result != 'undefined')) {\n                value = result;\n              }\n            }\n            if (!isShallow) {\n              value = isArr\n                ? (isArray(value) ? value : [])\n                : (isPlainObject(value) ? value : {});\n            }\n            // add `source` and associated `value` to the stack of traversed objects\n            stackA.push(source);\n            stackB.push(value);\n\n            // recursively merge objects and arrays (susceptible to call stack limits)\n            if (!isShallow) {\n              baseMerge(value, source, callback, stackA, stackB);\n            }\n          }\n        }\n        else {\n          if (callback) {\n            result = callback(value, source);\n            if (typeof result == 'undefined') {\n              result = source;\n            }\n          }\n          if (typeof result != 'undefined') {\n            value = result;\n          }\n        }\n        object[key] = value;\n      });\n    }\n\n    /**\n     * The base implementation of `_.random` without argument juggling or support\n     * for returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns a random number.\n     */\n    function baseRandom(min, max) {\n      return min + floor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function} [callback] The function called per iteration.\n     * @returns {Array} Returns a duplicate-value-free array.\n     */\n    function baseUniq(array, isSorted, callback) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          result = [];\n\n      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,\n          seen = (callback || isLarge) ? getArray() : result;\n\n      if (isLarge) {\n        var cache = createCache(seen);\n        indexOf = cacheIndexOf;\n        seen = cache;\n      }\n      while (++index < length) {\n        var value = array[index],\n            computed = callback ? callback(value, index, array) : value;\n\n        if (isSorted\n              ? !index || seen[seen.length - 1] !== computed\n              : indexOf(seen, computed) < 0\n            ) {\n          if (callback || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseArray(seen.array);\n        releaseObject(seen);\n      } else if (callback) {\n        releaseArray(seen);\n      }\n      return result;\n    }\n\n    /**\n     * Creates a function that aggregates a collection, creating an object composed\n     * of keys generated from the results of running each element of the collection\n     * through a callback. The given `setter` function sets the keys and values\n     * of the composed object.\n     *\n     * @private\n     * @param {Function} setter The setter function.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter) {\n      return function(collection, callback, thisArg) {\n        var result = {};\n        callback = lodash.createCallback(callback, thisArg, 3);\n\n        var index = -1,\n            length = collection ? collection.length : 0;\n\n        if (typeof length == 'number') {\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, callback(value, index, collection), collection);\n          }\n        } else {\n          forOwn(collection, function(value, key, collection) {\n            setter(result, value, callback(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, either curries or invokes `func`\n     * with an optional `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of method flags to compose.\n     *  The bitmask may be composed of the following flags:\n     *  1 - `_.bind`\n     *  2 - `_.bindKey`\n     *  4 - `_.curry`\n     *  8 - `_.curry` (bound)\n     *  16 - `_.partial`\n     *  32 - `_.partialRight`\n     * @param {Array} [partialArgs] An array of arguments to prepend to those\n     *  provided to the new function.\n     * @param {Array} [partialRightArgs] An array of arguments to append to those\n     *  provided to the new function.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new function.\n     */\n    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          isPartial = bitmask & 16,\n          isPartialRight = bitmask & 32;\n\n      if (!isBindKey && !isFunction(func)) {\n        throw new TypeError;\n      }\n      if (isPartial && !partialArgs.length) {\n        bitmask &= ~16;\n        isPartial = partialArgs = false;\n      }\n      if (isPartialRight && !partialRightArgs.length) {\n        bitmask &= ~32;\n        isPartialRight = partialRightArgs = false;\n      }\n      var bindData = func && func.__bindData__;\n      if (bindData && bindData !== true) {\n        // clone `bindData`\n        bindData = slice(bindData);\n        if (bindData[2]) {\n          bindData[2] = slice(bindData[2]);\n        }\n        if (bindData[3]) {\n          bindData[3] = slice(bindData[3]);\n        }\n        // set `thisBinding` is not previously bound\n        if (isBind && !(bindData[1] & 1)) {\n          bindData[4] = thisArg;\n        }\n        // set if previously bound but not currently (subsequent curried functions)\n        if (!isBind && bindData[1] & 1) {\n          bitmask |= 8;\n        }\n        // set curried arity if not yet set\n        if (isCurry && !(bindData[1] & 4)) {\n          bindData[5] = arity;\n        }\n        // append partial left arguments\n        if (isPartial) {\n          push.apply(bindData[2] || (bindData[2] = []), partialArgs);\n        }\n        // append partial right arguments\n        if (isPartialRight) {\n          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);\n        }\n        // merge flags\n        bindData[1] |= bitmask;\n        return createWrapper.apply(null, bindData);\n      }\n      // fast path for `_.bind`\n      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;\n      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);\n    }\n\n    /**\n     * Used by `escape` to convert characters to HTML entities.\n     *\n     * @private\n     * @param {string} match The matched character to escape.\n     * @returns {string} Returns the escaped character.\n     */\n    function escapeHtmlChar(match) {\n      return htmlEscapes[match];\n    }\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized, this method returns the custom method, otherwise it returns\n     * the `baseIndexOf` function.\n     *\n     * @private\n     * @returns {Function} Returns the \"indexOf\" function.\n     */\n    function getIndexOf() {\n      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.\n     */\n    function isNative(value) {\n      return typeof value == 'function' && reNative.test(value);\n    }\n\n    /**\n     * Sets `this` binding data on a given function.\n     *\n     * @private\n     * @param {Function} func The function to set data on.\n     * @param {Array} value The data array to set.\n     */\n    var setBindData = !defineProperty ? noop : function(func, value) {\n      descriptor.value = value;\n      defineProperty(func, '__bindData__', descriptor);\n      descriptor.value = null;\n    };\n\n    /**\n     * A fallback implementation of `isPlainObject` which checks if a given value\n     * is an object created by the `Object` constructor, assuming objects created\n     * by the `Object` constructor have no inherited enumerable properties and that\n     * there are no `Object.prototype` extensions.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     */\n    function shimIsPlainObject(value) {\n      var ctor,\n          result;\n\n      // avoid non Object objects, `arguments` objects, and DOM elements\n      if (!(value && toString.call(value) == objectClass) ||\n          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {\n        return false;\n      }\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      forIn(value, function(value, key) {\n        result = key;\n      });\n      return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * Used by `unescape` to convert HTML entities to characters.\n     *\n     * @private\n     * @param {string} match The matched character to unescape.\n     * @returns {string} Returns the unescaped character.\n     */\n    function unescapeHtmlChar(match) {\n      return htmlUnescapes[match];\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Checks if `value` is an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.\n     * @example\n     *\n     * (function() { return _.isArguments(arguments); })(1, 2, 3);\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == argsClass || false;\n    }\n\n    /**\n     * Checks if `value` is an array.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.\n     * @example\n     *\n     * (function() { return _.isArray(arguments); })();\n     * // => false\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     */\n    var isArray = nativeIsArray || function(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == arrayClass || false;\n    };\n\n    /**\n     * A fallback implementation of `Object.keys` which produces an array of the\n     * given object's own enumerable property names.\n     *\n     * @private\n     * @type Function\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     */\n    var shimKeys = function(object) {\n      var index, iterable = object, result = [];\n      if (!iterable) return result;\n      if (!(objectTypes[typeof object])) return result;\n        for (index in iterable) {\n          if (hasOwnProperty.call(iterable, index)) {\n            result.push(index);\n          }\n        }\n      return result\n    };\n\n    /**\n     * Creates an array composed of the own enumerable property names of an object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     * @example\n     *\n     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      if (!isObject(object)) {\n        return [];\n      }\n      return nativeKeys(object);\n    };\n\n    /**\n     * Used to convert characters to HTML entities:\n     *\n     * Though the `>` character is escaped for symmetry, characters like `>` and `/`\n     * don't require escaping in HTML and have no special meaning unless they're part\n     * of a tag or an unquoted attribute value.\n     * http://mathiasbynens.be/notes/ambiguous-ampersands (under \"semi-related fun fact\")\n     */\n    var htmlEscapes = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n\n    /** Used to convert HTML entities to characters */\n    var htmlUnescapes = invert(htmlEscapes);\n\n    /** Used to match HTML entities and HTML characters */\n    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),\n        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources will overwrite property assignments of previous\n     * sources. If a callback is provided it will be executed to produce the\n     * assigned values. The callback is bound to `thisArg` and invoked with two\n     * arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @alias extend\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize assigning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });\n     * // => { 'name': 'fred', 'employer': 'slate' }\n     *\n     * var defaults = _.partialRight(_.assign, function(a, b) {\n     *   return typeof a == 'undefined' ? b : a;\n     * });\n     *\n     * var object = { 'name': 'barney' };\n     * defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var assign = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n        callback = args[--argsLength];\n      }\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also\n     * be cloned, otherwise they will be assigned by reference. If a callback\n     * is provided it will be executed to produce the cloned values. If the\n     * callback returns `undefined` cloning will be handled by the method instead.\n     * The callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var shallow = _.clone(characters);\n     * shallow[0] === characters[0];\n     * // => true\n     *\n     * var deep = _.clone(characters, true);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * _.mixin({\n     *   'clone': _.partialRight(_.clone, function(value) {\n     *     return _.isElement(value) ? value.cloneNode(false) : undefined;\n     *   })\n     * });\n     *\n     * var clone = _.clone(document.body);\n     * clone.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, callback, thisArg) {\n      // allows working with \"Collections\" methods without using their `index`\n      // and `collection` arguments for `isDeep` and `callback`\n      if (typeof isDeep != 'boolean' && isDeep != null) {\n        thisArg = callback;\n        callback = isDeep;\n        isDeep = false;\n      }\n      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates a deep clone of `value`. If a callback is provided it will be\n     * executed to produce the cloned values. If the callback returns `undefined`\n     * cloning will be handled by the method instead. The callback is bound to\n     * `thisArg` and invoked with one argument; (value).\n     *\n     * Note: This method is loosely based on the structured clone algorithm. Functions\n     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and\n     * objects created by constructors other than `Object` are cloned to plain `Object` objects.\n     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var deep = _.cloneDeep(characters);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'node': element\n     * };\n     *\n     * var clone = _.cloneDeep(view, function(value) {\n     *   return _.isElement(value) ? value.cloneNode(true) : undefined;\n     * });\n     *\n     * clone.node == view.node;\n     * // => false\n     */\n    function cloneDeep(value, callback, thisArg) {\n      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties ? assign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional defaults of the same property will be ignored.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param- {Object} [guard] Allows working with `_.reduce` without using its\n     *  `key` and `object` arguments as sources.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var object = { 'name': 'barney' };\n     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var defaults = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (typeof result[index] == 'undefined') result[index] = iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * This method is like `_.findIndex` except that it returns the key of the\n     * first element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': false },\n     *   'fred': {    'age': 40, 'blocked': true },\n     *   'pebbles': { 'age': 1,  'blocked': false }\n     * };\n     *\n     * _.findKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (property order is not guaranteed across environments)\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findKey(characters, { 'age': 1 });\n     * // => 'pebbles'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findKey(characters, 'blocked');\n     * // => 'fred'\n     */\n    function findKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwn(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': true },\n     *   'fred': {    'age': 40, 'blocked': false },\n     *   'pebbles': { 'age': 1,  'blocked': true }\n     * };\n     *\n     * _.findLastKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles`, assuming `_.findKey` returns `barney`\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastKey(characters, { 'age': 40 });\n     * // => 'fred'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastKey(characters, 'blocked');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwnRight(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object,\n     * executing the callback for each property. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, key, object). Callbacks may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forIn(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)\n     */\n    var forIn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        for (index in iterable) {\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forIn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forInRight(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'\n     */\n    function forInRight(object, callback, thisArg) {\n      var pairs = [];\n\n      forIn(object, function(value, key) {\n        pairs.push(key, value);\n      });\n\n      var length = pairs.length;\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(pairs[length--], pairs[length], object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Iterates over own enumerable properties of an object, executing the callback\n     * for each property. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, key, object). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n     */\n    var forOwn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'\n     */\n    function forOwnRight(object, callback, thisArg) {\n      var props = keys(object),\n          length = props.length;\n\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        var key = props[length];\n        if (callback(object[key], key, object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Creates a sorted array of property names of all enumerable properties,\n     * own and inherited, of `object` that have function values.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names that have function values.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]\n     */\n    function functions(object) {\n      var result = [];\n      forIn(object, function(value, key) {\n        if (isFunction(value)) {\n          result.push(key);\n        }\n      });\n      return result.sort();\n    }\n\n    /**\n     * Checks if the specified property name exists as a direct property of `object`,\n     * instead of an inherited property.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to check.\n     * @returns {boolean} Returns `true` if key is a direct property, else `false`.\n     * @example\n     *\n     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n     * // => true\n     */\n    function has(object, key) {\n      return object ? hasOwnProperty.call(object, key) : false;\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of the given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the created inverted object.\n     * @example\n     *\n     * _.invert({ 'first': 'fred', 'second': 'barney' });\n     * // => { 'fred': 'first', 'barney': 'second' }\n     */\n    function invert(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        result[object[key]] = key;\n      }\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a boolean value.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.\n     * @example\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        value && typeof value == 'object' && toString.call(value) == boolClass || false;\n    }\n\n    /**\n     * Checks if `value` is a date.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     */\n    function isDate(value) {\n      return value && typeof value == 'object' && toString.call(value) == dateClass || false;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     */\n    function isElement(value) {\n      return value && value.nodeType === 1 || false;\n    }\n\n    /**\n     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a\n     * length of `0` and objects with no own enumerable properties are considered\n     * \"empty\".\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({});\n     * // => true\n     *\n     * _.isEmpty('');\n     * // => true\n     */\n    function isEmpty(value) {\n      var result = true;\n      if (!value) {\n        return result;\n      }\n      var className = toString.call(value),\n          length = value.length;\n\n      if ((className == arrayClass || className == stringClass || className == argsClass ) ||\n          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {\n        return !length;\n      }\n      forOwn(value, function() {\n        return (result = false);\n      });\n      return result;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent to each other. If a callback is provided it will be executed\n     * to compare values. If the callback returns `undefined` comparisons will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (a, b).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var copy = { 'name': 'fred' };\n     *\n     * object == copy;\n     * // => false\n     *\n     * _.isEqual(object, copy);\n     * // => true\n     *\n     * var words = ['hello', 'goodbye'];\n     * var otherWords = ['hi', 'goodbye'];\n     *\n     * _.isEqual(words, otherWords, function(a, b) {\n     *   var reGreet = /^(?:hello|hi)$/i,\n     *       aGreet = _.isString(a) && reGreet.test(a),\n     *       bGreet = _.isString(b) && reGreet.test(b);\n     *\n     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;\n     * });\n     * // => true\n     */\n    function isEqual(a, b, callback, thisArg) {\n      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));\n    }\n\n    /**\n     * Checks if `value` is, or can be coerced to, a finite number.\n     *\n     * Note: This is not the same as native `isFinite` which will return true for\n     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.\n     * @example\n     *\n     * _.isFinite(-101);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => true\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite('');\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));\n    }\n\n    /**\n     * Checks if `value` is a function.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     */\n    function isFunction(value) {\n      return typeof value == 'function';\n    }\n\n    /**\n     * Checks if `value` is the language type of Object.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // check if the value is the ECMAScript language type of Object\n      // http://es5.github.io/#x8\n      // and avoid a V8 bug\n      // http://code.google.com/p/v8/issues/detail?id=2291\n      return !!(value && objectTypes[typeof value]);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * Note: This is not the same as native `isNaN` which will return `true` for\n     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // `NaN` as a primitive is the only value that is not equal to itself\n      // (perform the [[Class]] check first to avoid errors with some host objects in IE)\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(undefined);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is a number.\n     *\n     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4 * 5);\n     * // => true\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        value && typeof value == 'object' && toString.call(value) == numberClass || false;\n    }\n\n    /**\n     * Checks if `value` is an object created by the `Object` constructor.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * _.isPlainObject(new Shape);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     */\n    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n      if (!(value && toString.call(value) == objectClass)) {\n        return false;\n      }\n      var valueOf = value.valueOf,\n          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n      return objProto\n        ? (value == objProto || getPrototypeOf(value) == objProto)\n        : shimIsPlainObject(value);\n    };\n\n    /**\n     * Checks if `value` is a regular expression.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.\n     * @example\n     *\n     * _.isRegExp(/fred/);\n     * // => true\n     */\n    function isRegExp(value) {\n      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;\n    }\n\n    /**\n     * Checks if `value` is a string.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('fred');\n     * // => true\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        value && typeof value == 'object' && toString.call(value) == stringClass || false;\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     */\n    function isUndefined(value) {\n      return typeof value == 'undefined';\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new object with values of the results of each `callback` execution.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     *\n     * var characters = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.mapValues(characters, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 }\n     */\n    function mapValues(object, callback, thisArg) {\n      var result = {};\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      forOwn(object, function(value, key, object) {\n        result[key] = callback(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * will overwrite property assignments of previous sources. If a callback is\n     * provided it will be executed to produce the merged values of the destination\n     * and source properties. If the callback returns `undefined` merging will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var names = {\n     *   'characters': [\n     *     { 'name': 'barney' },\n     *     { 'name': 'fred' }\n     *   ]\n     * };\n     *\n     * var ages = {\n     *   'characters': [\n     *     { 'age': 36 },\n     *     { 'age': 40 }\n     *   ]\n     * };\n     *\n     * _.merge(names, ages);\n     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }\n     *\n     * var food = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var otherFood = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(food, otherFood, function(a, b) {\n     *   return _.isArray(a) ? a.concat(b) : undefined;\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }\n     */\n    function merge(object) {\n      var args = arguments,\n          length = 2;\n\n      if (!isObject(object)) {\n        return object;\n      }\n      // allows working with `_.reduce` and `_.reduceRight` without using\n      // their `index` and `collection` arguments\n      if (typeof args[2] != 'number') {\n        length = args.length;\n      }\n      if (length > 3 && typeof args[length - 2] == 'function') {\n        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);\n      } else if (length > 2 && typeof args[length - 1] == 'function') {\n        callback = args[--length];\n      }\n      var sources = slice(arguments, 1, length),\n          index = -1,\n          stackA = getArray(),\n          stackB = getArray();\n\n      while (++index < length) {\n        baseMerge(object, sources[index], callback, stackA, stackB);\n      }\n      releaseArray(stackA);\n      releaseArray(stackB);\n      return object;\n    }\n\n    /**\n     * Creates a shallow clone of `object` excluding the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` omitting the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The properties to omit or the\n     *  function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object without the omitted properties.\n     * @example\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');\n     * // => { 'name': 'fred' }\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {\n     *   return typeof value == 'number';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function omit(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var props = [];\n        forIn(object, function(value, key) {\n          props.push(key);\n        });\n        props = baseDifference(props, baseFlatten(arguments, true, false, 1));\n\n        var index = -1,\n            length = props.length;\n\n        while (++index < length) {\n          var key = props[index];\n          result[key] = object[key];\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (!callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates a two dimensional array of an object's key-value pairs,\n     * i.e. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)\n     */\n    function pairs(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a shallow clone of `object` composed of the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` picking the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The function called per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object composed of the picked properties.\n     * @example\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');\n     * // => { 'name': 'fred' }\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {\n     *   return key.charAt(0) != '_';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function pick(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var index = -1,\n            props = baseFlatten(arguments, true, false, 1),\n            length = isObject(object) ? props.length : 0;\n\n        while (++index < length) {\n          var key = props[index];\n          if (key in object) {\n            result[key] = object[key];\n          }\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * An alternative to `_.reduce` this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable properties through a callback, with each callback execution\n     * potentially mutating the `accumulator` object. The callback is bound to\n     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).\n     * Callbacks may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {\n     *   num *= num;\n     *   if (num % 2) {\n     *     return result.push(num) < 3;\n     *   }\n     * });\n     * // => [1, 9, 25]\n     *\n     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     * });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function transform(object, callback, accumulator, thisArg) {\n      var isArr = isArray(object);\n      if (accumulator == null) {\n        if (isArr) {\n          accumulator = [];\n        } else {\n          var ctor = object && object.constructor,\n              proto = ctor && ctor.prototype;\n\n          accumulator = baseCreate(proto);\n        }\n      }\n      if (callback) {\n        callback = lodash.createCallback(callback, thisArg, 4);\n        (isArr ? forEach : forOwn)(object, function(value, index, object) {\n          return callback(accumulator, value, index, object);\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * Creates an array composed of the own enumerable property values of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property values.\n     * @example\n     *\n     * _.values({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => [1, 2, 3] (property order is not guaranteed across environments)\n     */\n    function values(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements from the specified indexes, or keys, of the\n     * `collection`. Indexes may be specified as individual arguments or as arrays\n     * of indexes.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`\n     *   to retrieve, specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns a new array of elements corresponding to the\n     *  provided indexes.\n     * @example\n     *\n     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);\n     * // => ['a', 'c', 'e']\n     *\n     * _.at(['fred', 'barney', 'pebbles'], 0, 2);\n     * // => ['fred', 'pebbles']\n     */\n    function at(collection) {\n      var args = arguments,\n          index = -1,\n          props = baseFlatten(args, true, false, 1),\n          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,\n          result = Array(length);\n\n      while(++index < length) {\n        result[index] = collection[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * Checks if a given value is present in a collection using strict equality\n     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the\n     * offset from the end of the collection.\n     *\n     * @static\n     * @memberOf _\n     * @alias include\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {*} target The value to check for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.\n     * @example\n     *\n     * _.contains([1, 2, 3], 1);\n     * // => true\n     *\n     * _.contains([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.contains('pebbles', 'eb');\n     * // => true\n     */\n    function contains(collection, target, fromIndex) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = collection ? collection.length : 0,\n          result = false;\n\n      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;\n      if (isArray(collection)) {\n        result = indexOf(collection, target, fromIndex) > -1;\n      } else if (typeof length == 'number') {\n        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;\n      } else {\n        forOwn(collection, function(value) {\n          if (++index >= fromIndex) {\n            return !(result = value === target);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through the callback. The corresponding value\n     * of each key is the number of times the key was returned by the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);\n    });\n\n    /**\n     * Checks if the given callback returns truey value for **all** elements of\n     * a collection. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if all elements passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes']);\n     * // => false\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.every(characters, 'age');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.every(characters, { 'age': 36 });\n     * // => false\n     */\n    function every(collection, callback, thisArg) {\n      var result = true;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (!(result = !!callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return (result = !!callback(value, index, collection));\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning an array of all elements\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that passed the callback check.\n     * @example\n     *\n     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [2, 4, 6]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.filter(characters, 'blocked');\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.filter(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     */\n    function filter(collection, callback, thisArg) {\n      var result = [];\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning the first element that\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect, findWhere\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.find(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => { 'name': 'barney', 'age': 36, 'blocked': false }\n     *\n     * // using \"_.where\" callback shorthand\n     * _.find(characters, { 'age': 1 });\n     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.find(characters, 'blocked');\n     * // => { 'name': 'fred', 'age': 40, 'blocked': true }\n     */\n    function find(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            return value;\n          }\n        }\n      } else {\n        var result;\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result = value;\n            return false;\n          }\n        });\n        return result;\n      }\n    }\n\n    /**\n     * This method is like `_.find` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(num) {\n     *   return num % 2 == 1;\n     * });\n     * // => 3\n     */\n    function findLast(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forEachRight(collection, function(value, index, collection) {\n        if (callback(value, index, collection)) {\n          result = value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, executing the callback for each\n     * element. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * Note: As with other \"Collections\" methods, objects with a `length` property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');\n     * // => logs each number and returns '1,2,3'\n     *\n     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });\n     * // => logs each number and returns the object (property order is not guaranteed across environments)\n     */\n    function forEach(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (callback(collection[index], index, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, callback);\n      }\n      return collection;\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');\n     * // => logs each number from right to left and returns '3,2,1'\n     */\n    function forEachRight(collection, callback, thisArg) {\n      var length = collection ? collection.length : 0;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (length--) {\n          if (callback(collection[length], length, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        var props = keys(collection);\n        length = props.length;\n        forOwn(collection, function(value, key, collection) {\n          key = props ? props[--length] : --length;\n          return callback(collection[key], key, collection);\n        });\n      }\n      return collection;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of a collection through the callback. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of the collection through the given callback. The corresponding\n     * value of each key is the last element responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keys = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keys, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method named by `methodName` on each element in the `collection`\n     * returning an array of the results of each invoked method. Additional arguments\n     * will be provided to each invoked method. If `methodName` is a function it\n     * will be invoked for, and `this` bound to, each element in the `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|string} methodName The name of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [arg] Arguments to invoke the method with.\n     * @returns {Array} Returns a new array of the results of each invoked method.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    function invoke(collection, methodName) {\n      var args = slice(arguments, 2),\n          index = -1,\n          isFunc = typeof methodName == 'function',\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an array of values by running each element in the collection\n     * through the callback. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of the results of each `callback` execution.\n     * @example\n     *\n     * _.map([1, 2, 3], function(num) { return num * 3; });\n     * // => [3, 6, 9]\n     *\n     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });\n     * // => [3, 6, 9] (property order is not guaranteed across environments)\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        var result = Array(length);\n        while (++index < length) {\n          result[index] = callback(collection[index], index, collection);\n        }\n      } else {\n        result = [];\n        forOwn(collection, function(value, key, collection) {\n          result[++index] = callback(value, key, collection);\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the maximum value of a collection. If the collection is empty or\n     * falsey `-Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'fred', 'age': 40 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.max(characters, 'age');\n     * // => { 'name': 'fred', 'age': 40 };\n     */\n    function max(collection, callback, thisArg) {\n      var computed = -Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value > result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current > computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the minimum value of a collection. If the collection is empty or\n     * falsey `Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'barney', 'age': 36 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.min(characters, 'age');\n     * // => { 'name': 'barney', 'age': 36 };\n     */\n    function min(collection, callback, thisArg) {\n      var computed = Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value < result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current < computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the value of a specified property from all elements in the collection.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {string} property The name of the property to pluck.\n     * @returns {Array} Returns a new array of property values.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    var pluck = map;\n\n    /**\n     * Reduces a collection to a value which is the accumulated result of running\n     * each element in the collection through the callback, where each successive\n     * callback execution consumes the return value of the previous execution. If\n     * `accumulator` is not provided the first element of the collection will be\n     * used as the initial `accumulator` value. The callback is bound to `thisArg`\n     * and invoked with four arguments; (accumulator, value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var sum = _.reduce([1, 2, 3], function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function reduce(collection, callback, accumulator, thisArg) {\n      if (!collection) return accumulator;\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n\n      var index = -1,\n          length = collection.length;\n\n      if (typeof length == 'number') {\n        if (noaccum) {\n          accumulator = collection[++index];\n        }\n        while (++index < length) {\n          accumulator = callback(accumulator, collection[index], index, collection);\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          accumulator = noaccum\n            ? (noaccum = false, value)\n            : callback(accumulator, value, index, collection)\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var list = [[0, 1], [2, 3], [4, 5]];\n     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, callback, accumulator, thisArg) {\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n      forEachRight(collection, function(value, index, collection) {\n        accumulator = noaccum\n          ? (noaccum = false, value)\n          : callback(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The opposite of `_.filter` this method returns the elements of a\n     * collection that the callback does **not** return truey for.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that failed the callback check.\n     * @example\n     *\n     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [1, 3, 5]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.reject(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.reject(characters, { 'age': 36 });\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     */\n    function reject(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n      return filter(collection, function(value, index, collection) {\n        return !callback(value, index, collection);\n      });\n    }\n\n    /**\n     * Retrieves a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Allows working with functions like `_.map`\n     *  without using their `index` arguments as `n`.\n     * @returns {Array} Returns the random sample(s) of `collection`.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (collection && typeof collection.length != 'number') {\n        collection = values(collection);\n      }\n      if (n == null || guard) {\n        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(nativeMax(0, n), result.length);\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the Fisher-Yates\n     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns a new shuffled collection.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4, 5, 6]);\n     * // => [4, 1, 6, 3, 5, 2]\n     */\n    function shuffle(collection) {\n      var index = -1,\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        var rand = baseRandom(0, ++index);\n        result[index] = result[rand];\n        result[rand] = value;\n      });\n      return result;\n    }\n\n    /**\n     * Gets the size of the `collection` by returning `collection.length` for arrays\n     * and array-like objects or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns `collection.length` or number of own enumerable properties.\n     * @example\n     *\n     * _.size([1, 2]);\n     * // => 2\n     *\n     * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => 3\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? collection.length : 0;\n      return typeof length == 'number' ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if the callback returns a truey value for **any** element of a\n     * collection. The function returns as soon as it finds a passing value and\n     * does not iterate over the entire collection. The callback is bound to\n     * `thisArg` and invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if any element passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.some(characters, 'blocked');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.some(characters, { 'age': 1 });\n     * // => false\n     */\n    function some(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if ((result = callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return !(result = callback(value, index, collection));\n        });\n      }\n      return !!result;\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through the callback. This method\n     * performs a stable sort, that is, it will preserve the original sort order\n     * of equal elements. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an array of property names is provided for `callback` the collection\n     * will be sorted by each property value.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of sorted elements.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);\n     * // => [3, 1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'barney',  'age': 26 },\n     *   { 'name': 'fred',    'age': 30 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(_.sortBy(characters, 'age'), _.values);\n     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]\n     *\n     * // sorting by multiple properties\n     * _.map(_.sortBy(characters, ['name', 'age']), _.values);\n     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]\n     */\n    function sortBy(collection, callback, thisArg) {\n      var index = -1,\n          isArr = isArray(callback),\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      if (!isArr) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      forEach(collection, function(value, key, collection) {\n        var object = result[++index] = getObject();\n        if (isArr) {\n          object.criteria = map(callback, function(key) { return value[key]; });\n        } else {\n          (object.criteria = getArray())[0] = callback(value, key, collection);\n        }\n        object.index = index;\n        object.value = value;\n      });\n\n      length = result.length;\n      result.sort(compareAscending);\n      while (length--) {\n        var object = result[length];\n        result[length] = object.value;\n        if (!isArr) {\n          releaseArray(object.criteria);\n        }\n        releaseObject(object);\n      }\n      return result;\n    }\n\n    /**\n     * Converts the `collection` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to convert.\n     * @returns {Array} Returns the new converted array.\n     * @example\n     *\n     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n     * // => [2, 3, 4]\n     */\n    function toArray(collection) {\n      if (collection && typeof collection.length == 'number') {\n        return slice(collection);\n      }\n      return values(collection);\n    }\n\n    /**\n     * Performs a deep comparison of each element in a `collection` to the given\n     * `properties` object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Object} props The object of property values to filter by.\n     * @returns {Array} Returns a new array of elements that have the given properties.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.where(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]\n     *\n     * _.where(characters, { 'pets': ['dino'] });\n     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]\n     */\n    var where = filter;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are all falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all values of the provided arrays using strict\n     * equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);\n     * // => [1, 3, 4]\n     */\n    function difference(array) {\n      return baseDifference(array, baseFlatten(arguments, true, true, 1));\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.findIndex(characters, function(chr) {\n     *   return chr.age < 20;\n     * });\n     * // => 2\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findIndex(characters, 'blocked');\n     * // => 1\n     */\n    function findIndex(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        if (callback(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': true },\n     *   { 'name': 'fred',    'age': 40, 'blocked': false },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }\n     * ];\n     *\n     * _.findLastIndex(characters, function(chr) {\n     *   return chr.age > 30;\n     * });\n     * // => 1\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastIndex(characters, 'blocked');\n     * // => 2\n     */\n    function findLastIndex(array, callback, thisArg) {\n      var length = array ? array.length : 0;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(array[length], length, array)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Gets the first element or first `n` elements of an array. If a callback\n     * is provided elements at the beginning of the array are returned as long\n     * as the callback returns truey. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head, take\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the first element(s) of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.first([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.first(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function first(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = -1;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[0] : undefined;\n        }\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, n), length));\n    }\n\n    /**\n     * Flattens a nested array (the nesting can be to any depth). If `isShallow`\n     * is truey, the array will only be flattened a single level. If a callback\n     * is provided each element of the array is passed through the callback before\n     * flattening. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2], [3, [[4]]]]);\n     * // => [1, 2, 3, 4];\n     *\n     * _.flatten([1, [2], [3, [[4]]]], true);\n     * // => [1, 2, 3, [[4]]];\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.flatten(characters, 'pets');\n     * // => ['hoppy', 'baby puss', 'dino']\n     */\n    function flatten(array, isShallow, callback, thisArg) {\n      // juggle arguments\n      if (typeof isShallow != 'boolean' && isShallow != null) {\n        thisArg = callback;\n        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;\n        isShallow = false;\n      }\n      if (callback != null) {\n        array = map(array, callback, thisArg);\n      }\n      return baseFlatten(array, isShallow);\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found using\n     * strict equality for comparisons, i.e. `===`. If the array is already sorted\n     * providing `true` for `fromIndex` will run a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 1\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 4\n     *\n     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      if (typeof fromIndex == 'number') {\n        var length = array ? array.length : 0;\n        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);\n      } else if (fromIndex) {\n        var index = sortedIndex(array, value);\n        return array[index] === value ? index : -1;\n      }\n      return baseIndexOf(array, value, fromIndex);\n    }\n\n    /**\n     * Gets all but the last element or last `n` elements of an array. If a\n     * callback is provided elements at the end of the array are excluded from\n     * the result as long as the callback returns truey. The callback is bound\n     * to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.initial([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.initial([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [1]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.initial(characters, 'blocked');\n     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function initial(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : callback || n;\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));\n    }\n\n    /**\n     * Creates an array of unique values present in all provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of shared values.\n     * @example\n     *\n     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2]\n     */\n    function intersection() {\n      var args = [],\n          argsIndex = -1,\n          argsLength = arguments.length,\n          caches = getArray(),\n          indexOf = getIndexOf(),\n          trustIndexOf = indexOf === baseIndexOf,\n          seen = getArray();\n\n      while (++argsIndex < argsLength) {\n        var value = arguments[argsIndex];\n        if (isArray(value) || isArguments(value)) {\n          args.push(value);\n          caches.push(trustIndexOf && value.length >= largeArraySize &&\n            createCache(argsIndex ? args[argsIndex] : seen));\n        }\n      }\n      var array = args[0],\n          index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      outer:\n      while (++index < length) {\n        var cache = caches[0];\n        value = array[index];\n\n        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {\n          argsIndex = argsLength;\n          (cache || seen).push(value);\n          while (--argsIndex) {\n            cache = caches[argsIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n      }\n      while (argsLength--) {\n        cache = caches[argsLength];\n        if (cache) {\n          releaseObject(cache);\n        }\n      }\n      releaseArray(caches);\n      releaseArray(seen);\n      return result;\n    }\n\n    /**\n     * Gets the last element or last `n` elements of an array. If a callback is\n     * provided elements at the end of the array are returned as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the last element(s) of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     *\n     * _.last([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.last([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.last(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.last(characters, { 'employer': 'na' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function last(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[length - 1] : undefined;\n        }\n      }\n      return slice(array, nativeMax(0, length - n));\n    }\n\n    /**\n     * Gets the index at which the last occurrence of `value` is found using strict\n     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used\n     * as the offset from the end of the collection.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 4\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var index = array ? array.length : 0;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from the given array using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {...*} [value] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull(array) {\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = args.length,\n          length = array ? array.length : 0;\n\n      while (++argsIndex < argsLength) {\n        var index = -1,\n            value = args[argsIndex];\n        while (++index < length) {\n          if (array[index] === value) {\n            splice.call(array, index--, 1);\n            length--;\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to but not including `end`. If `start` is less than `stop` a\n     * zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns a new range array.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      start = +start || 0;\n      step = typeof step == 'number' ? step : (+step || 1);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      }\n      // use `Array(length)` so engines like Chakra and V8 avoid slower modes\n      // http://youtu.be/XAqIpGU8ZZk#t=17m25s\n      var index = -1,\n          length = nativeMax(0, ceil((end - start) / (step || 1))),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Removes all elements from an array that the callback returns truey for\n     * and returns an array of removed elements. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4, 5, 6];\n     * var evens = _.remove(array, function(num) { return num % 2 == 0; });\n     *\n     * console.log(array);\n     * // => [1, 3, 5]\n     *\n     * console.log(evens);\n     * // => [2, 4, 6]\n     */\n    function remove(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (callback(value, index, array)) {\n          result.push(value);\n          splice.call(array, index--, 1);\n          length--;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The opposite of `_.initial` this method gets all but the first element or\n     * first `n` elements of an array. If a callback function is provided elements\n     * at the beginning of the array are excluded from the result as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias drop, tail\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.rest([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.rest([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.rest(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.rest(characters, { 'employer': 'slate' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function rest(array, callback, thisArg) {\n      if (typeof callback != 'number' && callback != null) {\n        var n = 0,\n            index = -1,\n            length = array ? array.length : 0;\n\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);\n      }\n      return slice(array, n);\n    }\n\n    /**\n     * Uses a binary search to determine the smallest index at which a value\n     * should be inserted into a given sorted array in order to maintain the sort\n     * order of the array. If a callback is provided it will be executed for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([20, 30, 50], 40);\n     * // => 2\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 2\n     *\n     * var dict = {\n     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }\n     * };\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return dict.wordToNumber[word];\n     * });\n     * // => 2\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return this.wordToNumber[word];\n     * }, dict);\n     * // => 2\n     */\n    function sortedIndex(array, value, callback, thisArg) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      // explicitly reference `identity` for better inlining in Firefox\n      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;\n      value = callback(value);\n\n      while (low < high) {\n        var mid = (low + high) >>> 1;\n        (callback(array[mid]) < value)\n          ? low = mid + 1\n          : high = mid;\n      }\n      return low;\n    }\n\n    /**\n     * Creates an array of unique values, in order, of the provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of combined values.\n     * @example\n     *\n     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2, 3, 5, 4]\n     */\n    function union() {\n      return baseUniq(baseFlatten(arguments, true, true));\n    }\n\n    /**\n     * Creates a duplicate-value-free version of an array using strict equality\n     * for comparisons, i.e. `===`. If the array is sorted, providing\n     * `true` for `isSorted` will use a faster algorithm. If a callback is provided\n     * each element of `array` is passed through the callback before uniqueness\n     * is computed. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([1, 2, 1, 3, 1]);\n     * // => [1, 2, 3]\n     *\n     * _.uniq([1, 1, 2, 2, 3], true);\n     * // => [1, 2, 3]\n     *\n     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });\n     * // => ['A', 'b', 'C']\n     *\n     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);\n     * // => [1, 2.5, 3]\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, callback, thisArg) {\n      // juggle arguments\n      if (typeof isSorted != 'boolean' && isSorted != null) {\n        thisArg = callback;\n        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;\n        isSorted = false;\n      }\n      if (callback != null) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      return baseUniq(array, isSorted, callback);\n    }\n\n    /**\n     * Creates an array excluding all provided values using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to filter.\n     * @param {...*} [value] The values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n     * // => [2, 3, 4]\n     */\n    function without(array) {\n      return baseDifference(array, slice(arguments, 1));\n    }\n\n    /**\n     * Creates an array that is the symmetric difference of the provided arrays.\n     * See http://en.wikipedia.org/wiki/Symmetric_difference.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of values.\n     * @example\n     *\n     * _.xor([1, 2, 3], [5, 2, 1, 4]);\n     * // => [3, 5, 4]\n     *\n     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);\n     * // => [1, 4, 5]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArray(array) || isArguments(array)) {\n          var result = result\n            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))\n            : array;\n        }\n      }\n      return result || [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second\n     * elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @alias unzip\n     * @category Arrays\n     * @param {...Array} [array] Arrays to process.\n     * @returns {Array} Returns a new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    function zip() {\n      var array = arguments.length > 1 ? arguments : arguments[0],\n          index = -1,\n          length = array ? max(pluck(array, 'length')) : 0,\n          result = Array(length < 0 ? 0 : length);\n\n      while (++index < length) {\n        result[index] = pluck(array, index);\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed from arrays of `keys` and `values`. Provide\n     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`\n     * or two arrays, one of `keys` and one of corresponding `values`.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Arrays\n     * @param {Array} keys The array of keys.\n     * @param {Array} [values=[]] The array of values.\n     * @returns {Object} Returns an object composed of the given keys and\n     *  corresponding values.\n     * @example\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(keys, values) {\n      var index = -1,\n          length = keys ? keys.length : 0,\n          result = {};\n\n      if (!values && length && !isArray(keys[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = keys[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that executes `func`, with  the `this` binding and\n     * arguments of the created function, only after being called `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {number} n The number of times the function must be called before\n     *  `func` is executed.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('Done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'Done saving!', after all saves have completed\n     */\n    function after(n, func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with the `this`\n     * binding of `thisArg` and prepends any additional `bind` arguments to those\n     * provided to the bound function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var func = function(greeting) {\n     *   return greeting + ' ' + this.name;\n     * };\n     *\n     * func = _.bind(func, { 'name': 'fred' }, 'hi');\n     * func();\n     * // => 'hi fred'\n     */\n    function bind(func, thisArg) {\n      return arguments.length > 2\n        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)\n        : createWrapper(func, 1, null, null, thisArg);\n    }\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all the function properties\n     * of `object` will be bound.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...string} [methodName] The object method names to\n     *  bind, specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() { console.log('clicked ' + this.label); }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs', when the button is clicked\n     */\n    function bindAll(object) {\n      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),\n          index = -1,\n          length = funcs.length;\n\n      while (++index < length) {\n        var key = funcs[index];\n        object[key] = createWrapper(object[key], 1, null, null, object);\n      }\n      return object;\n    }\n\n    /**\n     * Creates a function that, when called, invokes the method at `object[key]`\n     * and prepends any additional `bindKey` arguments to those provided to the bound\n     * function. This method differs from `_.bind` by allowing bound functions to\n     * reference methods that will be redefined or don't yet exist.\n     * See http://michaux.ca/articles/lazy-function-definition-pattern.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'name': 'fred',\n     *   'greet': function(greeting) {\n     *     return greeting + ' ' + this.name;\n     *   }\n     * };\n     *\n     * var func = _.bindKey(object, 'greet', 'hi');\n     * func();\n     * // => 'hi fred'\n     *\n     * object.greet = function(greeting) {\n     *   return greeting + 'ya ' + this.name + '!';\n     * };\n     *\n     * func();\n     * // => 'hiya fred!'\n     */\n    function bindKey(object, key) {\n      return arguments.length > 2\n        ? createWrapper(key, 19, slice(arguments, 2), null, object)\n        : createWrapper(key, 3, null, null, object);\n    }\n\n    /**\n     * Creates a function that is the composition of the provided functions,\n     * where each function consumes the return value of the function that follows.\n     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {...Function} [func] Functions to compose.\n     * @returns {Function} Returns the new composed function.\n     * @example\n     *\n     * var realNameMap = {\n     *   'pebbles': 'penelope'\n     * };\n     *\n     * var format = function(name) {\n     *   name = realNameMap[name.toLowerCase()] || name;\n     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\n     * };\n     *\n     * var greet = function(formatted) {\n     *   return 'Hiya ' + formatted + '!';\n     * };\n     *\n     * var welcome = _.compose(greet, format);\n     * welcome('pebbles');\n     * // => 'Hiya Penelope!'\n     */\n    function compose() {\n      var funcs = arguments,\n          length = funcs.length;\n\n      while (length--) {\n        if (!isFunction(funcs[length])) {\n          throw new TypeError;\n        }\n      }\n      return function() {\n        var args = arguments,\n            length = funcs.length;\n\n        while (length--) {\n          args = [funcs[length].apply(this, args)];\n        }\n        return args[0];\n      };\n    }\n\n    /**\n     * Creates a function which accepts one or more arguments of `func` that when\n     * invoked either executes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` can be specified\n     * if `func.length` is not sufficient.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var curried = _.curry(function(a, b, c) {\n     *   console.log(a + b + c);\n     * });\n     *\n     * curried(1)(2)(3);\n     * // => 6\n     *\n     * curried(1, 2)(3);\n     * // => 6\n     *\n     * curried(1, 2, 3);\n     * // => 6\n     */\n    function curry(func, arity) {\n      arity = typeof arity == 'number' ? arity : (+arity || func.length);\n      return createWrapper(func, 4, null, null, null, arity);\n    }\n\n    /**\n     * Creates a function that will delay the execution of `func` until after\n     * `wait` milliseconds have elapsed since the last time it was invoked.\n     * Provide an options object to indicate that `func` should be invoked on\n     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls\n     * to the debounced function will return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to debounce.\n     * @param {number} wait The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * var lazyLayout = _.debounce(calculateLayout, 150);\n     * jQuery(window).on('resize', lazyLayout);\n     *\n     * // execute `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * });\n     *\n     * // ensure `batchLog` is executed once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * source.addEventListener('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }, false);\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      wait = nativeMax(0, wait) || 0;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      var delayed = function() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      };\n\n      var maxDelayed = function() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      };\n\n      return function() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Defers executing the `func` function until the current call stack has cleared.\n     * Additional arguments will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to defer.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) { console.log(text); }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    function defer(func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 1);\n      return setTimeout(function() { func.apply(undefined, args); }, 1);\n    }\n\n    /**\n     * Executes the `func` function after `wait` milliseconds. Additional arguments\n     * will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay execution.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) { console.log(text); }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    function delay(func, wait) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 2);\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it will be used to determine the cache key for storing the result\n     * based on the arguments provided to the memoized function. By default, the\n     * first argument provided to the memoized function is used as the cache key.\n     * The `func` is executed with the `this` binding of the memoized function.\n     * The result cache is exposed as the `cache` property on the memoized function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] A function used to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var fibonacci = _.memoize(function(n) {\n     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n     * });\n     *\n     * fibonacci(9)\n     * // => 34\n     *\n     * var data = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // modifying the result cache\n     * var get = _.memoize(function(name) { return data[name]; }, _.identity);\n     * get('pebbles');\n     * // => { 'name': 'pebbles', 'age': 1 }\n     *\n     * get.cache.pebbles.name = 'penelope';\n     * get('pebbles');\n     * // => { 'name': 'penelope', 'age': 1 }\n     */\n    function memoize(func, resolver) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var memoized = function() {\n        var cache = memoized.cache,\n            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];\n\n        return hasOwnProperty.call(cache, key)\n          ? cache[key]\n          : (cache[key] = func.apply(this, arguments));\n      }\n      memoized.cache = {};\n      return memoized;\n    }\n\n    /**\n     * Creates a function that is restricted to execute `func` once. Repeat calls to\n     * the function will return the value of the first call. The `func` is executed\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` executes `createApplication` once\n     */\n    function once(func) {\n      var ran,\n          result;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (ran) {\n          return result;\n        }\n        ran = true;\n        result = func.apply(this, arguments);\n\n        // clear the `func` variable so the function may be garbage collected\n        func = null;\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with any additional\n     * `partial` arguments prepended to those provided to the new function. This\n     * method is similar to `_.bind` except it does **not** alter the `this` binding.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) { return greeting + ' ' + name; };\n     * var hi = _.partial(greet, 'hi');\n     * hi('fred');\n     * // => 'hi fred'\n     */\n    function partial(func) {\n      return createWrapper(func, 16, slice(arguments, 1));\n    }\n\n    /**\n     * This method is like `_.partial` except that `partial` arguments are\n     * appended to those provided to the new function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var defaultsDeep = _.partialRight(_.merge, _.defaults);\n     *\n     * var options = {\n     *   'variable': 'data',\n     *   'imports': { 'jq': $ }\n     * };\n     *\n     * defaultsDeep(options, _.templateSettings);\n     *\n     * options.variable\n     * // => 'data'\n     *\n     * options.imports\n     * // => { '_': _, 'jq': $ }\n     */\n    function partialRight(func) {\n      return createWrapper(func, 32, null, slice(arguments, 1));\n    }\n\n    /**\n     * Creates a function that, when executed, will only call the `func` function\n     * at most once per every `wait` milliseconds. Provide an options object to\n     * indicate that `func` should be invoked on the leading and/or trailing edge\n     * of the `wait` timeout. Subsequent calls to the throttled function will\n     * return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to throttle.\n     * @param {number} wait The number of milliseconds to throttle executions to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * var throttled = _.throttle(updatePosition, 100);\n     * jQuery(window).on('scroll', throttled);\n     *\n     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? options.leading : leading;\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      debounceOptions.leading = leading;\n      debounceOptions.maxWait = wait;\n      debounceOptions.trailing = trailing;\n\n      return debounce(func, wait, debounceOptions);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Additional arguments provided to the function are appended\n     * to those provided to the wrapper function. The wrapper is executed with\n     * the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('Fred, Wilma, & Pebbles');\n     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return createWrapper(wrapper, 16, [value]);\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var getter = _.constant(object);\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Produces a callback bound to an optional `thisArg`. If `func` is a property\n     * name the created callback will return the property value for a given element.\n     * If `func` is an object the created callback will return `true` for elements\n     * that contain the equivalent object properties, otherwise it will return `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);\n     *   return !match ? func(callback, thisArg) : function(object) {\n     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(characters, 'age__gt38');\n     * // => [{ 'name': 'fred', 'age': 40 }]\n     */\n    function createCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (func == null || type == 'function') {\n        return baseCreateCallback(func, thisArg, argCount);\n      }\n      // handle \"_.pluck\" style callback shorthands\n      if (type != 'object') {\n        return property(func);\n      }\n      var props = keys(func),\n          key = props[0],\n          a = func[key];\n\n      // handle \"_.where\" style callback shorthands\n      if (props.length == 1 && a === a && !isObject(a)) {\n        // fast path the common case of providing an object with a single\n        // property containing a primitive value\n        return function(object) {\n          var b = object[key];\n          return a === b && (a !== 0 || (1 / a == 1 / b));\n        };\n      }\n      return function(object) {\n        var length = props.length,\n            result = false;\n\n        while (length--) {\n          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {\n            break;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Converts the characters `&`, `<`, `>`, `\"`, and `'` in `string` to their\n     * corresponding HTML entities.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('Fred, Wilma, & Pebbles');\n     * // => 'Fred, Wilma, &amp; Pebbles'\n     */\n    function escape(string) {\n      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Adds function properties of a source object to the destination object.\n     * If `object` is a function methods will be added to its prototype as well.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Function|Object} [object=lodash] object The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.\n     * @example\n     *\n     * function capitalize(string) {\n     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n     * }\n     *\n     * _.mixin({ 'capitalize': capitalize });\n     * _.capitalize('fred');\n     * // => 'Fred'\n     *\n     * _('fred').capitalize().value();\n     * // => 'Fred'\n     *\n     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });\n     * _('fred').capitalize();\n     * // => 'Fred'\n     */\n    function mixin(object, source, options) {\n      var chain = true,\n          methodNames = source && functions(source);\n\n      if (!source || (!options && !methodNames.length)) {\n        if (options == null) {\n          options = source;\n        }\n        ctor = lodashWrapper;\n        source = object;\n        object = lodash;\n        methodNames = functions(source);\n      }\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      var ctor = object,\n          isFunc = isFunction(ctor);\n\n      forEach(methodNames, function(methodName) {\n        var func = object[methodName] = source[methodName];\n        if (isFunc) {\n          ctor.prototype[methodName] = function() {\n            var chainAll = this.__chain__,\n                value = this.__wrapped__,\n                args = [value];\n\n            push.apply(args, arguments);\n            var result = func.apply(object, args);\n            if (chain || chainAll) {\n              if (value === result && isObject(result)) {\n                return this;\n              }\n              result = new ctor(result);\n              result.__chain__ = chainAll;\n            }\n            return result;\n          };\n        }\n      });\n    }\n\n    /**\n     * Reverts the '_' variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      context._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // no operation performed\n    }\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var stamp = _.now();\n     * _.defer(function() { console.log(_.now() - stamp); });\n     * // => logs the number of milliseconds it took for the deferred function to be called\n     */\n    var now = isNative(now = Date.now) && now || function() {\n      return new Date().getTime();\n    };\n\n    /**\n     * Converts the given value into an integer of the specified radix.\n     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the\n     * `value` is a hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * Note: This method avoids differences in native ES3 and ES5 `parseInt`\n     * implementations. See http://es5.github.io/#E.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} value The value to parse.\n     * @param {number} [radix] The radix used to interpret the value to parse.\n     * @returns {number} Returns the new integer value.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     */\n    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {\n      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`\n      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);\n    };\n\n    /**\n     * Creates a \"_.pluck\" style function, which returns the `key` value of a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} key The name of the property to retrieve.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'fred',   'age': 40 },\n     *   { 'name': 'barney', 'age': 36 }\n     * ];\n     *\n     * var getName = _.property('name');\n     *\n     * _.map(characters, getName);\n     * // => ['barney', 'fred']\n     *\n     * _.sortBy(characters, getName);\n     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]\n     */\n    function property(key) {\n      return function(object) {\n        return object[key];\n      };\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number will be\n     * returned. If `floating` is truey or either `min` or `max` are floats a\n     * floating-point number will be returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating=false] Specify returning a floating-point number.\n     * @returns {number} Returns a random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (typeof min == 'boolean' && noMax) {\n          floating = min;\n          min = 1;\n        }\n        else if (!noMax && typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /**\n     * Resolves the value of property `key` on `object`. If `key` is a function\n     * it will be invoked with the `this` binding of `object` and its result returned,\n     * else the property value is returned. If `object` is falsey then `undefined`\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to resolve.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = {\n     *   'cheese': 'crumpets',\n     *   'stuff': function() {\n     *     return 'nonsense';\n     *   }\n     * };\n     *\n     * _.result(object, 'cheese');\n     * // => 'crumpets'\n     *\n     * _.result(object, 'stuff');\n     * // => 'nonsense'\n     */\n    function result(object, key) {\n      if (object) {\n        var value = object[key];\n        return isFunction(value) ? object[key]() : value;\n      }\n    }\n\n    /**\n     * A micro-templating method that handles arbitrary delimiters, preserves\n     * whitespace, and correctly escapes quotes within interpolated code.\n     *\n     * Note: In the development build, `_.template` utilizes sourceURLs for easier\n     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n     *\n     * For more information on precompiling templates see:\n     * https://lodash.com/custom-builds\n     *\n     * For more information on Chrome extension sandboxes see:\n     * http://developer.chrome.com/stable/extensions/sandboxingEval.html\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} text The template text.\n     * @param {Object} data The data object used to populate the text.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as local variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [variable] The data object variable name.\n     * @returns {Function|string} Returns a compiled function when no `data` object\n     *  is given, else it returns the interpolated text.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= name %>');\n     * compiled({ 'name': 'fred' });\n     * // => 'hello fred'\n     *\n     * // using the \"escape\" delimiter to escape HTML in data property values\n     * _.template('<b><%- value %></b>', { 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to generate HTML\n     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the ES6 delimiter as an alternative to the default \"interpolate\" delimiter\n     * _.template('hello ${ name }', { 'name': 'pebbles' });\n     * // => 'hello pebbles'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * _.template('<% print(\"hello \" + name); %>!', { 'name': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using a custom template delimiters\n     * _.templateSettings = {\n     *   'interpolate': /{{([\\s\\S]+?)}}/g\n     * };\n     *\n     * _.template('hello {{ name }}!', { 'name': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using the `imports` option to import jQuery\n     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     *   var __t, __p = '', __e = _.escape;\n     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';\n     *   return __p;\n     * }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(text, data, options) {\n      // based on John Resig's `tmpl` implementation\n      // http://ejohn.org/blog/javascript-micro-templating/\n      // and Laura Doktorova's doT.js\n      // https://github.com/olado/doT\n      var settings = lodash.templateSettings;\n      text = String(text || '');\n\n      // avoid missing dependencies when `iteratorTemplate` is not defined\n      options = defaults({}, options, settings);\n\n      var imports = defaults({}, options.imports, settings.imports),\n          importsKeys = keys(imports),\n          importsValues = values(imports);\n\n      var isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // compile the regexp to match each delimiter\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // escape characters that cannot be included in string literals\n        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // replace delimiters with snippets\n        if (escapeValue) {\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // the JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // if `variable` is not specified, wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain\n      var variable = options.variable,\n          hasVariable = variable;\n\n      if (!hasVariable) {\n        variable = 'obj';\n        source = 'with (' + variable + ') {\\n' + source + '\\n}\\n';\n      }\n      // cleanup code by stripping empty strings\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // frame code as the function body\n      source = 'function(' + variable + ') {\\n' +\n        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\\n') +\n        \"var __t, __p = '', __e = _.escape\" +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      // Use a sourceURL for easier debugging.\n      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n      var sourceURL = '\\n/*\\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\\n*/';\n\n      try {\n        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);\n      } catch(e) {\n        e.source = source;\n        throw e;\n      }\n      if (data) {\n        return result(data);\n      }\n      // provide the compiled function's source by its `toString` method, in\n      // supported environments, or the `source` property as a convenience for\n      // inlining compiled templates during the build process\n      result.source = source;\n      return result;\n    }\n\n    /**\n     * Executes the callback `n` times, returning an array of the results\n     * of each callback execution. The callback is bound to `thisArg` and invoked\n     * with one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} n The number of times to execute the callback.\n     * @param {Function} callback The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns an array of the results of each `callback` execution.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) { mage.castSpell(n); });\n     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively\n     *\n     * _.times(3, function(n) { this.cast(n); }, mage);\n     * // => also calls `mage.castSpell(n)` three times\n     */\n    function times(n, callback, thisArg) {\n      n = (n = +n) > -1 ? n : 0;\n      var index = -1,\n          result = Array(n);\n\n      callback = baseCreateCallback(callback, thisArg, 1);\n      while (++index < n) {\n        result[index] = callback(index);\n      }\n      return result;\n    }\n\n    /**\n     * The inverse of `_.escape` this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their\n     * corresponding characters.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('Fred, Barney &amp; Pebbles');\n     * // => 'Fred, Barney & Pebbles'\n     */\n    function unescape(string) {\n      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return String(prefix == null ? '' : prefix) + id;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps the given value with explicit\n     * method chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(characters)\n     *     .sortBy('age')\n     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })\n     *     .first()\n     *     .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      value = new lodashWrapper(value);\n      value.__chain__ = true;\n      return value;\n    }\n\n    /**\n     * Invokes `interceptor` with the `value` as the first argument and then\n     * returns `value`. The purpose of this method is to \"tap into\" a method\n     * chain in order to perform operations on intermediate results within\n     * the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3, 4])\n     *  .tap(function(array) { array.pop(); })\n     *  .reverse()\n     *  .value();\n     * // => [3, 2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chaining\n     * @returns {*} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(characters).first();\n     * // => { 'name': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(characters).chain()\n     *   .first()\n     *   .pick('age')\n     *   .value();\n     * // => { 'age': 36 }\n     */\n    function wrapperChain() {\n      this.__chain__ = true;\n      return this;\n    }\n\n    /**\n     * Produces the `toString` result of the wrapped value.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chaining\n     * @returns {string} Returns the string result.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return String(this.__wrapped__);\n    }\n\n    /**\n     * Extracts the wrapped value.\n     *\n     * @name valueOf\n     * @memberOf _\n     * @alias value\n     * @category Chaining\n     * @returns {*} Returns the wrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).valueOf();\n     * // => [1, 2, 3]\n     */\n    function wrapperValueOf() {\n      return this.__wrapped__;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return wrapped values when chaining\n    lodash.after = after;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.chain = chain;\n    lodash.compact = compact;\n    lodash.compose = compose;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.createCallback = createCallback;\n    lodash.curry = curry;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.map = map;\n    lodash.mapValues = mapValues;\n    lodash.max = max;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.min = min;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.pull = pull;\n    lodash.range = range;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.shuffle = shuffle;\n    lodash.sortBy = sortBy;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.values = values;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n\n    // add aliases\n    lodash.collect = map;\n    lodash.drop = rest;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n    lodash.unzip = zip;\n\n    // add functions to `lodash.prototype`\n    mixin(lodash);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return unwrapped values when chaining\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.contains = contains;\n    lodash.escape = escape;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.indexOf = indexOf;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isNaN = isNaN;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isUndefined = isUndefined;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.mixin = mixin;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.result = result;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.template = template;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n\n    // add aliases\n    lodash.all = every;\n    lodash.any = some;\n    lodash.detect = find;\n    lodash.findWhere = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.include = contains;\n    lodash.inject = reduce;\n\n    mixin(function() {\n      var source = {}\n      forOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }(), false);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions capable of returning wrapped and unwrapped values when chaining\n    lodash.first = first;\n    lodash.last = last;\n    lodash.sample = sample;\n\n    // add aliases\n    lodash.take = first;\n    lodash.head = first;\n\n    forOwn(lodash, function(func, methodName) {\n      var callbackable = methodName !== 'sample';\n      if (!lodash.prototype[methodName]) {\n        lodash.prototype[methodName]= function(n, guard) {\n          var chainAll = this.__chain__,\n              result = func(this.__wrapped__, n, guard);\n\n          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))\n            ? result\n            : new lodashWrapper(result, chainAll);\n        };\n      }\n    });\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = '2.4.2';\n\n    // add \"Chaining\" functions to the wrapper\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.value = wrapperValueOf;\n    lodash.prototype.valueOf = wrapperValueOf;\n\n    // add `Array` functions that return unwrapped values\n    forEach(['join', 'pop', 'shift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        var chainAll = this.__chain__,\n            result = func.apply(this.__wrapped__, arguments);\n\n        return chainAll\n          ? new lodashWrapper(result, chainAll)\n          : result;\n      };\n    });\n\n    // add `Array` functions that return the existing wrapped value\n    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        func.apply(this.__wrapped__, arguments);\n        return this;\n      };\n    });\n\n    // add `Array` functions that return new wrapped values\n    forEach(['concat', 'slice', 'splice'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);\n      };\n    });\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // expose Lo-Dash\n  var _ = runInContext();\n\n  // some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lo-Dash to the global object even when an AMD loader is present in\n    // case Lo-Dash is loaded with a RequireJS shim config.\n    // See http://requirejs.org/docs/api.html#config-shim\n    root._ = _;\n\n    // define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module\n    define(function() {\n      return _;\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // in Narwhal or Rhino -require\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // in a browser or Rhino\n    root._ = _;\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/index.js":"var root = require('./root')\nmodule.exports = {\n  fetchPlugins: require('./fetch_plugins')(root),\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/root.js":"/* When editing ecosystem or client you can clone it and run\n * python -m SimpleHTTPServer\n * and use this export instead: */\n//module.exports = 'http://localhost:8000'\nmodule.exports = 'https://raw.githubusercontent.com/Strider-CD/ecosystem-index/master'\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/fetch_plugins.js":"var Promise = require('bluebird')\nvar get = require('./get')\nvar yaml = require('js-yaml')\n\nmodule.exports = function(root) {\n  var url = root+'/plugins.yml'\n  return function() {\n    return new Promise(function(resolve, reject){\n      get(url, function(err, res, body) {\n        if (err) reject(err);\n        resolve(yaml.load(body));\n      });\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/bluebird.js":"\"use strict\";\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict() {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nvar bluebird = require(\"./promise.js\")();\nbluebird.noConflict = noConflict;\nmodule.exports = bluebird;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/promise.js":"\"use strict\";\nmodule.exports = function() {\nvar makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/LhFpo0\\u000a\");\n};\nvar reflect = function() {\n    return new Promise.PromiseInspection(this._target());\n};\nvar apiRejection = function(msg) {\n    return Promise.reject(new TypeError(msg));\n};\n\nvar util = require(\"./util.js\");\n\nvar getDomain;\nif (util.isNode) {\n    getDomain = function() {\n        var ret = process.domain;\n        if (ret === undefined) ret = null;\n        return ret;\n    };\n} else {\n    getDomain = function() {\n        return null;\n    };\n}\nutil.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n\nvar UNDEFINED_BINDING = {};\nvar async = require(\"./async.js\");\nvar errors = require(\"./errors.js\");\nvar TypeError = Promise.TypeError = errors.TypeError;\nPromise.RangeError = errors.RangeError;\nPromise.CancellationError = errors.CancellationError;\nPromise.TimeoutError = errors.TimeoutError;\nPromise.OperationalError = errors.OperationalError;\nPromise.RejectionError = errors.OperationalError;\nPromise.AggregateError = errors.AggregateError;\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {e: null};\nvar tryConvertToPromise = require(\"./thenables.js\")(Promise, INTERNAL);\nvar PromiseArray =\n    require(\"./promise_array.js\")(Promise, INTERNAL,\n                                    tryConvertToPromise, apiRejection);\nvar CapturedTrace = require(\"./captured_trace.js\")();\nvar isDebugging = require(\"./debuggability.js\")(Promise, CapturedTrace);\n /*jshint unused:false*/\nvar createContext =\n    require(\"./context.js\")(Promise, CapturedTrace, isDebugging);\nvar CatchFilter = require(\"./catch_filter.js\")(NEXT_FILTER);\nvar PromiseResolver = require(\"./promise_resolver.js\");\nvar nodebackForPromise = PromiseResolver._nodebackForPromise;\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\n\nfunction Promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"the promise constructor requires a resolver function\\u000a\\u000a    See http://goo.gl/EC22Yn\\u000a\");\n    }\n    if (this.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/KsIlge\\u000a\");\n    }\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._progressHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settledValue = undefined;\n    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (typeof item === \"function\") {\n                catchInstances[j++] = item;\n            } else {\n                return Promise.reject(\n                    new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\"));\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n        var catchFilter = new CatchFilter(catchInstances, fn, this);\n        return this._then(undefined, catchFilter.doFilter, undefined,\n            catchFilter, undefined);\n    }\n    return this._then(undefined, fn, undefined, undefined, undefined);\n};\n\nPromise.prototype.reflect = function () {\n    return this._then(reflect, reflect, undefined, this, undefined);\n};\n\nPromise.prototype.then = function (didFulfill, didReject, didProgress) {\n    if (isDebugging() && arguments.length > 0 &&\n        typeof didFulfill !== \"function\" &&\n        typeof didReject !== \"function\") {\n        var msg = \".then() only accepts functions but was passed: \" +\n                util.classString(didFulfill);\n        if (arguments.length > 1) {\n            msg += \", \" + util.classString(didReject);\n        }\n        this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, didProgress,\n        undefined, undefined);\n};\n\nPromise.prototype.done = function (didFulfill, didReject, didProgress) {\n    var promise = this._then(didFulfill, didReject, didProgress,\n        undefined, undefined);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function (didFulfill, didReject) {\n    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);\n};\n\nPromise.prototype.isCancellable = function () {\n    return !this.isResolved() &&\n        this._cancellable();\n};\n\nPromise.prototype.toJSON = function () {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: undefined,\n        rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this.value();\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this.reason();\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function () {\n    return new PromiseArray(this).promise();\n};\n\nPromise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n};\n\nPromise.getNewLibraryCopy = module.exports;\n\nPromise.is = function (val) {\n    return val instanceof Promise;\n};\n\nPromise.fromNode = function(fn) {\n    var ret = new Promise(INTERNAL);\n    var result = tryCatch(fn)(nodebackForPromise(ret));\n    if (result === errorObj) {\n        ret._rejectCallback(result.e, true, true);\n    }\n    return ret;\n};\n\nPromise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.defer = Promise.pending = function () {\n    var promise = new Promise(INTERNAL);\n    return new PromiseResolver(promise);\n};\n\nPromise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n        var val = ret;\n        ret = new Promise(INTERNAL);\n        ret._fulfillUnchecked(val);\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    var prev = async._schedule;\n    async._schedule = fn;\n    return prev;\n};\n\nPromise.prototype._then = function (\n    didFulfill,\n    didReject,\n    didProgress,\n    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== undefined;\n    var ret = haveInternalData ? internalData : new Promise(INTERNAL);\n\n    if (!haveInternalData) {\n        ret._propagateFrom(this, 4 | 1);\n        ret._captureStackTrace();\n    }\n\n    var target = this._target();\n    if (target !== this) {\n        if (receiver === undefined) receiver = this._boundTo;\n        if (!haveInternalData) ret._setIsMigrated();\n    }\n\n    var callbackIndex = target._addCallbacks(didFulfill,\n                                             didReject,\n                                             didProgress,\n                                             ret,\n                                             receiver,\n                                             getDomain());\n\n    if (target._isResolved() && !target._isSettlePromisesQueued()) {\n        async.invoke(\n            target._settlePromiseAtPostResolution, target, callbackIndex);\n    }\n\n    return ret;\n};\n\nPromise.prototype._settlePromiseAtPostResolution = function (index) {\n    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();\n    this._settlePromiseAt(index);\n};\n\nPromise.prototype._length = function () {\n    return this._bitField & 131071;\n};\n\nPromise.prototype._isFollowingOrFulfilledOrRejected = function () {\n    return (this._bitField & 939524096) > 0;\n};\n\nPromise.prototype._isFollowing = function () {\n    return (this._bitField & 536870912) === 536870912;\n};\n\nPromise.prototype._setLength = function (len) {\n    this._bitField = (this._bitField & -131072) |\n        (len & 131071);\n};\n\nPromise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 134217728;\n};\n\nPromise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 536870912;\n};\n\nPromise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 33554432;\n};\n\nPromise.prototype._isFinal = function () {\n    return (this._bitField & 33554432) > 0;\n};\n\nPromise.prototype._cancellable = function () {\n    return (this._bitField & 67108864) > 0;\n};\n\nPromise.prototype._setCancellable = function () {\n    this._bitField = this._bitField | 67108864;\n};\n\nPromise.prototype._unsetCancellable = function () {\n    this._bitField = this._bitField & (~67108864);\n};\n\nPromise.prototype._setIsMigrated = function () {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._unsetIsMigrated = function () {\n    this._bitField = this._bitField & (~4194304);\n};\n\nPromise.prototype._isMigrated = function () {\n    return (this._bitField & 4194304) > 0;\n};\n\nPromise.prototype._receiverAt = function (index) {\n    var ret = index === 0\n        ? this._receiver0\n        : this[\n            index * 5 - 5 + 4];\n    if (ret === UNDEFINED_BINDING) {\n        return undefined;\n    } else if (ret === undefined && this._isBound()) {\n        return this._boundValue();\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function (index) {\n    return index === 0\n        ? this._promise0\n        : this[index * 5 - 5 + 3];\n};\n\nPromise.prototype._fulfillmentHandlerAt = function (index) {\n    return index === 0\n        ? this._fulfillmentHandler0\n        : this[index * 5 - 5 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt = function (index) {\n    return index === 0\n        ? this._rejectionHandler0\n        : this[index * 5 - 5 + 1];\n};\n\nPromise.prototype._boundValue = function() {\n    var ret = this._boundTo;\n    if (ret !== undefined) {\n        if (ret instanceof Promise) {\n            if (ret.isFulfilled()) {\n                return ret.value();\n            } else {\n                return undefined;\n            }\n        }\n    }\n    return ret;\n};\n\nPromise.prototype._migrateCallbacks = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var progress = follower._progressHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (promise instanceof Promise) promise._setIsMigrated();\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);\n};\n\nPromise.prototype._addCallbacks = function (\n    fulfill,\n    reject,\n    progress,\n    promise,\n    receiver,\n    domain\n) {\n    var index = this._length();\n\n    if (index >= 131071 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        if (receiver !== undefined) this._receiver0 = receiver;\n        if (typeof fulfill === \"function\" && !this._isCarryingStackTrace()) {\n            this._fulfillmentHandler0 =\n                domain === null ? fulfill : domain.bind(fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this._rejectionHandler0 =\n                domain === null ? reject : domain.bind(reject);\n        }\n        if (typeof progress === \"function\") {\n            this._progressHandler0 =\n                domain === null ? progress : domain.bind(progress);\n        }\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] = promise;\n        this[base + 4] = receiver;\n        if (typeof fulfill === \"function\") {\n            this[base + 0] =\n                domain === null ? fulfill : domain.bind(fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this[base + 1] =\n                domain === null ? reject : domain.bind(reject);\n        }\n        if (typeof progress === \"function\") {\n            this[base + 2] =\n                domain === null ? progress : domain.bind(progress);\n        }\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {\n    var index = this._length();\n\n    if (index >= 131071 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n    if (index === 0) {\n        this._promise0 = promiseSlotValue;\n        this._receiver0 = receiver;\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] = promiseSlotValue;\n        this[base + 4] = receiver;\n    }\n    this._setLength(index + 1);\n};\n\nPromise.prototype._proxyPromiseArray = function (promiseArray, index) {\n    this._setProxyHandlers(promiseArray, index);\n};\n\nPromise.prototype._resolveCallback = function(value, shouldBind) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    if (value === this)\n        return this._rejectCallback(makeSelfResolutionError(), false, true);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n    var propagationFlags = 1 | (shouldBind ? 4 : 0);\n    this._propagateFrom(maybePromise, propagationFlags);\n    var promise = maybePromise._target();\n    if (promise._isPending()) {\n        var len = this._length();\n        for (var i = 0; i < len; ++i) {\n            promise._migrateCallbacks(this, i);\n        }\n        this._setFollowing();\n        this._setLength(0);\n        this._setFollowee(promise);\n    } else if (promise._isFulfilled()) {\n        this._fulfillUnchecked(promise._value());\n    } else {\n        this._rejectUnchecked(promise._reason(),\n            promise._getCarriedStackTrace());\n    }\n};\n\nPromise.prototype._rejectCallback =\nfunction(reason, synchronous, shouldNotMarkOriginatingFromRejection) {\n    if (!shouldNotMarkOriginatingFromRejection) {\n        util.markAsOriginatingFromRejection(reason);\n    }\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason, hasStack ? undefined : trace);\n};\n\nPromise.prototype._resolveFromResolver = function (resolver) {\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = tryCatch(resolver)(function(value) {\n        if (promise === null) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }, function (reason) {\n        if (promise === null) return;\n        promise._rejectCallback(reason, synchronous);\n        promise = null;\n    });\n    synchronous = false;\n    this._popContext();\n\n    if (r !== undefined && r === errorObj && promise !== null) {\n        promise._rejectCallback(r.e, true, true);\n        promise = null;\n    }\n};\n\nPromise.prototype._settlePromiseFromHandler = function (\n    handler, receiver, value, promise\n) {\n    if (promise._isRejected()) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY && !this._isRejected()) {\n        x = tryCatch(handler).apply(this._boundValue(), value);\n    } else {\n        x = tryCatch(handler).call(receiver, value);\n    }\n    promise._popContext();\n\n    if (x === errorObj || x === promise || x === NEXT_FILTER) {\n        var err = x === promise ? makeSelfResolutionError() : x.e;\n        promise._rejectCallback(err, false, true);\n    } else {\n        promise._resolveCallback(x);\n    }\n};\n\nPromise.prototype._target = function() {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n};\n\nPromise.prototype._followee = function() {\n    return this._rejectionHandler0;\n};\n\nPromise.prototype._setFollowee = function(promise) {\n    this._rejectionHandler0 = promise;\n};\n\nPromise.prototype._cleanValues = function () {\n    if (this._cancellable()) {\n        this._cancellationParent = undefined;\n    }\n};\n\nPromise.prototype._propagateFrom = function (parent, flags) {\n    if ((flags & 1) > 0 && parent._cancellable()) {\n        this._setCancellable();\n        this._cancellationParent = parent;\n    }\n    if ((flags & 4) > 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n};\n\nPromise.prototype._fulfill = function (value) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._fulfillUnchecked(value);\n};\n\nPromise.prototype._reject = function (reason, carriedStackTrace) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._rejectUnchecked(reason, carriedStackTrace);\n};\n\nPromise.prototype._settlePromiseAt = function (index) {\n    var promise = this._promiseAt(index);\n    var isPromise = promise instanceof Promise;\n\n    if (isPromise && promise._isMigrated()) {\n        promise._unsetIsMigrated();\n        return async.invoke(this._settlePromiseAt, this, index);\n    }\n    var handler = this._isFulfilled()\n        ? this._fulfillmentHandlerAt(index)\n        : this._rejectionHandlerAt(index);\n\n    var carriedStackTrace =\n        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;\n    var value = this._settledValue;\n    var receiver = this._receiverAt(index);\n    this._clearCallbackDataAtIndex(index);\n\n    if (typeof handler === \"function\") {\n        if (!isPromise) {\n            handler.call(receiver, value, promise);\n        } else {\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (receiver instanceof PromiseArray) {\n        if (!receiver._isResolved()) {\n            if (this._isFulfilled()) {\n                receiver._promiseFulfilled(value, promise);\n            }\n            else {\n                receiver._promiseRejected(value, promise);\n            }\n        }\n    } else if (isPromise) {\n        if (this._isFulfilled()) {\n            promise._fulfill(value);\n        } else {\n            promise._reject(value, carriedStackTrace);\n        }\n    }\n\n    if (index >= 4 && (index & 31) === 4)\n        async.invokeLater(this._setLength, this, 0);\n};\n\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\n    if (index === 0) {\n        if (!this._isCarryingStackTrace()) {\n            this._fulfillmentHandler0 = undefined;\n        }\n        this._rejectionHandler0 =\n        this._progressHandler0 =\n        this._receiver0 =\n        this._promise0 = undefined;\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] =\n        this[base + 4] =\n        this[base + 0] =\n        this[base + 1] =\n        this[base + 2] = undefined;\n    }\n};\n\nPromise.prototype._isSettlePromisesQueued = function () {\n    return (this._bitField &\n            -1073741824) === -1073741824;\n};\n\nPromise.prototype._setSettlePromisesQueued = function () {\n    this._bitField = this._bitField | -1073741824;\n};\n\nPromise.prototype._unsetSettlePromisesQueued = function () {\n    this._bitField = this._bitField & (~-1073741824);\n};\n\nPromise.prototype._queueSettlePromises = function() {\n    async.settlePromises(this);\n    this._setSettlePromisesQueued();\n};\n\nPromise.prototype._fulfillUnchecked = function (value) {\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err, undefined);\n    }\n    this._setFulfilled();\n    this._settledValue = value;\n    this._cleanValues();\n\n    if (this._length() > 0) {\n        this._queueSettlePromises();\n    }\n};\n\nPromise.prototype._rejectUncheckedCheckError = function (reason) {\n    var trace = util.ensureErrorObject(reason);\n    this._rejectUnchecked(reason, trace === reason ? undefined : trace);\n};\n\nPromise.prototype._rejectUnchecked = function (reason, trace) {\n    if (reason === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err);\n    }\n    this._setRejected();\n    this._settledValue = reason;\n    this._cleanValues();\n\n    if (this._isFinal()) {\n        async.throwLater(function(e) {\n            if (\"stack\" in e) {\n                async.invokeFirst(\n                    CapturedTrace.unhandledRejection, undefined, e);\n            }\n            throw e;\n        }, trace === undefined ? reason : trace);\n        return;\n    }\n\n    if (trace !== undefined && trace !== reason) {\n        this._setCarriedStackTrace(trace);\n    }\n\n    if (this._length() > 0) {\n        this._queueSettlePromises();\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._settlePromises = function () {\n    this._unsetSettlePromisesQueued();\n    var len = this._length();\n    for (var i = 0; i < len; i++) {\n        this._settlePromiseAt(i);\n    }\n};\n\n\nutil.notEnumerableProp(Promise,\n                       \"_makeSelfResolutionError\",\n                       makeSelfResolutionError);\n\nrequire(\"./progress.js\")(Promise, PromiseArray);\nrequire(\"./method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\nrequire(\"./bind.js\")(Promise, INTERNAL, tryConvertToPromise);\nrequire(\"./finally.js\")(Promise, NEXT_FILTER, tryConvertToPromise);\nrequire(\"./direct_resolve.js\")(Promise);\nrequire(\"./synchronous_inspection.js\")(Promise);\nrequire(\"./join.js\")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);\nPromise.version = \"2.11.0\";\nPromise.Promise = Promise;\nrequire('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\nrequire('./cancel.js')(Promise);\nrequire('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);\nrequire('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);\nrequire('./nodeify.js')(Promise);\nrequire('./call_get.js')(Promise);\nrequire('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\nrequire('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\nrequire('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\nrequire('./settle.js')(Promise, PromiseArray);\nrequire('./some.js')(Promise, PromiseArray, apiRejection);\nrequire('./promisify.js')(Promise, INTERNAL);\nrequire('./any.js')(Promise);\nrequire('./each.js')(Promise, INTERNAL);\nrequire('./timers.js')(Promise, INTERNAL);\nrequire('./filter.js')(Promise, INTERNAL);\n                                                         \n    util.toFastProperties(Promise);                                          \n    util.toFastProperties(Promise.prototype);                                \n    function fillTypes(value) {                                              \n        var p = new Promise(INTERNAL);                                       \n        p._fulfillmentHandler0 = value;                                      \n        p._rejectionHandler0 = value;                                        \n        p._progressHandler0 = value;                                         \n        p._promise0 = value;                                                 \n        p._receiver0 = value;                                                \n        p._settledValue = value;                                             \n    }                                                                        \n    // Complete slack tracking, opt out of field-type tracking and           \n    // stabilize map                                                         \n    fillTypes({a: 1});                                                       \n    fillTypes({b: 2});                                                       \n    fillTypes({c: 3});                                                       \n    fillTypes(1);                                                            \n    fillTypes(function(){});                                                 \n    fillTypes(undefined);                                                    \n    fillTypes(false);                                                        \n    fillTypes(new Promise(INTERNAL));                                        \n    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       \n    return Promise;                                                          \n\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/util.js":"\"use strict\";\nvar es5 = require(\"./es5.js\");\nvar canEvaluate = typeof navigator == \"undefined\";\nvar haveGetters = (function(){\n    try {\n        var o = {};\n        es5.defineProperty(o, \"f\", {\n            get: function () {\n                return 3;\n            }\n        });\n        return o.f === 3;\n    }\n    catch (e) {\n        return false;\n    }\n\n})();\n\nvar errorObj = {e: {}};\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        var target = tryCatchTarget;\n        tryCatchTarget = null;\n        return target.apply(this, arguments);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return !isPrimitive(value);\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(safeToString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    var excludedPrototypes = [\n        Array.prototype,\n        Object.prototype,\n        Function.prototype\n    ];\n\n    var isExcludedProto = function(val) {\n        for (var i = 0; i < excludedPrototypes.length; ++i) {\n            if (excludedPrototypes[i] === val) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (es5.isES5) {\n        var getKeys = Object.getOwnPropertyNames;\n        return function(obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            while (obj != null && !isExcludedProto(obj)) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        var hasProp = {}.hasOwnProperty;\n        return function(obj) {\n            if (isExcludedProto(obj)) return [];\n            var ret = [];\n\n            /*jshint forin:false */\n            enumeration: for (var key in obj) {\n                if (hasProp.call(obj, key)) {\n                    ret.push(key);\n                } else {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (hasProp.call(excludedPrototypes[i], key)) {\n                            continue enumeration;\n                        }\n                    }\n                    ret.push(key);\n                }\n            }\n            return ret;\n        };\n    }\n\n})();\n\nvar thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n\n            var hasMethods = es5.isES5 && keys.length > 1;\n            var hasMethodsOtherThanConstructor = keys.length > 0 &&\n                !(keys.length === 1 && keys[0] === \"constructor\");\n            var hasThisAssignmentAndStaticMethods =\n                thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n            if (hasMethods || hasMethodsOtherThanConstructor ||\n                hasThisAssignmentAndStaticMethods) {\n                return true;\n            }\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027,-W055,-W031*/\n    function f() {}\n    f.prototype = obj;\n    var l = 8;\n    while (l--) new f();\n    return obj;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nfunction safeToString(obj) {\n    try {\n        return obj + \"\";\n    } catch (e) {\n        return \"[no string representation]\";\n    }\n}\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction canAttachTrace(obj) {\n    return obj instanceof Error && es5.propertyIsWritable(obj, \"stack\");\n}\n\nvar ensureErrorObject = (function() {\n    if (!(\"stack\" in new Error())) {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            try {throw new Error(safeToString(value));}\n            catch(err) {return err;}\n        };\n    } else {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n        };\n    }\n})();\n\nfunction classString(obj) {\n    return {}.toString.call(obj);\n}\n\nfunction copyDescriptors(from, to, filter) {\n    var keys = es5.names(from);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        if (filter(key)) {\n            try {\n                es5.defineProperty(to, key, es5.getDescriptor(from, key));\n            } catch (ignore) {}\n        }\n    }\n}\n\nvar ret = {\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    haveGetters: haveGetters,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch: tryCatch,\n    inherits: inherits,\n    withAppended: withAppended,\n    maybeWrapAsError: maybeWrapAsError,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange,\n    toString: safeToString,\n    canAttachTrace: canAttachTrace,\n    ensureErrorObject: ensureErrorObject,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    classString: classString,\n    copyDescriptors: copyDescriptors,\n    hasDevTools: typeof chrome !== \"undefined\" && chrome &&\n                 typeof chrome.loadTimes === \"function\",\n    isNode: typeof process !== \"undefined\" &&\n        classString(process).toLowerCase() === \"[object process]\"\n};\nret.isRecentNode = ret.isNode && (function() {\n    var version = process.versions.node.split(\".\").map(Number);\n    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);\n})();\n\nif (ret.isNode) ret.toFastProperties(process);\n\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\nmodule.exports = ret;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/es5.js":"var isES5 = (function(){\n    \"use strict\";\n    return this === undefined;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        getDescriptor: Object.getOwnPropertyDescriptor,\n        keys: Object.keys,\n        names: Object.getOwnPropertyNames,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5,\n        propertyIsWritable: function(obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n        }\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function (o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    };\n\n    var ObjectGetDescriptor = function(o, key) {\n        return {value: o[key]};\n    };\n\n    var ObjectDefineProperty = function (o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    };\n\n    var ObjectFreeze = function (obj) {\n        return obj;\n    };\n\n    var ObjectGetPrototypeOf = function (obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    };\n\n    var ArrayIsArray = function (obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    };\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        names: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        getDescriptor: ObjectGetDescriptor,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5,\n        propertyIsWritable: function() {\n            return true;\n        }\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/async.js":"\"use strict\";\nvar firstLineError;\ntry {throw new Error(); } catch (e) {firstLineError = e;}\nvar schedule = require(\"./schedule.js\");\nvar Queue = require(\"./queue.js\");\nvar util = require(\"./util.js\");\n\nfunction Async() {\n    this._isTickUsed = false;\n    this._lateQueue = new Queue(16);\n    this._normalQueue = new Queue(16);\n    this._trampolineEnabled = true;\n    var self = this;\n    this.drainQueues = function () {\n        self._drainQueues();\n    };\n    this._schedule =\n        schedule.isStatic ? schedule(this.drainQueues) : schedule;\n}\n\nAsync.prototype.disableTrampolineIfNecessary = function() {\n    if (util.hasDevTools) {\n        this._trampolineEnabled = false;\n    }\n};\n\nAsync.prototype.enableTrampoline = function() {\n    if (!this._trampolineEnabled) {\n        this._trampolineEnabled = true;\n        this._schedule = function(fn) {\n            setTimeout(fn, 0);\n        };\n    }\n};\n\nAsync.prototype.haveItemsQueued = function () {\n    return this._normalQueue.length() > 0;\n};\n\nAsync.prototype.throwLater = function(fn, arg) {\n    if (arguments.length === 1) {\n        arg = fn;\n        fn = function () { throw arg; };\n    }\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function() {\n            fn(arg);\n        }, 0);\n    } else try {\n        this._schedule(function() {\n            fn(arg);\n        });\n    } catch (e) {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n    }\n};\n\nfunction AsyncInvokeLater(fn, receiver, arg) {\n    this._lateQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncInvoke(fn, receiver, arg) {\n    this._normalQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncSettlePromises(promise) {\n    this._normalQueue._pushOne(promise);\n    this._queueTick();\n}\n\nif (!util.hasDevTools) {\n    Async.prototype.invokeLater = AsyncInvokeLater;\n    Async.prototype.invoke = AsyncInvoke;\n    Async.prototype.settlePromises = AsyncSettlePromises;\n} else {\n    if (schedule.isStatic) {\n        schedule = function(fn) { setTimeout(fn, 0); };\n    }\n    Async.prototype.invokeLater = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvokeLater.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                setTimeout(function() {\n                    fn.call(receiver, arg);\n                }, 100);\n            });\n        }\n    };\n\n    Async.prototype.invoke = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvoke.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                fn.call(receiver, arg);\n            });\n        }\n    };\n\n    Async.prototype.settlePromises = function(promise) {\n        if (this._trampolineEnabled) {\n            AsyncSettlePromises.call(this, promise);\n        } else {\n            this._schedule(function() {\n                promise._settlePromises();\n            });\n        }\n    };\n}\n\nAsync.prototype.invokeFirst = function (fn, receiver, arg) {\n    this._normalQueue.unshift(fn, receiver, arg);\n    this._queueTick();\n};\n\nAsync.prototype._drainQueue = function(queue) {\n    while (queue.length() > 0) {\n        var fn = queue.shift();\n        if (typeof fn !== \"function\") {\n            fn._settlePromises();\n            continue;\n        }\n        var receiver = queue.shift();\n        var arg = queue.shift();\n        fn.call(receiver, arg);\n    }\n};\n\nAsync.prototype._drainQueues = function () {\n    this._drainQueue(this._normalQueue);\n    this._reset();\n    this._drainQueue(this._lateQueue);\n};\n\nAsync.prototype._queueTick = function () {\n    if (!this._isTickUsed) {\n        this._isTickUsed = true;\n        this._schedule(this.drainQueues);\n    }\n};\n\nAsync.prototype._reset = function () {\n    this._isTickUsed = false;\n};\n\nmodule.exports = new Async();\nmodule.exports.firstLineError = firstLineError;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/schedule.js":"\"use strict\";\nvar schedule;\nvar util = require(\"./util\");\nvar noAsyncScheduler = function() {\n    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n};\nif (util.isNode && typeof MutationObserver === \"undefined\") {\n    var GlobalSetImmediate = global.setImmediate;\n    var ProcessNextTick = process.nextTick;\n    schedule = util.isRecentNode\n                ? function(fn) { GlobalSetImmediate.call(global, fn); }\n                : function(fn) { ProcessNextTick.call(process, fn); };\n} else if ((typeof MutationObserver !== \"undefined\") &&\n          !(typeof window !== \"undefined\" &&\n            window.navigator &&\n            window.navigator.standalone)) {\n    schedule = function(fn) {\n        var div = document.createElement(\"div\");\n        var observer = new MutationObserver(fn);\n        observer.observe(div, {attributes: true});\n        return function() { div.classList.toggle(\"foo\"); };\n    };\n    schedule.isStatic = true;\n} else if (typeof setImmediate !== \"undefined\") {\n    schedule = function (fn) {\n        setImmediate(fn);\n    };\n} else if (typeof setTimeout !== \"undefined\") {\n    schedule = function (fn) {\n        setTimeout(fn, 0);\n    };\n} else {\n    schedule = noAsyncScheduler;\n}\nmodule.exports = schedule;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/queue.js":"\"use strict\";\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n}\n\nQueue.prototype._willBeOverCapacity = function (size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function (arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype._unshiftOne = function(value) {\n    var capacity = this._capacity;\n    this._checkCapacity(this.length() + 1);\n    var front = this._front;\n    var i = (((( front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n    this[i] = value;\n    this._front = i;\n    this._length = this.length() + 1;\n};\n\nQueue.prototype.unshift = function(fn, receiver, arg) {\n    this._unshiftOne(arg);\n    this._unshiftOne(receiver);\n    this._unshiftOne(fn);\n};\n\nQueue.prototype.push = function (fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function () {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = undefined;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function () {\n    return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 1);\n    }\n};\n\nQueue.prototype._resizeTo = function (capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n};\n\nmodule.exports = Queue;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/errors.js":"\"use strict\";\nvar es5 = require(\"./es5.js\");\nvar Objectfreeze = es5.freeze;\nvar util = require(\"./util.js\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        notEnumerableProp(this, \"message\",\n            typeof message === \"string\" ? message : defaultMessage);\n        notEnumerableProp(this, \"name\", nameProperty);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Error.call(this);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nes5.defineProperty(AggregateError.prototype, \"length\", {\n    value: 0,\n    configurable: false,\n    writable: true,\n    enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    if (!(this instanceof OperationalError))\n        return new OperationalError(message);\n    notEnumerableProp(this, \"name\", \"OperationalError\");\n    notEnumerableProp(this, \"message\", message);\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        notEnumerableProp(this, \"message\", message.message);\n        notEnumerableProp(this, \"stack\", message.stack);\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    notEnumerableProp(Error, \"__BluebirdErrorTypes__\", errorTypes);\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    Warning: Warning\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/thenables.js":"\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar util = require(\"./util.js\");\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction tryConvertToPromise(obj, context) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) {\n            return obj;\n        }\n        else if (isAnyBluebirdPromise(obj)) {\n            var ret = new Promise(INTERNAL);\n            obj._then(\n                ret._fulfillUnchecked,\n                ret._rejectUncheckedCheckError,\n                ret._progressUnchecked,\n                ret,\n                null\n            );\n            return ret;\n        }\n        var then = util.tryCatch(getThen)(obj);\n        if (then === errorObj) {\n            if (context) context._pushContext();\n            var ret = Promise.reject(then.e);\n            if (context) context._popContext();\n            return ret;\n        } else if (typeof then === \"function\") {\n            return doThenable(obj, then, context);\n        }\n    }\n    return obj;\n}\n\nfunction getThen(obj) {\n    return obj.then;\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    return hasProp.call(obj, \"_promise0\");\n}\n\nfunction doThenable(x, then, context) {\n    var promise = new Promise(INTERNAL);\n    var ret = promise;\n    if (context) context._pushContext();\n    promise._captureStackTrace();\n    if (context) context._popContext();\n    var synchronous = true;\n    var result = util.tryCatch(then).call(x,\n                                        resolveFromThenable,\n                                        rejectFromThenable,\n                                        progressFromThenable);\n    synchronous = false;\n    if (promise && result === errorObj) {\n        promise._rejectCallback(result.e, true, true);\n        promise = null;\n    }\n\n    function resolveFromThenable(value) {\n        if (!promise) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }\n\n    function rejectFromThenable(reason) {\n        if (!promise) return;\n        promise._rejectCallback(reason, synchronous, true);\n        promise = null;\n    }\n\n    function progressFromThenable(value) {\n        if (!promise) return;\n        if (typeof promise._progress === \"function\") {\n            promise._progress(value);\n        }\n    }\n    return ret;\n}\n\nreturn tryConvertToPromise;\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/promise_array.js":"\"use strict\";\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n    apiRejection) {\nvar util = require(\"./util.js\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -2: return [];\n    case -3: return {};\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    var parent;\n    if (values instanceof Promise) {\n        parent = values;\n        promise._propagateFrom(parent, 1 | 4);\n    }\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(undefined, -2);\n}\nPromiseArray.prototype.length = function () {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n    var values = tryConvertToPromise(this._values, this._promise);\n    if (values instanceof Promise) {\n        values = values._target();\n        this._values = values;\n        if (values._isFulfilled()) {\n            values = values._value();\n            if (!isArray(values)) {\n                var err = new Promise.TypeError(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n                this.__hardReject__(err);\n                return;\n            }\n        } else if (values._isPending()) {\n            values._then(\n                init,\n                this._reject,\n                undefined,\n                this,\n                resolveValueIfEmpty\n           );\n            return;\n        } else {\n            this._reject(values._reason());\n            return;\n        }\n    } else if (!isArray(values)) {\n        this._promise._reject(apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\")._reason());\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    var len = this.getActualLength(values.length);\n    this._length = len;\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n    var promise = this._promise;\n    for (var i = 0; i < len; ++i) {\n        var isResolved = this._isResolved();\n        var maybePromise = tryConvertToPromise(values[i], promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (isResolved) {\n                maybePromise._ignoreRejections();\n            } else if (maybePromise._isPending()) {\n                maybePromise._proxyPromiseArray(this, i);\n            } else if (maybePromise._isFulfilled()) {\n                this._promiseFulfilled(maybePromise._value(), i);\n            } else {\n                this._promiseRejected(maybePromise._reason(), i);\n            }\n        } else if (!isResolved) {\n            this._promiseFulfilled(maybePromise, i);\n        }\n    }\n};\n\nPromiseArray.prototype._isResolved = function () {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function (value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype.__hardReject__ =\nPromiseArray.prototype._reject = function (reason) {\n    this._values = null;\n    this._promise._rejectCallback(reason, false, true);\n};\n\nPromiseArray.prototype._promiseProgressed = function (progressValue, index) {\n    this._promise._progress({\n        index: index,\n        value: progressValue\n    });\n};\n\n\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nPromiseArray.prototype._promiseRejected = function (reason, index) {\n    this._totalResolved++;\n    this._reject(reason);\n};\n\nPromiseArray.prototype.shouldCopyValues = function () {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength = function (len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/captured_trace.js":"\"use strict\";\nmodule.exports = function() {\nvar async = require(\"./async.js\");\nvar util = require(\"./util.js\");\nvar bluebirdFramePattern =\n    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](main|debug|zalgo|instrumented)/;\nvar stackFramePattern = null;\nvar formatStack = null;\nvar indentStackFrames = false;\nvar warn;\n\nfunction CapturedTrace(parent) {\n    this._parent = parent;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n}\nutil.inherits(CapturedTrace, Error);\n\nCapturedTrace.prototype.uncycle = function() {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n\n    for (var i = 0, node = this; node !== undefined; ++i) {\n        nodes.push(node);\n        node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n        var stack = nodes[i].stack;\n        if (stackToIndex[stack] === undefined) {\n            stackToIndex[stack] = i;\n        }\n    }\n    for (var i = 0; i < length; ++i) {\n        var currentStack = nodes[i].stack;\n        var index = stackToIndex[currentStack];\n        if (index !== undefined && index !== i) {\n            if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n            }\n            nodes[i]._parent = undefined;\n            nodes[i]._length = 1;\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n            if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n                cycleEdgeNode._parent.uncycle();\n                cycleEdgeNode._length =\n                    cycleEdgeNode._parent._length + 1;\n            } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n            }\n            var currentChildLength = cycleEdgeNode._length + 1;\n            for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n            }\n            return;\n        }\n    }\n};\n\nCapturedTrace.prototype.parent = function() {\n    return this._parent;\n};\n\nCapturedTrace.prototype.hasParent = function() {\n    return this._parent !== undefined;\n};\n\nCapturedTrace.prototype.attachExtraTrace = function(error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = CapturedTrace.parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n\n    var trace = this;\n    while (trace !== undefined) {\n        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n        trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n};\n\nfunction reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n        stacks[i].push(\"From previous event:\");\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n}\n\nfunction removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n        if (stacks[i].length === 0 ||\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n            stacks.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n        var prev = stacks[i];\n        var currentLastIndex = current.length - 1;\n        var currentLastLine = current[currentLastIndex];\n        var commonRootMeetPoint = -1;\n\n        for (var j = prev.length - 1; j >= 0; --j) {\n            if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n            }\n        }\n\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\n            var line = prev[j];\n            if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n            } else {\n                break;\n            }\n        }\n        current = prev;\n    }\n}\n\nfunction cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        var isTraceLine = stackFramePattern.test(line) ||\n            \"    (No stack trace)\" === line;\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\n        if (isTraceLine && !isInternalFrame) {\n            if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n            }\n            ret.push(line);\n        }\n    }\n    return ret;\n}\n\nfunction stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n            break;\n        }\n    }\n    if (i > 0) {\n        stack = stack.slice(i);\n    }\n    return stack;\n}\n\nCapturedTrace.parseStackAndMessage = function(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0\n                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n        message: message,\n        stack: cleanStack(stack)\n    };\n};\n\nCapturedTrace.formatAndLogError = function(error, title) {\n    if (typeof console !== \"undefined\") {\n        var message;\n        if (typeof error === \"object\" || typeof error === \"function\") {\n            var stack = error.stack;\n            message = title + formatStack(stack, error);\n        } else {\n            message = title + String(error);\n        }\n        if (typeof warn === \"function\") {\n            warn(message);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n};\n\nCapturedTrace.unhandledRejection = function (reason) {\n    CapturedTrace.formatAndLogError(reason, \"^--- With additional stack trace: \");\n};\n\nCapturedTrace.isSupported = function () {\n    return typeof captureStackTrace === \"function\";\n};\n\nCapturedTrace.fireRejectionEvent =\nfunction(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n        if (typeof localHandler === \"function\") {\n            localEventFired = true;\n            if (name === \"rejectionHandled\") {\n                localHandler(promise);\n            } else {\n                localHandler(reason, promise);\n            }\n        }\n    } catch (e) {\n        async.throwLater(e);\n    }\n\n    var globalEventFired = false;\n    try {\n        globalEventFired = fireGlobalEvent(name, reason, promise);\n    } catch (e) {\n        globalEventFired = true;\n        async.throwLater(e);\n    }\n\n    var domEventFired = false;\n    if (fireDomEvent) {\n        try {\n            domEventFired = fireDomEvent(name.toLowerCase(), {\n                reason: reason,\n                promise: promise\n            });\n        } catch (e) {\n            domEventFired = true;\n            async.throwLater(e);\n        }\n    }\n\n    if (!globalEventFired && !localEventFired && !domEventFired &&\n        name === \"unhandledRejection\") {\n        CapturedTrace.formatAndLogError(reason, \"Unhandled rejection \");\n    }\n};\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj.toString();\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nvar shouldIgnore = function() { return false; };\nvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\nfunction parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n        return {\n            fileName: matches[1],\n            line: parseInt(matches[2], 10)\n        };\n    }\n}\nCapturedTrace.setBounds = function(firstLineError, lastLineError) {\n    if (!CapturedTrace.isSupported()) return;\n    var firstStackLines = firstLineError.stack.split(\"\\n\");\n    var lastStackLines = lastLineError.stack.split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n        var result = parseLineInfo(firstStackLines[i]);\n        if (result) {\n            firstFileName = result.fileName;\n            firstIndex = result.line;\n            break;\n        }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n        var result = parseLineInfo(lastStackLines[i]);\n        if (result) {\n            lastFileName = result.fileName;\n            lastIndex = result.line;\n            break;\n        }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n        return;\n    }\n\n    shouldIgnore = function(line) {\n        if (bluebirdFramePattern.test(line)) return true;\n        var info = parseLineInfo(line);\n        if (info) {\n            if (info.fileName === firstFileName &&\n                (firstIndex <= info.line && info.line <= lastIndex)) {\n                return true;\n            }\n        }\n        return false;\n    };\n};\n\nvar captureStackTrace = (function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if (error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        Error.stackTraceLimit = Error.stackTraceLimit + 6;\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        var captureStackTrace = Error.captureStackTrace;\n\n        shouldIgnore = function(line) {\n            return bluebirdFramePattern.test(line);\n        };\n        return function(receiver, ignoreUntil) {\n            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n            captureStackTrace(receiver, ignoreUntil);\n            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n        stackFramePattern = /@/;\n        formatStack = v8stackFormatter;\n        indentStackFrames = true;\n        return function captureStackTrace(o) {\n            o.stack = new Error().stack;\n        };\n    }\n\n    var hasStackAfterThrow;\n    try { throw new Error(); }\n    catch(e) {\n        hasStackAfterThrow = (\"stack\" in e);\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow &&\n        typeof Error.stackTraceLimit === \"number\") {\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        return function captureStackTrace(o) {\n            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n            try { throw new Error(); }\n            catch(e) { o.stack = e.stack; }\n            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n        };\n    }\n\n    formatStack = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if ((typeof error === \"object\" ||\n            typeof error === \"function\") &&\n            error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    return null;\n\n})([]);\n\nvar fireDomEvent;\nvar fireGlobalEvent = (function() {\n    if (util.isNode) {\n        return function(name, reason, promise) {\n            if (name === \"rejectionHandled\") {\n                return process.emit(name, promise);\n            } else {\n                return process.emit(name, reason, promise);\n            }\n        };\n    } else {\n        var customEventWorks = false;\n        var anyEventWorks = true;\n        try {\n            var ev = new self.CustomEvent(\"test\");\n            customEventWorks = ev instanceof CustomEvent;\n        } catch (e) {}\n        if (!customEventWorks) {\n            try {\n                var event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent(\"testingtheevent\", false, true, {});\n                self.dispatchEvent(event);\n            } catch (e) {\n                anyEventWorks = false;\n            }\n        }\n        if (anyEventWorks) {\n            fireDomEvent = function(type, detail) {\n                var event;\n                if (customEventWorks) {\n                    event = new self.CustomEvent(type, {\n                        detail: detail,\n                        bubbles: false,\n                        cancelable: true\n                    });\n                } else if (self.dispatchEvent) {\n                    event = document.createEvent(\"CustomEvent\");\n                    event.initCustomEvent(type, false, true, detail);\n                }\n\n                return event ? !self.dispatchEvent(event) : false;\n            };\n        }\n\n        var toWindowMethodNameMap = {};\n        toWindowMethodNameMap[\"unhandledRejection\"] = (\"on\" +\n            \"unhandledRejection\").toLowerCase();\n        toWindowMethodNameMap[\"rejectionHandled\"] = (\"on\" +\n            \"rejectionHandled\").toLowerCase();\n\n        return function(name, reason, promise) {\n            var methodName = toWindowMethodNameMap[name];\n            var method = self[methodName];\n            if (!method) return false;\n            if (name === \"rejectionHandled\") {\n                method.call(self, promise);\n            } else {\n                method.call(self, reason, promise);\n            }\n            return true;\n        };\n    }\n})();\n\nif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    warn = function (message) {\n        console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n        warn = function(message) {\n            process.stderr.write(\"\\u001b[31m\" + message + \"\\u001b[39m\\n\");\n        };\n    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n        warn = function(message) {\n            console.warn(\"%c\" + message, \"color: red\");\n        };\n    }\n}\n\nreturn CapturedTrace;\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/debuggability.js":"\"use strict\";\nmodule.exports = function(Promise, CapturedTrace) {\nvar getDomain = Promise._getDomain;\nvar async = require(\"./async.js\");\nvar Warning = require(\"./errors.js\").Warning;\nvar util = require(\"./util.js\");\nvar canAttachTrace = util.canAttachTrace;\nvar unhandledRejectionHandled;\nvar possiblyUnhandledRejection;\nvar debugging = false || (util.isNode &&\n                    (!!process.env[\"BLUEBIRD_DEBUG\"] ||\n                     process.env[\"NODE_ENV\"] === \"development\"));\n\nif (util.isNode && process.env[\"BLUEBIRD_DEBUG\"] == 0) debugging = false;\n\nif (debugging) {\n    async.disableTrampolineIfNecessary();\n}\n\nPromise.prototype._ignoreRejections = function() {\n    this._unsetRejectionIsUnhandled();\n    this._bitField = this._bitField | 16777216;\n};\n\nPromise.prototype._ensurePossibleRejectionHandled = function () {\n    if ((this._bitField & 16777216) !== 0) return;\n    this._setRejectionIsUnhandled();\n    async.invokeLater(this._notifyUnhandledRejection, this, undefined);\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    CapturedTrace.fireRejectionEvent(\"rejectionHandled\",\n                                  unhandledRejectionHandled, undefined, this);\n};\n\nPromise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._getCarriedStackTrace() || this._settledValue;\n        this._setUnhandledRejectionIsNotified();\n        CapturedTrace.fireRejectionEvent(\"unhandledRejection\",\n                                      possiblyUnhandledRejection, reason, this);\n    }\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 524288;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & (~524288);\n};\n\nPromise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 524288) > 0;\n};\n\nPromise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 2097152;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & (~2097152);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 2097152) > 0;\n};\n\nPromise.prototype._setCarriedStackTrace = function (capturedTrace) {\n    this._bitField = this._bitField | 1048576;\n    this._fulfillmentHandler0 = capturedTrace;\n};\n\nPromise.prototype._isCarryingStackTrace = function () {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._getCarriedStackTrace = function () {\n    return this._isCarryingStackTrace()\n        ? this._fulfillmentHandler0\n        : undefined;\n};\n\nPromise.prototype._captureStackTrace = function () {\n    if (debugging) {\n        this._trace = new CapturedTrace(this._peekContext());\n    }\n    return this;\n};\n\nPromise.prototype._attachExtraTrace = function (error, ignoreSelf) {\n    if (debugging && canAttachTrace(error)) {\n        var trace = this._trace;\n        if (trace !== undefined) {\n            if (ignoreSelf) trace = trace._parent;\n        }\n        if (trace !== undefined) {\n            trace.attachExtraTrace(error);\n        } else if (!error.__stackCleaned__) {\n            var parsed = CapturedTrace.parseStackAndMessage(error);\n            util.notEnumerableProp(error, \"stack\",\n                parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        }\n    }\n};\n\nPromise.prototype._warn = function(message) {\n    var warning = new Warning(message);\n    var ctx = this._peekContext();\n    if (ctx) {\n        ctx.attachExtraTrace(warning);\n    } else {\n        var parsed = CapturedTrace.parseStackAndMessage(warning);\n        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n    CapturedTrace.formatAndLogError(warning, \"\");\n};\n\nPromise.onPossiblyUnhandledRejection = function (fn) {\n    var domain = getDomain();\n    possiblyUnhandledRejection =\n        typeof fn === \"function\" ? (domain === null ? fn : domain.bind(fn))\n                                 : undefined;\n};\n\nPromise.onUnhandledRejectionHandled = function (fn) {\n    var domain = getDomain();\n    unhandledRejectionHandled =\n        typeof fn === \"function\" ? (domain === null ? fn : domain.bind(fn))\n                                 : undefined;\n};\n\nPromise.longStackTraces = function () {\n    if (async.haveItemsQueued() &&\n        debugging === false\n   ) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/DT1qyG\\u000a\");\n    }\n    debugging = CapturedTrace.isSupported();\n    if (debugging) {\n        async.disableTrampolineIfNecessary();\n    }\n};\n\nPromise.hasLongStackTraces = function () {\n    return debugging && CapturedTrace.isSupported();\n};\n\nif (!CapturedTrace.isSupported()) {\n    Promise.longStackTraces = function(){};\n    debugging = false;\n}\n\nreturn function() {\n    return debugging;\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/context.js":"\"use strict\";\nmodule.exports = function(Promise, CapturedTrace, isDebugging) {\nvar contextStack = [];\nfunction Context() {\n    this._trace = new CapturedTrace(peekContext());\n}\nContext.prototype._pushContext = function () {\n    if (!isDebugging()) return;\n    if (this._trace !== undefined) {\n        contextStack.push(this._trace);\n    }\n};\n\nContext.prototype._popContext = function () {\n    if (!isDebugging()) return;\n    if (this._trace !== undefined) {\n        contextStack.pop();\n    }\n};\n\nfunction createContext() {\n    if (isDebugging()) return new Context();\n}\n\nfunction peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return undefined;\n}\n\nPromise.prototype._peekContext = peekContext;\nPromise.prototype._pushContext = Context.prototype._pushContext;\nPromise.prototype._popContext = Context.prototype._popContext;\n\nreturn createContext;\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/catch_filter.js":"\"use strict\";\nmodule.exports = function(NEXT_FILTER) {\nvar util = require(\"./util.js\");\nvar errors = require(\"./errors.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar keys = require(\"./es5.js\").keys;\nvar TypeError = errors.TypeError;\n\nfunction CatchFilter(instances, callback, promise) {\n    this._instances = instances;\n    this._callback = callback;\n    this._promise = promise;\n}\n\nfunction safePredicate(predicate, e) {\n    var safeObject = {};\n    var retfilter = tryCatch(predicate).call(safeObject, e);\n\n    if (retfilter === errorObj) return retfilter;\n\n    var safeKeys = keys(safeObject);\n    if (safeKeys.length) {\n        errorObj.e = new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\");\n        return errorObj;\n    }\n    return retfilter;\n}\n\nCatchFilter.prototype.doFilter = function (e) {\n    var cb = this._callback;\n    var promise = this._promise;\n    var boundTo = promise._boundValue();\n    for (var i = 0, len = this._instances.length; i < len; ++i) {\n        var item = this._instances[i];\n        var itemIsErrorType = item === Error ||\n            (item != null && item.prototype instanceof Error);\n\n        if (itemIsErrorType && e instanceof item) {\n            var ret = tryCatch(cb).call(boundTo, e);\n            if (ret === errorObj) {\n                NEXT_FILTER.e = ret.e;\n                return NEXT_FILTER;\n            }\n            return ret;\n        } else if (typeof item === \"function\" && !itemIsErrorType) {\n            var shouldHandle = safePredicate(item, e);\n            if (shouldHandle === errorObj) {\n                e = errorObj.e;\n                break;\n            } else if (shouldHandle) {\n                var ret = tryCatch(cb).call(boundTo, e);\n                if (ret === errorObj) {\n                    NEXT_FILTER.e = ret.e;\n                    return NEXT_FILTER;\n                }\n                return ret;\n            }\n        }\n    }\n    NEXT_FILTER.e = e;\n    return NEXT_FILTER;\n};\n\nreturn CatchFilter;\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/promise_resolver.js":"\"use strict\";\nvar util = require(\"./util.js\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = require(\"./errors.js\");\nvar TimeoutError = errors.TimeoutError;\nvar OperationalError = errors.OperationalError;\nvar haveGetters = util.haveGetters;\nvar es5 = require(\"./es5.js\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n        ret.name = obj.name;\n        ret.message = obj.message;\n        ret.stack = obj.stack;\n        var keys = es5.keys(obj);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!rErrorKey.test(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    util.markAsOriginatingFromRejection(obj);\n    return obj;\n}\n\nfunction nodebackForPromise(promise) {\n    return function(err, value) {\n        if (promise === null) return;\n\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (arguments.length > 2) {\n            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n            promise._fulfill(args);\n        } else {\n            promise._fulfill(value);\n        }\n\n        promise = null;\n    };\n}\n\n\nvar PromiseResolver;\nif (!haveGetters) {\n    PromiseResolver = function (promise) {\n        this.promise = promise;\n        this.asCallback = nodebackForPromise(promise);\n        this.callback = this.asCallback;\n    };\n}\nelse {\n    PromiseResolver = function (promise) {\n        this.promise = promise;\n    };\n}\nif (haveGetters) {\n    var prop = {\n        get: function() {\n            return nodebackForPromise(this.promise);\n        }\n    };\n    es5.defineProperty(PromiseResolver.prototype, \"asCallback\", prop);\n    es5.defineProperty(PromiseResolver.prototype, \"callback\", prop);\n}\n\nPromiseResolver._nodebackForPromise = nodebackForPromise;\n\nPromiseResolver.prototype.toString = function () {\n    return \"[object PromiseResolver]\";\n};\n\nPromiseResolver.prototype.resolve =\nPromiseResolver.prototype.fulfill = function (value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._resolveCallback(value);\n};\n\nPromiseResolver.prototype.reject = function (reason) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._rejectCallback(reason);\n};\n\nPromiseResolver.prototype.progress = function (value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._progress(value);\n};\n\nPromiseResolver.prototype.cancel = function (err) {\n    this.promise.cancel(err);\n};\n\nPromiseResolver.prototype.timeout = function () {\n    this.reject(new TimeoutError(\"timeout\"));\n};\n\nPromiseResolver.prototype.isResolved = function () {\n    return this.promise.isResolved();\n};\n\nPromiseResolver.prototype.toJSON = function () {\n    return this.promise.toJSON();\n};\n\nmodule.exports = PromiseResolver;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/progress.js":"\"use strict\";\nmodule.exports = function(Promise, PromiseArray) {\nvar util = require(\"./util.js\");\nvar async = require(\"./async.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nPromise.prototype.progressed = function (handler) {\n    return this._then(undefined, undefined, handler, undefined, undefined);\n};\n\nPromise.prototype._progress = function (progressValue) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._target()._progressUnchecked(progressValue);\n\n};\n\nPromise.prototype._progressHandlerAt = function (index) {\n    return index === 0\n        ? this._progressHandler0\n        : this[(index << 2) + index - 5 + 2];\n};\n\nPromise.prototype._doProgressWith = function (progression) {\n    var progressValue = progression.value;\n    var handler = progression.handler;\n    var promise = progression.promise;\n    var receiver = progression.receiver;\n\n    var ret = tryCatch(handler).call(receiver, progressValue);\n    if (ret === errorObj) {\n        if (ret.e != null &&\n            ret.e.name !== \"StopProgressPropagation\") {\n            var trace = util.canAttachTrace(ret.e)\n                ? ret.e : new Error(util.toString(ret.e));\n            promise._attachExtraTrace(trace);\n            promise._progress(ret.e);\n        }\n    } else if (ret instanceof Promise) {\n        ret._then(promise._progress, null, null, promise, undefined);\n    } else {\n        promise._progress(ret);\n    }\n};\n\n\nPromise.prototype._progressUnchecked = function (progressValue) {\n    var len = this._length();\n    var progress = this._progress;\n    for (var i = 0; i < len; i++) {\n        var handler = this._progressHandlerAt(i);\n        var promise = this._promiseAt(i);\n        if (!(promise instanceof Promise)) {\n            var receiver = this._receiverAt(i);\n            if (typeof handler === \"function\") {\n                handler.call(receiver, progressValue, promise);\n            } else if (receiver instanceof PromiseArray &&\n                       !receiver._isResolved()) {\n                receiver._promiseProgressed(progressValue, promise);\n            }\n            continue;\n        }\n\n        if (typeof handler === \"function\") {\n            async.invoke(this._doProgressWith, this, {\n                handler: handler,\n                promise: promise,\n                receiver: this._receiverAt(i),\n                value: progressValue\n            });\n        } else {\n            async.invoke(progress, promise, progressValue);\n        }\n    }\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/method.js":"\"use strict\";\nmodule.exports =\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar util = require(\"./util.js\");\nvar tryCatch = util.tryCatch;\n\nPromise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n        throw new Promise.TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    return function () {\n        var ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._pushContext();\n        var value = tryCatch(fn).apply(this, arguments);\n        ret._popContext();\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function (fn, args, ctx) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value = util.isArray(args)\n        ? tryCatch(fn).apply(ctx, args)\n        : tryCatch(fn).call(ctx, args);\n    ret._popContext();\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n        this._rejectCallback(value.e, false, true);\n    } else {\n        this._resolveCallback(value, true);\n    }\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/bind.js":"\"use strict\";\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise) {\nvar rejectThis = function(_, e) {\n    this._reject(e);\n};\n\nvar targetRejected = function(e, context) {\n    context.promiseRejectionQueued = true;\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n};\n\nvar bindingResolved = function(thisArg, context) {\n    if (this._isPending()) {\n        this._resolveCallback(context.target);\n    }\n};\n\nvar bindingRejected = function(e, context) {\n    if (!context.promiseRejectionQueued) this._reject(e);\n};\n\nPromise.prototype.bind = function (thisArg) {\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 1);\n    var target = this._target();\n\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        var context = {\n            promiseRejectionQueued: false,\n            promise: ret,\n            target: target,\n            bindingPromise: maybePromise\n        };\n        target._then(INTERNAL, targetRejected, ret._progress, ret, context);\n        maybePromise._then(\n            bindingResolved, bindingRejected, ret._progress, ret, context);\n    } else {\n        ret._resolveCallback(target);\n    }\n    return ret;\n};\n\nPromise.prototype._setBoundTo = function (obj) {\n    if (obj !== undefined) {\n        this._bitField = this._bitField | 131072;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~131072);\n    }\n};\n\nPromise.prototype._isBound = function () {\n    return (this._bitField & 131072) === 131072;\n};\n\nPromise.bind = function (thisArg, value) {\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        maybePromise._then(function() {\n            ret._resolveCallback(value);\n        }, ret._reject, ret._progress, ret, null);\n    } else {\n        ret._resolveCallback(value);\n    }\n    return ret;\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/finally.js":"\"use strict\";\nmodule.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {\nvar util = require(\"./util.js\");\nvar isPrimitive = util.isPrimitive;\nvar thrower = util.thrower;\n\nfunction returnThis() {\n    return this;\n}\nfunction throwThis() {\n    throw this;\n}\nfunction return$(r) {\n    return function() {\n        return r;\n    };\n}\nfunction throw$(r) {\n    return function() {\n        throw r;\n    };\n}\nfunction promisedFinally(ret, reasonOrValue, isFulfilled) {\n    var then;\n    if (isPrimitive(reasonOrValue)) {\n        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);\n    } else {\n        then = isFulfilled ? returnThis : throwThis;\n    }\n    return ret._then(then, thrower, undefined, reasonOrValue, undefined);\n}\n\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundValue())\n                    : handler();\n\n    if (ret !== undefined) {\n        var maybePromise = tryConvertToPromise(ret, promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            return promisedFinally(maybePromise, reasonOrValue,\n                                    promise.isFulfilled());\n        }\n    }\n\n    if (promise.isRejected()) {\n        NEXT_FILTER.e = reasonOrValue;\n        return NEXT_FILTER;\n    } else {\n        return reasonOrValue;\n    }\n}\n\nfunction tapHandler(value) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundValue(), value)\n                    : handler(value);\n\n    if (ret !== undefined) {\n        var maybePromise = tryConvertToPromise(ret, promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            return promisedFinally(maybePromise, value, true);\n        }\n    }\n    return value;\n}\n\nPromise.prototype._passThroughHandler = function (handler, isFinally) {\n    if (typeof handler !== \"function\") return this.then();\n\n    var promiseAndHandler = {\n        promise: this,\n        handler: handler\n    };\n\n    return this._then(\n            isFinally ? finallyHandler : tapHandler,\n            isFinally ? finallyHandler : undefined, undefined,\n            promiseAndHandler, undefined);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function (handler) {\n    return this._passThroughHandler(handler, true);\n};\n\nPromise.prototype.tap = function (handler) {\n    return this._passThroughHandler(handler, false);\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/direct_resolve.js":"\"use strict\";\nvar util = require(\"./util.js\");\nvar isPrimitive = util.isPrimitive;\n\nmodule.exports = function(Promise) {\nvar returner = function () {\n    return this;\n};\nvar thrower = function () {\n    throw this;\n};\nvar returnUndefined = function() {};\nvar throwUndefined = function() {\n    throw undefined;\n};\n\nvar wrapper = function (value, action) {\n    if (action === 1) {\n        return function () {\n            throw value;\n        };\n    } else if (action === 2) {\n        return function () {\n            return value;\n        };\n    }\n};\n\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn = function (value) {\n    if (value === undefined) return this.then(returnUndefined);\n\n    if (isPrimitive(value)) {\n        return this._then(\n            wrapper(value, 2),\n            undefined,\n            undefined,\n            undefined,\n            undefined\n       );\n    } else if (value instanceof Promise) {\n        value._ignoreRejections();\n    }\n    return this._then(returner, undefined, undefined, value, undefined);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow = function (reason) {\n    if (reason === undefined) return this.then(throwUndefined);\n\n    if (isPrimitive(reason)) {\n        return this._then(\n            wrapper(reason, 1),\n            undefined,\n            undefined,\n            undefined,\n            undefined\n       );\n    }\n    return this._then(thrower, undefined, undefined, reason, undefined);\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/synchronous_inspection.js":"\"use strict\";\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== undefined) {\n        promise = promise._target();\n        this._bitField = promise._bitField;\n        this._settledValue = promise._settledValue;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValue = undefined;\n    }\n}\n\nPromiseInspection.prototype.value = function () {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.error =\nPromiseInspection.prototype.reason = function () {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.isFulfilled =\nPromise.prototype._isFulfilled = function () {\n    return (this._bitField & 268435456) > 0;\n};\n\nPromiseInspection.prototype.isRejected =\nPromise.prototype._isRejected = function () {\n    return (this._bitField & 134217728) > 0;\n};\n\nPromiseInspection.prototype.isPending =\nPromise.prototype._isPending = function () {\n    return (this._bitField & 402653184) === 0;\n};\n\nPromiseInspection.prototype.isResolved =\nPromise.prototype._isResolved = function () {\n    return (this._bitField & 402653184) > 0;\n};\n\nPromise.prototype.isPending = function() {\n    return this._target()._isPending();\n};\n\nPromise.prototype.isRejected = function() {\n    return this._target()._isRejected();\n};\n\nPromise.prototype.isFulfilled = function() {\n    return this._target()._isFulfilled();\n};\n\nPromise.prototype.isResolved = function() {\n    return this._target()._isResolved();\n};\n\nPromise.prototype._value = function() {\n    return this._settledValue;\n};\n\nPromise.prototype._reason = function() {\n    this._unsetRejectionIsUnhandled();\n    return this._settledValue;\n};\n\nPromise.prototype.value = function() {\n    var target = this._target();\n    if (!target.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n    }\n    return target._settledValue;\n};\n\nPromise.prototype.reason = function() {\n    var target = this._target();\n    if (!target.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n    }\n    target._unsetRejectionIsUnhandled();\n    return target._settledValue;\n};\n\n\nPromise.PromiseInspection = PromiseInspection;\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/join.js":"\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {\nvar util = require(\"./util.js\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar reject;\n\nif (!false) {\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var caller = function(count) {\n        var values = [];\n        for (var i = 1; i <= count; ++i) values.push(\"holder.p\" + i);\n        return new Function(\"holder\", \"                                      \\n\\\n            'use strict';                                                    \\n\\\n            var callback = holder.fn;                                        \\n\\\n            return callback(values);                                         \\n\\\n            \".replace(/values/g, values.join(\", \")));\n    };\n    var thenCallbacks = [];\n    var callers = [undefined];\n    for (var i = 1; i <= 5; ++i) {\n        thenCallbacks.push(thenCallback(i));\n        callers.push(caller(i));\n    }\n\n    var Holder = function(total, fn) {\n        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;\n        this.fn = fn;\n        this.total = total;\n        this.now = 0;\n    };\n\n    Holder.prototype.callers = callers;\n    Holder.prototype.checkFulfillment = function(promise) {\n        var now = this.now;\n        now++;\n        var total = this.total;\n        if (now >= total) {\n            var handler = this.callers[total];\n            promise._pushContext();\n            var ret = tryCatch(handler)(this);\n            promise._popContext();\n            if (ret === errorObj) {\n                promise._rejectCallback(ret.e, false, true);\n            } else {\n                promise._resolveCallback(ret);\n            }\n        } else {\n            this.now = now;\n        }\n    };\n\n    var reject = function (reason) {\n        this._reject(reason);\n    };\n}\n}\n\nPromise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (!false) {\n            if (last < 6 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n                ret._captureStackTrace();\n                var holder = new Holder(last, fn);\n                var callbacks = thenCallbacks;\n                for (var i = 0; i < last; ++i) {\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                    if (maybePromise instanceof Promise) {\n                        maybePromise = maybePromise._target();\n                        if (maybePromise._isPending()) {\n                            maybePromise._then(callbacks[i], reject,\n                                               undefined, ret, holder);\n                        } else if (maybePromise._isFulfilled()) {\n                            callbacks[i].call(ret,\n                                              maybePromise._value(), holder);\n                        } else {\n                            ret._reject(maybePromise._reason());\n                        }\n                    } else {\n                        callbacks[i].call(ret, maybePromise, holder);\n                    }\n                }\n                return ret;\n            }\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n};\n\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/map.js":"\"use strict\";\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL) {\nvar getDomain = Promise._getDomain;\nvar async = require(\"./async.js\");\nvar util = require(\"./util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar PENDING = {};\nvar EMPTY_ARRAY = [];\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    var domain = getDomain();\n    this._callback = domain === null ? fn : domain.bind(fn);\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;\n    async.invoke(init, this, undefined);\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\nfunction init() {this._init$(undefined, -2);}\n\nMappingPromiseArray.prototype._init = function () {};\n\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n    if (values[index] === PENDING) {\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var callback = this._callback;\n        var receiver = this._promise._boundValue();\n        this._promise._pushContext();\n        var ret = tryCatch(callback).call(receiver, value, index, length);\n        this._promise._popContext();\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (maybePromise._isPending()) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = PENDING;\n                return maybePromise._proxyPromiseArray(this, index);\n            } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n            } else {\n                return this._reject(maybePromise._reason());\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n\n    }\n};\n\nMappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        if (this._isResolved()) return;\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    var limit = typeof options === \"object\" && options !== null\n        ? options.concurrency\n        : 0;\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter);\n}\n\nPromise.prototype.map = function (fn, options) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\n    return map(this, fn, options, null).promise();\n};\n\nPromise.map = function (promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    return map(promises, fn, options, _filter).promise();\n};\n\n\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/cancel.js":"\"use strict\";\nmodule.exports = function(Promise) {\nvar errors = require(\"./errors.js\");\nvar async = require(\"./async.js\");\nvar CancellationError = errors.CancellationError;\n\nPromise.prototype._cancel = function (reason) {\n    if (!this.isCancellable()) return this;\n    var parent;\n    var promiseToReject = this;\n    while ((parent = promiseToReject._cancellationParent) !== undefined &&\n        parent.isCancellable()) {\n        promiseToReject = parent;\n    }\n    this._unsetCancellable();\n    promiseToReject._target()._rejectCallback(reason, false, true);\n};\n\nPromise.prototype.cancel = function (reason) {\n    if (!this.isCancellable()) return this;\n    if (reason === undefined) reason = new CancellationError();\n    async.invokeLater(this._cancel, this, reason);\n    return this;\n};\n\nPromise.prototype.cancellable = function () {\n    if (this._cancellable()) return this;\n    async.enableTrampoline();\n    this._setCancellable();\n    this._cancellationParent = undefined;\n    return this;\n};\n\nPromise.prototype.uncancellable = function () {\n    var ret = this.then();\n    ret._unsetCancellable();\n    return ret;\n};\n\nPromise.prototype.fork = function (didFulfill, didReject, didProgress) {\n    var ret = this._then(didFulfill, didReject, didProgress,\n                         undefined, undefined);\n\n    ret._setCancellable();\n    ret._cancellationParent = undefined;\n    return ret;\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/using.js":"\"use strict\";\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n    createContext) {\n    var TypeError = require(\"./errors.js\").TypeError;\n    var inherits = require(\"./util.js\").inherits;\n    var PromiseInspection = Promise.PromiseInspection;\n\n    function inspectionMapper(inspections) {\n        var len = inspections.length;\n        for (var i = 0; i < len; ++i) {\n            var inspection = inspections[i];\n            if (inspection.isRejected()) {\n                return Promise.reject(inspection.error());\n            }\n            inspections[i] = inspection._settledValue;\n        }\n        return inspections;\n    }\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function castPreservingDisposable(thenable) {\n        var maybePromise = tryConvertToPromise(thenable);\n        if (maybePromise !== thenable &&\n            typeof thenable._isDisposable === \"function\" &&\n            typeof thenable._getDisposer === \"function\" &&\n            thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n        }\n        return maybePromise;\n    }\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = Promise.defer();\n        function iterator() {\n            if (i >= len) return ret.resolve();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = tryConvertToPromise(\n                        maybePromise._getDisposer().tryDispose(inspection),\n                        resources.promise);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret.promise;\n    }\n\n    function disposerSuccess(value) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = value;\n        inspection._bitField = 268435456;\n        return dispose(this, inspection).thenReturn(value);\n    }\n\n    function disposerFail(reason) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = reason;\n        inspection._bitField = 134217728;\n        return dispose(this, inspection).thenThrow(reason);\n    }\n\n    function Disposer(data, promise, context) {\n        this._data = data;\n        this._promise = promise;\n        this._context = context;\n    }\n\n    Disposer.prototype.data = function () {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function () {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function () {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return null;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var context = this._context;\n        if (context !== undefined) context._pushContext();\n        var ret = resource !== null\n            ? this.doDispose(resource, inspection) : null;\n        if (context !== undefined) context._popContext();\n        this._promise._unsetDisposable();\n        this._data = null;\n        return ret;\n    };\n\n    Disposer.isDisposer = function (d) {\n        return (d != null &&\n                typeof d.resource === \"function\" &&\n                typeof d.tryDispose === \"function\");\n    };\n\n    function FunctionDisposer(fn, promise, context) {\n        this.constructor$(fn, promise, context);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    function maybeUnwrapDisposer(value) {\n        if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n            return value.promise();\n        }\n        return value;\n    }\n\n    Promise.using = function () {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\n        var input;\n        var spreadArgs = true;\n        if (len === 2 && Array.isArray(arguments[0])) {\n            input = arguments[0];\n            len = input.length;\n            spreadArgs = false;\n        } else {\n            input = arguments;\n            len--;\n        }\n        var resources = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = input[i];\n            if (Disposer.isDisposer(resource)) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            } else {\n                var maybePromise = tryConvertToPromise(resource);\n                if (maybePromise instanceof Promise) {\n                    resource =\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n                            resources: resources,\n                            index: i\n                    }, undefined);\n                }\n            }\n            resources[i] = resource;\n        }\n\n        var promise = Promise.settle(resources)\n            .then(inspectionMapper)\n            .then(function(vals) {\n                promise._pushContext();\n                var ret;\n                try {\n                    ret = spreadArgs\n                        ? fn.apply(undefined, vals) : fn.call(undefined,  vals);\n                } finally {\n                    promise._popContext();\n                }\n                return ret;\n            })\n            ._then(\n                disposerSuccess, disposerFail, undefined, resources, undefined);\n        resources.promise = promise;\n        return promise;\n    };\n\n    Promise.prototype._setDisposable = function (disposer) {\n        this._bitField = this._bitField | 262144;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function () {\n        return (this._bitField & 262144) > 0;\n    };\n\n    Promise.prototype._getDisposer = function () {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function () {\n        this._bitField = this._bitField & (~262144);\n        this._disposer = undefined;\n    };\n\n    Promise.prototype.disposer = function (fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n        }\n        throw new TypeError();\n    };\n\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/generators.js":"\"use strict\";\nmodule.exports = function(Promise,\n                          apiRejection,\n                          INTERNAL,\n                          tryConvertToPromise) {\nvar errors = require(\"./errors.js\");\nvar TypeError = errors.TypeError;\nvar util = require(\"./util.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n        traceParent._pushContext();\n        var result = tryCatch(yieldHandlers[i])(value);\n        traceParent._popContext();\n        if (result === errorObj) {\n            traceParent._pushContext();\n            var ret = Promise.reject(errorObj.e);\n            traceParent._popContext();\n            return ret;\n        }\n        var maybePromise = tryConvertToPromise(result, traceParent);\n        if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    var promise = this._promise = new Promise(INTERNAL);\n    promise._captureStackTrace();\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n}\n\nPromiseSpawn.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = undefined;\n    this._next(undefined);\n};\n\nPromiseSpawn.prototype._continue = function (result) {\n    if (result === errorObj) {\n        return this._promise._rejectCallback(result.e, false, true);\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._promise._resolveCallback(value);\n    } else {\n        var maybePromise = tryConvertToPromise(value, this._promise);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise,\n                                        this._yieldHandlers,\n                                        this._promise);\n            if (maybePromise === null) {\n                this._throw(\n                    new TypeError(\n                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/4Y4pDk\\u000a\\u000a\".replace(\"%s\", value) +\n                        \"From coroutine:\\u000a\" +\n                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n                    )\n                );\n                return;\n            }\n        }\n        maybePromise._then(\n            this._next,\n            this._throw,\n            undefined,\n            this,\n            null\n       );\n    }\n};\n\nPromiseSpawn.prototype._throw = function (reason) {\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"])\n        .call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._next = function (value) {\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n                                      stack);\n        spawn._generator = generator;\n        spawn._next(undefined);\n        return spawn.promise();\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function (generatorFunction) {\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/nodeify.js":"\"use strict\";\nmodule.exports = function(Promise) {\nvar util = require(\"./util.js\");\nvar async = require(\"./async.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction spreadAdapter(val, nodeback) {\n    var promise = this;\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n    var ret =\n        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nfunction successAdapter(val, nodeback) {\n    var promise = this;\n    var receiver = promise._boundValue();\n    var ret = val === undefined\n        ? tryCatch(nodeback).call(receiver, null)\n        : tryCatch(nodeback).call(receiver, null, val);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\nfunction errorAdapter(reason, nodeback) {\n    var promise = this;\n    if (!reason) {\n        var target = promise._target();\n        var newReason = target._getCarriedStackTrace();\n        newReason.cause = reason;\n        reason = newReason;\n    }\n    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nPromise.prototype.asCallback =\nPromise.prototype.nodeify = function (nodeback, options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = successAdapter;\n        if (options !== undefined && Object(options).spread) {\n            adapter = spreadAdapter;\n        }\n        this._then(\n            adapter,\n            errorAdapter,\n            undefined,\n            this,\n            nodeback\n        );\n    }\n    return this;\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/call_get.js":"\"use strict\";\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = require(\"./util.js\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nvar getMethodCaller;\nvar getGetter;\nif (!false) {\nvar makeMethodCaller = function (methodName) {\n    return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n};\n\nvar makeGetter = function (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n};\n\nvar getCompiled = function(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n};\n\ngetMethodCaller = function(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n};\n\ngetGetter = function(name) {\n    return getCompiled(name, makeGetter, getterCache);\n};\n}\n\nfunction ensureMethod(obj, methodName) {\n    var fn;\n    if (obj != null) fn = obj[methodName];\n    if (typeof fn !== \"function\") {\n        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n            util.toString(methodName) + \"'\";\n        throw new Promise.TypeError(message);\n    }\n    return fn;\n}\n\nfunction caller(obj) {\n    var methodName = this.pop();\n    var fn = ensureMethod(obj, methodName);\n    return fn.apply(obj, this);\n}\nPromise.prototype.call = function (methodName) {\n    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n    if (!false) {\n        if (canEvaluate) {\n            var maybeCaller = getMethodCaller(methodName);\n            if (maybeCaller !== null) {\n                return this._then(\n                    maybeCaller, undefined, undefined, args, undefined);\n            }\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, undefined, undefined, args, undefined);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    var index = +this;\n    if (index < 0) index = Math.max(0, index + obj.length);\n    return obj[index];\n}\nPromise.prototype.get = function (propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, undefined, undefined, propertyName, undefined);\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/props.js":"\"use strict\";\nmodule.exports = function(\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\nvar util = require(\"./util.js\");\nvar isObject = util.isObject;\nvar es5 = require(\"./es5.js\");\n\nfunction PropertiesPromiseArray(obj) {\n    var keys = es5.keys(obj);\n    var len = keys.length;\n    var values = new Array(len * 2);\n    for (var i = 0; i < len; ++i) {\n        var key = keys[i];\n        values[i] = obj[key];\n        values[i + len] = key;\n    }\n    this.constructor$(values);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init = function () {\n    this._init$(undefined, -3) ;\n};\n\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val = {};\n        var keyOffset = this.length();\n        for (var i = 0, len = this.length(); i < len; ++i) {\n            val[this._values[i + keyOffset]] = this._values[i];\n        }\n        this._resolve(val);\n    }\n};\n\nPropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {\n    this._promise._progress({\n        key: this._values[index + this.length()],\n        value: value\n    });\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\n    return len >> 1;\n};\n\nfunction props(promises) {\n    var ret;\n    var castValue = tryConvertToPromise(promises);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/OsFKC8\\u000a\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(\n            Promise.props, undefined, undefined, undefined, undefined);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 4);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function () {\n    return props(this);\n};\n\nPromise.props = function (promises) {\n    return props(promises);\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/race.js":"\"use strict\";\nmodule.exports = function(\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar isArray = require(\"./util.js\").isArray;\n\nvar raceLater = function (promise) {\n    return promise.then(function(array) {\n        return race(array, promise);\n    });\n};\n\nfunction race(promises, parent) {\n    var maybePromise = tryConvertToPromise(promises);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else if (!isArray(promises)) {\n        return apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== undefined) {\n        ret._propagateFrom(parent, 4 | 1);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === undefined && !(i in promises)) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function (promises) {\n    return race(promises, undefined);\n};\n\nPromise.prototype.race = function () {\n    return race(this, undefined);\n};\n\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/reduce.js":"\"use strict\";\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL) {\nvar getDomain = Promise._getDomain;\nvar async = require(\"./async.js\");\nvar util = require(\"./util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nfunction ReductionPromiseArray(promises, fn, accum, _each) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    this._preservedValues = _each === INTERNAL ? [] : null;\n    this._zerothIsAccum = (accum === undefined);\n    this._gotAccum = false;\n    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);\n    this._valuesPhase = undefined;\n    var maybePromise = tryConvertToPromise(accum, this._promise);\n    var rejected = false;\n    var isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        maybePromise = maybePromise._target();\n        if (maybePromise._isPending()) {\n            maybePromise._proxyPromiseArray(this, -1);\n        } else if (maybePromise._isFulfilled()) {\n            accum = maybePromise._value();\n            this._gotAccum = true;\n        } else {\n            this._reject(maybePromise._reason());\n            rejected = true;\n        }\n    }\n    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;\n    var domain = getDomain();\n    this._callback = domain === null ? fn : domain.bind(fn);\n    this._accum = accum;\n    if (!rejected) async.invoke(init, this, undefined);\n}\nfunction init() {\n    this._init$(undefined, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._init = function () {};\n\nReductionPromiseArray.prototype._resolveEmptyArray = function () {\n    if (this._gotAccum || this._zerothIsAccum) {\n        this._resolve(this._preservedValues !== null\n                        ? [] : this._accum);\n    }\n};\n\nReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    values[index] = value;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var isEach = preservedValues !== null;\n    var gotAccum = this._gotAccum;\n    var valuesPhase = this._valuesPhase;\n    var valuesPhaseIndex;\n    if (!valuesPhase) {\n        valuesPhase = this._valuesPhase = new Array(length);\n        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {\n            valuesPhase[valuesPhaseIndex] = 0;\n        }\n    }\n    valuesPhaseIndex = valuesPhase[index];\n\n    if (index === 0 && this._zerothIsAccum) {\n        this._accum = value;\n        this._gotAccum = gotAccum = true;\n        valuesPhase[index] = ((valuesPhaseIndex === 0)\n            ? 1 : 2);\n    } else if (index === -1) {\n        this._accum = value;\n        this._gotAccum = gotAccum = true;\n    } else {\n        if (valuesPhaseIndex === 0) {\n            valuesPhase[index] = 1;\n        } else {\n            valuesPhase[index] = 2;\n            this._accum = value;\n        }\n    }\n    if (!gotAccum) return;\n\n    var callback = this._callback;\n    var receiver = this._promise._boundValue();\n    var ret;\n\n    for (var i = this._reducingIndex; i < length; ++i) {\n        valuesPhaseIndex = valuesPhase[i];\n        if (valuesPhaseIndex === 2) {\n            this._reducingIndex = i + 1;\n            continue;\n        }\n        if (valuesPhaseIndex !== 1) return;\n        value = values[i];\n        this._promise._pushContext();\n        if (isEach) {\n            preservedValues.push(value);\n            ret = tryCatch(callback).call(receiver, value, i, length);\n        }\n        else {\n            ret = tryCatch(callback)\n                .call(receiver, this._accum, value, i, length);\n        }\n        this._promise._popContext();\n\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (maybePromise._isPending()) {\n                valuesPhase[i] = 4;\n                return maybePromise._proxyPromiseArray(this, i);\n            } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n            } else {\n                return this._reject(maybePromise._reason());\n            }\n        }\n\n        this._reducingIndex = i + 1;\n        this._accum = ret;\n    }\n\n    this._resolve(isEach ? preservedValues : this._accum);\n};\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nPromise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/settle.js":"\"use strict\";\nmodule.exports =\n    function(Promise, PromiseArray) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = require(\"./util.js\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 268435456;\n    ret._settledValue = value;\n    this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 134217728;\n    ret._settledValue = reason;\n    this._promiseResolved(index, ret);\n};\n\nPromise.settle = function (promises) {\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function () {\n    return new SettledPromiseArray(this).promise();\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/some.js":"\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = require(\"./util.js\");\nvar RangeError = require(\"./errors.js\").RangeError;\nvar AggregateError = require(\"./errors.js\").AggregateError;\nvar isArray = util.isArray;\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function () {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(undefined, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function () {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function () {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function () {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany = function (count) {\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n    }\n\n};\nSomePromiseArray.prototype._promiseRejected = function (reason) {\n    this._addRejected(reason);\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            e.push(this._values[i]);\n        }\n        this._reject(e);\n    }\n};\n\nSomePromiseArray.prototype._fulfilled = function () {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function () {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected = function (reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled = function (value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError = function (count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray = function () {\n    this._reject(this._getRangeError(0));\n};\n\nfunction some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/1wAmHx\\u000a\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function (promises, howMany) {\n    return some(promises, howMany);\n};\n\nPromise.prototype.some = function (howMany) {\n    return some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/promisify.js":"\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = require(\"./util.js\");\nvar nodebackForPromise = require(\"./promise_resolver.js\")\n    ._nodebackForPromise;\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = require(\"./errors\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyProps = [\n    \"arity\",    \"length\",\n    \"name\",\n    \"arguments\",\n    \"caller\",\n    \"callee\",\n    \"prototype\",\n    \"__isPromisified__\"\n];\nvar noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\nvar defaultFilter = function(name) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        name !== \"constructor\";\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/iWrZbw\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (!false) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"notEnumerableProp\",\n                        \"INTERNAL\",\"'use strict';                            \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise);                      \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n        \"\n        .replace(\"Parameters\", parameterDeclaration(newParameterCount))\n        .replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode))(\n            Promise,\n            fn,\n            receiver,\n            withAppended,\n            maybeWrapAsError,\n            nodebackForPromise,\n            util.tryCatch,\n            util.errorObj,\n            util.notEnumerableProp,\n            INTERNAL\n        );\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        if (promisifier === makeNodePromisified) {\n            obj[promisifiedKey] =\n                makeNodePromisified(key, THIS, key, fn, suffix);\n        } else {\n            var promisified = promisifier(fn, function() {\n                return makeNodePromisified(key, THIS, key, fn, suffix);\n            });\n            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n            obj[promisifiedKey] = promisified;\n        }\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver) {\n    return makeNodePromisified(callback, receiver, undefined, callback);\n}\n\nPromise.promisify = function (fn, receiver) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/9ITlV0\\u000a\");\n    }\n    options = Object(options);\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/8FZo5V\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier);\n            promisifyAll(value, suffix, filter, promisifier);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier);\n};\n};\n\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/any.js":"\"use strict\";\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function (promises) {\n    return any(promises);\n};\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/each.js":"\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\n\nPromise.prototype.each = function (fn) {\n    return PromiseReduce(this, fn, null, INTERNAL);\n};\n\nPromise.each = function (promises, fn) {\n    return PromiseReduce(promises, fn, null, INTERNAL);\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/timers.js":"\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar util = require(\"./util.js\");\nvar TimeoutError = Promise.TimeoutError;\n\nvar afterTimeout = function (promise, message) {\n    if (!promise.isPending()) return;\n    \n    var err;\n    if(!util.isPrimitive(message) && (message instanceof Error)) {\n        err = message;\n    } else {\n        if (typeof message !== \"string\") {\n            message = \"operation timed out\";\n        }\n        err = new TimeoutError(message);\n    }\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._cancel(err);\n};\n\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\nvar delay = Promise.delay = function (value, ms) {\n    if (ms === undefined) {\n        ms = value;\n        value = undefined;\n        var ret = new Promise(INTERNAL);\n        setTimeout(function() { ret._fulfill(); }, ms);\n        return ret;\n    }\n    ms = +ms;\n    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);\n};\n\nPromise.prototype.delay = function (ms) {\n    return delay(this, ms);\n};\n\nfunction successClear(value) {\n    var handle = this;\n    if (handle instanceof Number) handle = +handle;\n    clearTimeout(handle);\n    return value;\n}\n\nfunction failureClear(reason) {\n    var handle = this;\n    if (handle instanceof Number) handle = +handle;\n    clearTimeout(handle);\n    throw reason;\n}\n\nPromise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret = this.then().cancellable();\n    ret._cancellationParent = this;\n    var handle = setTimeout(function timeoutTimeout() {\n        afterTimeout(ret, message);\n    }, ms);\n    return ret._then(successClear, failureClear, undefined, handle, undefined);\n};\n\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/node_modules/bluebird/js/main/filter.js":"\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function (fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function (promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-ecosystem-client/get.js":"var root = require('./root')\nvar needle = require('needle')\nmodule.exports = get;\nfunction get(url, cb) {\n  console.log(\"GET \"+url.replace(root, '[ecosystem]'))\n  needle.get(url, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/admin/plugins/plugin_manager.js":"'use strict';\n\nvar pluginPath = require('../../../plugin-path')();\n\nmodule.exports = require('strider-cli/lib/plugin_manager')(pluginPath);\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider-cli/lib/plugin_manager/index.js":"module.exports = function (pluginsPath) {\n    \n  return {\n    listLocal: function() {\n      return require('./list_local_plugins')(pluginsPath) \n    },\n    listRemote: function() {\n      return require('./list_remote_plugins')(pluginsPath) \n    },\n    createNew: function() {\n      return require('./create_new_plugin')(pluginsPath)\n    },\n    install: function(name, cb) {\n      return require('./install_plugin')(pluginsPath)(name, cb)\n    },\n    uninstall: function(name, cb) {\n      return require('./uninstall_plugin')(pluginsPath)(name, cb)\n    },\n    upgrade: function(name, cb) {\n      return require('./upgrade_plugin')(pluginsPath)(name, cb)\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/jobs/index.js":"'use strict';\n\n/*\n * routes/jobs/index.js\n */\n\nvar _ = require('lodash');\nvar common = require('../../common');\nvar debug = require('debug')('strider:routes:jobs');\nvar filter = require('../../ansi');\nvar ljobs = require('../../jobs');\nvar models = require('../../models');\nvar pjson = require('../../../package.json');\nvar utils = require('../../utils');\n\nvar Job = models.Job;\n\nmodule.exports = {\n  html: html,\n  multijob: multijob,\n  jobs: jobs\n};\n\n/*\n * GET /org/repo/[job/:job_id] - view latest build for repo\n *\n * middleware.project set \"project\" and \"accessLevel\" on the req object.\n */\nfunction multijob(req, res) {\n  var type = req.accepts('html', 'json', 'plain');\n  switch (type) {\n  case 'json':\n    return data(req, res);\n  case 'plain':\n    return output(req, res);\n  default:\n    return html(req, res);\n  }\n}\n\nfunction filterJob(job) {\n  if (job.trigger.message === 'Retest') {\n    job.trigger.message = 'Manually Retested';\n  }\n  if (job.trigger.message === 'Redeploy') {\n    job.trigger.message = 'Manually Redeployed';\n  }\n  return job;\n}\n\nfunction findJob(job) {\n  // job.runner can be undefined if it hasn't been fully prepared yet.\n  // this is a sort of race between job.prepare and job.new events.\n  // fixes https://github.com/Strider-CD/strider/issues/273\n  if (!job.runner) return;\n\n  var runner = common.extensions.runner[job.runner.id];\n  if (runner) return runner.getJobData(job._id) || {};\n}\n\n\nfunction html(req, res, next) {\n  if (req.params.org === 'auth') {\n    return next();\n  }\n\n  var id = req.params.id;\n  var projectName = req.project.name;\n\n  Job.find({project: projectName, archived: null}).sort({finished: -1}).limit(20).lean().exec(function (err, jobs) {\n    if (err) {\n      debug('[job] error finding jobs', err.message);\n      return res.status(500).send('Failed to find jobs');\n    }\n    // Use our custom sort function\n    jobs.sort(ljobs.sort);\n\n    Job.find({\n      project: projectName,\n      archived: null,\n      finished: null\n    }).sort({started: -1}).lean().exec(function (err, running) {\n      if (err) {\n        debug('[job] error finding running jobs', err.message);\n        return res.status(500).send('Failed to find running jobs');\n      }\n      var i;\n      for (i = 0; i < running.length; i++) {\n        _.extend(running[i], findJob(running[i]));\n        delete running[i].data;\n        delete running[i].id;\n      }\n      jobs = running.concat(jobs);\n\n      var showStatus = {};\n      var sanitized = utils.sanitizeProject(req.project);\n      sanitized.access_level = req.accessLevel;\n      req.project.branches.forEach(function (branch) {\n        var plugins = showStatus[branch.name] = {};\n        branch.plugins.forEach(function (plugin) {\n          plugins[plugin.id] = plugin.enabled && plugin.showStatus;\n        });\n      });\n\n      var job = id ? null : jobs[0];\n      for (i = 0; i < jobs.length; i++) {\n        if (!job && jobs[i]._id === id) job = jobs[i];\n        jobs[i] = ljobs.small(jobs[i]);\n        jobs[i] = filterJob(jobs[i]);\n        jobs[i].project = sanitized;\n      }\n      if (job) {\n        job.status = ljobs.status(job);\n        job.project = sanitized;\n      }\n\n      var isGlobalAdmin = req.user && req.user.account_level > 0;\n      var canAdminProject = sanitized.access_level > 0 || isGlobalAdmin;\n\n      // Make sure jobs are only listed once.\n      jobs = _.uniqBy(jobs, job => job._id.toString());\n\n      res.format({\n        html: function () {\n          debug('Build page requested. Logging jobs to investigate duplicate job listings.');\n          debug(jobs);\n          res.render('build.html', {\n            project: sanitized,\n            accessLevel: req.accessLevel,\n            canAdminProject: canAdminProject,\n            jobs: jobs,\n            job: job,\n            statusBlocks: common.statusBlocks,\n            showStatus: showStatus,\n            page_base: `${req.params.org}/${req.params.repo}`,\n            version: pjson.version\n          });\n        },\n        json: function () {\n          res.send({\n            project: sanitized,\n            accessLevel: req.accessLevel,\n            canAdminProject: canAdminProject,\n            jobs: jobs,\n            job: job\n          });\n        }\n      });\n    });\n  });\n}\n\nfunction getJob(req, res, next) {\n  var query;\n  if (!req.params.job_id) {\n    query = Job.findOne({project: req.project.name.toLowerCase(), archived: null}, {}, {sort: {finished: -1}});\n  } else {\n    query = Job.findOne({project: req.project.name.toLowerCase(), _id: req.params.job_id, archived: null});\n  }\n  query.exec(function (err, job) {\n    if (err || !job) return res.status(404).send('Failed to find job');\n    job = filterJob(job);\n    if (!job.finished) {\n      _.extend(job, findJob(job));\n    }\n    next(job);\n  });\n}\n\nfunction output(req, res) {\n  getJob(req, res, function (job) {\n    res.setHeader('Content-type', 'text/plain');\n    res.send(job.std.merged ? filter(job.std.merged) : '');\n  });\n}\n\nfunction data(req, res) {\n  getJob(req, res, function (job) {\n    res.setHeader('Content-type', 'application/json');\n    res.send(job);\n  });\n}\n\nfunction jobs(req, res) {\n  Job.find({project: req.project.name.toLowerCase(), archived: null})\n    .sort({finished: -1}).limit(20).lean()\n    .exec(function (err, jobs) {\n      if (err) return res.status(500).send('Failed to retrieve jobs');\n      res.send(JSON.stringify(jobs.map(function (j) {\n        return filterJob(j);\n      })));\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/ansi.js":"'use strict';\n\nvar ansi_up = require('ansi_up');\n\n// Copy of client/ansi/filters/ansi.js\nmodule.exports = function (input, plaintext) {\n  if (!input) return '';\n  if (input.length > 100000) return input;\n  // handle the characters for \"delete line\" and \"move to start of line\"\n  var startswithcr = /^[^\\n]*\\r[^\\n]/.test(input);\n\n  input = input.replace(/^[^\\n\\r]*\\u001b\\[2K/gm, '')\n    .replace(/\\u001b\\[K[^\\n\\r]*/g, '')\n    .replace(/[^\\n]*\\r([^\\n])/g, '$1')\n    .replace(/^[^\\n]*\\u001b\\[0G/gm, '');\n\n  if (startswithcr) input = `\\r${input}`;\n  if (plaintext) return ansi_up.ansi_to_text(input);\n\n  return ansi_up.ansi_to_html(ansi_up.escape_for_html(input));\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/api/index.js":"'use strict';\n\nvar express = require('express');\nvar router = new express.Router();\n\nrouter.use('/account', require('./account'));\nrouter.use('/admin', require('./admin'));\nrouter.use('/session', require('./session'));\n\nmodule.exports = router;\n\n\n// Globals & Commons for ApiDoc ..\n\n/**\n * @apiDefine RequestUrl Request URL Parameters\n *  Indicates that this parameter should be specified in the request URL.\n */\n\n/**\n * @apiDefine RequestBody Request Body Parameters\n *  Indicates that this parameter should be specified in the request body.\n */\n\n/**\n * @apiDefine ProjectAdmin\n *  You must have admin privileges on the corresponding RepoConfig to be able to use this endpoint.\n */\n\n/**\n * @apiDefine GlobalAdmin\n *  You must have admin privileges in Strider (globally) in order to use this endpoint.\n */\n\n/**\n * @apiDefine ProjectReference\n *\n * @apiParam (RequestUrl) {String} org The organization name for the project.  This is\n * usually a GitHub user or organization name (e.g. \"strider\" in \"strider-cd/strider\")\n * but may vary from one project provider to another. (as another example,\n * in GitLab this refers to the repository's \"group\").\n * @apiParam (RequestUrl) {String} repo The project's repository name.\n */\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/api/account.js":"'use strict';\n\nvar auth = require('../../auth');\nvar debug = require('debug')('strider:routes:api:account');\nvar email = require('../../email');\nvar express = require('express');\nvar models = require('../../models');\nvar Project = models.Project;\nvar router = express.Router();\nvar User = models.User;\nvar validator = require('validator');\n\nrouter.use(auth.requireUserOr401);\n\nrouter.route('/:provider/:id')\n\n/**\n * @api {put} /account/:provider/:id Update Provider Account\n * @apiDescription Updates a provider account for the _active_ user (the API user).\n * @apiName UpdateAccount\n * @apiGroup Account\n * @apiVersion 1.0.0\n *\n * @apiParam {String} provider Type of provider, e.g. github\n * @apiParam {Number} id Unique provider identification\n */\n  .put(function (req, res) {\n    var accounts = req.user.accounts;\n    var provider = req.params.provider;\n    var id = req.params.id;\n\n    for (var i = 0; i < accounts.length; i++) {\n      if (accounts[i].provider === provider &&\n        accounts[i].id === id) {\n        // TODO validate these accounts\n        accounts[i] = req.body;\n\n        return User.update({_id: req.user._id}, {$set: {accounts: accounts}}, function (err) {\n          if (err) {\n            debug(err);\n            return res.status(500).send('Failed to save one user');\n          }\n\n          res.sendStatus(200);\n        });\n      }\n    }\n\n    accounts.push(req.body);\n\n    User.update({_id: req.user._id}, {$set: {accounts: accounts}}, function (err) {\n      if (err) {\n        debug(err);\n        return res.status(500).send('Failed to save one user');\n      }\n\n      res.sendStatus(200);\n    });\n  })\n\n  /**\n   * @api {delete} /account/:provider/:id Delete Provider Account\n   * @apiDescription Deletes a provider account for the _active_ user (the API user).\n   * @apiName DeleteAccount\n   * @apiGroup Account\n   * @apiVersion 1.0.0\n   *\n   * @apiParam {String} provider Type of provider, e.g. github\n   * @apiParam {Number} id Unique provider identification\n   */\n  .delete(function (req, res) {\n    var accounts = req.user.accounts;\n    var provider = req.params.provider;\n    var id = req.params.id;\n    var accountRemoved = false;\n\n    Project.find({'provider.id': provider})\n      .lean()\n      .exec(function (err, projects) {\n        if (err) {\n          return res.status(400).send('Failed do to bad data');\n        }\n\n        if (projects.length) {\n          var projectNames = projects.map(function (project) {\n            return project.name;\n          });\n          return res.status(403)\n            .send(`Cannot delete provider since projects are using this provider: ${projectNames.join(', ')}`);\n        } else {\n          accounts.forEach(function (account, index) {\n            if (account.provider === provider && account.id === id) {\n              accounts.splice(index, 1);\n              accountRemoved = true;\n            }\n          });\n\n          if (accountRemoved) {\n            return req.user.save(function (err) {\n              if (err) {\n                return res.status(500).send('Failed to save user');\n              }\n\n              res.sendStatus(204);\n            });\n          }\n\n          res.status(404).send('Account not found');\n        }\n      });\n  });\n\nrouter.route('/password')\n\n/**\n * @api {post} /account/password Change Password\n * @apiDescription Changes the password for the _active_ user (the API user).\n * @apiName ChangePassword\n * @apiGroup Account\n * @apiVersion 1.0.0\n *\n * @apiParam (RequestBody) {String{6..}} password The new password, which must be at least 6 characters long.\n */\n  .post(function (req, res) {\n    if (req.user !== undefined) {\n      debug(`password change by ${req.user.email}`);\n    }\n\n    if (req.user.isAdUser) {\n      return res.status(400).json({\n        status: 'error',\n        errors: [{message: 'The ldap user can not change password.'}]\n      });\n    }\n    var password = req.body.password;\n\n    if (password.length < 6) {\n      return res.status(400).json({\n        status: 'error',\n        errors: [{message: 'password must be at least 6 characters long'}]\n      });\n    }\n\n    req.user.password = password;\n\n    req.user.save(function (err) {\n      if (err) {\n        throw err;\n      }\n\n      email.notifyPasswordChange(req.user);\n\n      res.json({\n        status: 'ok',\n        errors: []\n      });\n    });\n  });\n\n\nrouter.route('/email')\n\n/**\n * @api {post} /account/email Change Email\n * @apiDescription Changes the email address for the _active_ user (the API user).\n * @apiName ChangeEmail\n * @apiGroup Account\n * @apiVersion 1.0.0\n *\n * @apiParam (RequestBody) {String} email The new email address. This must be a VALID email address.\n */\n  .post(function (req, res) {\n    var newEmail = req.body.email;\n\n    if (!validator.isEmail(newEmail)) {\n      return res.status(400).json({\n\n        status: 'error',\n        errors: [{message: 'email is invalid'}]\n      });\n    }\n\n    debug(`email change from ${req.user.email} to ${newEmail}`);\n\n    if (req.user.isAdUser) {\n      return res.status(400).json({\n        status: 'error',\n        errors: [{message: 'The ldap user can not change email.'}]\n      });\n    }\n\n    var oldEmail = req.user.email;\n    req.user.email = newEmail;\n\n    req.user.save(function (err) {\n      if (err) {\n        return res.status(400).json({\n          status: 'error',\n          errors: [{message: 'email already in use'}]\n        });\n      }\n\n      email.notifyEmailChange(req.user, oldEmail);\n      res.json({status: 'ok', errors: []});\n    });\n  });\n\nmodule.exports = router;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/api/admin/index.js":"'use strict';\n\nvar auth = require('../../../auth');\nvar debug = require('debug')('strider:routes:api:admin');\nvar email = require('../../../email');\nvar express = require('express');\nvar requireBody = require('../../../utils/require-body');\nvar router = new express.Router();\nvar InviteCode = require('../../../models').InviteCode;\nvar User = require('../../../models').User;\n\nrouter.use(auth.requireAdminOr401);\n\n/**\n * @api {get} /admin/users Get All Users\n * @apiPermission GlobalAdmin\n * @apiDescription Retrieves a list of all Strider users.\n * @apiName GetUsers\n * @apiGroup Admin\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X GET http://localhost/admin/users\n */\nrouter.route('/users')\n  .get(function (req, res) {\n    var users = [];\n\n    User.find({}).sort({email: 1}).exec(function (err, results) {\n      results.forEach(function (user) {\n        users.push({\n          id: user.id,\n          email: user.email\n        });\n      });\n\n      res.json(users);\n    });\n  });\n\n/**\n * @apiIgnore\n * @api {get} /admin/jobs Get Job Status\n * @apiPermission GlobalAdmin\n * @apiDescription Returns a JSON object of the last 100 jobs executed.\n * @apiName GetJobs\n * @apiGroup Admin\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X GET http://localhost/admin/jobs\n */\nrouter.route('/jobs')\n  .get(function (req, res) {\n    res.status(500).send('Not yet implemented');\n  });\n\n/**\n * @api {post} /admin/invite/new Send Invite\n * @apiPermission GlobalAdmin\n * @apiDescription Create & email a new Strider invite.\n * @apiName SendInvite\n * @apiGroup Admin\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X POST -d invite_code=xoxox -d email=new_guy@strider-cd.com http://localhost/invite/new\n *\n * @apiParam (RequestBody) {String} invite_code The invite code/token to use in the invitation\n * @apiParam (RequestBody) {String} email The email address of the new user being invited\n */\nrouter.route('/invite/new')\n  .post(function (req, res) {\n    var inviteCode = requireBody('invite_code', req, res);\n    var emailAddr = requireBody('email', req, res);\n\n    if (inviteCode === undefined || emailAddr === undefined) {\n      return;\n    }\n\n    var invite = new InviteCode();\n\n    invite.code = inviteCode;\n    invite.created_timestamp = new Date();\n    invite.emailed_to = emailAddr;\n\n    invite.save(function (err, invite) {\n      email.sendInvite(invite.code, emailAddr);\n      res.redirect('/admin/invites');\n    });\n  });\n\n/**\n * @api {post} /admin/invite/revoke Revoke Invite\n * @apiPermission GlobalAdmin\n * @apiDescription Revokes a previously sent Strider invitation.\n * @apiName RevokeInvite\n * @apiGroup Admin\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X POST -d invite_code=xoxox http://localhost/invite/revoke\n *\n * @apiParam (RequestBody) {String} invite_code The invite code/token of the invite\n * being revoked.\n */\nrouter.route('/invite/revoke')\n  .post(function (req, res) {\n    var inviteCode = requireBody('invite_code', req, res);\n\n    InviteCode.remove({code: inviteCode, consumed_timestamp: {$exists: false}}, function (err) {\n      if (err) {\n        debug(err);\n        return res.status(500).send('Error revoking invite');\n      }\n\n      email.revokeInvite(inviteCode);\n      res.redirect('/admin/invites');\n    });\n  });\n\nmodule.exports = router;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/utils/require-body.js":"'use strict';\n\n\n/*\n * Require a request parameter is present or return a 400 response.\n */\nfunction requireBody(key, req, res) {\n  var val = req.body[key];\n\n  if (val === undefined) {\n    return res.status(400).json({\n      status: 'error',\n      errors: [`you must supply parameter ${key}`]\n    });\n  }\n\n  return val;\n}\n\nmodule.exports = requireBody;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/api/session.js":"'use strict';\n\nvar express = require('express');\nvar models = require('../../models');\nvar router = new express.Router();\nvar User = models.User;\n\nrouter.route('/')\n  /**\n   * @api {get} /api/session Get Session\n   * @apiDescription Gets the current session information\n   * @apiName GetSession\n   * @apiGroup Session\n   * @apiVersion 1.0.0\n   *\n   * @apiExample {curl} CURL Example:\n   *    curl -X GET http://localhost/api/session\n   */\n  .get(function getSession(req, res) {\n    res.send({ user: req.user });\n  })\n\n  /**\n   * @api {post} /api/session Create New Session\n   * @apiDescription Creates a new user session after validating an email address and password pair.\n   * @apiName CreateSession\n   * @apiGroup Session\n   * @apiVersion 1.0.0\n   *\n   * @apiExample {curl} CURL Example:\n   *    curl -X POST -d email=me@me.com -d password=mypass http://localhost/api/session\n   *\n   * @apiParam (RequestBody) {String} email The email address to login as (which is used as the username).\n   * @apiParam (RequestBody) {String} password The user's password.\n   */\n  .post(function createSession(req, res) {\n    User.authenticate(req.body.email, req.body.password, function (err, user) {\n      if (!user) {\n        res.status(404).send({message: 'No such username / password'});\n      } else {\n        if (!req.session.passport) {\n          req.session.passport = {};\n        }\n        req.session.passport.user = user.id;\n        res.send(user);\n      }\n    });\n  });\n\n\nmodule.exports = router;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/collaborators/index.js":"'use strict';\n\nvar _ = require('lodash');\nvar express = require('express');\nvar middleware = require('../../middleware');\nvar auth = require('../../auth');\nvar models = require('../../models');\nvar utils = require('../../utils');\nvar api = require('./api');\nvar router = new express.Router();\nvar User = models.User;\n\nrouter.route('/:org/:repo/collaborators/')\n.all(\n  auth.requireUserOr401,\n  middleware.project,\n  auth.requireProjectAdmin\n)\n\n/**\n * @api {get} /:org/:repo/collaborators Get Collaborators\n * @apiUse ProjectReference\n * @apiDescription Gets a list of collaborators for a project\n * @apiName GetCollaborators\n * @apiGroup Collaborators\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X GET http://localhost/api/strider-cd/strider/collaborators\n */\n.get(function getCollab(req, res) {\n  var project = `${req.params.org}/${req.params.repo}`;\n\n  User.collaborators(project, 0, function (err, users) {\n    if (err) return res.status(500).send(`Failed to get users: ${err.message}`);\n    var results = [];\n    for (var i = 0; i < users.length; i++) {\n      var p = _.find(users[i].projects, function (p) {\n        return p.name === project.toLowerCase();\n      });\n\n      results.push({\n        type: 'user',\n        id: users[i]._id,\n        email: users[i].email,\n        access_level: p.access_level,\n        gravatar: utils.gravatar(users[i].email)\n      });\n    }\n    res.send(results);\n  });\n})\n\n/**\n * @api {post} /:org/:repo/collaborators Add Collaborator\n * @apiUse ProjectReference\n * @apiPermission ProjectAdmin\n * @apiDescription Add a new collaborator to a repository/project.\n * @apiName AddCollaborator\n * @apiGroup Collaborators\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *  curl -X GET -d '{\"email\":\"new_guy@strider-cd.com\", \"access\":2}' http://localhost/api/strider-cd/strider/collaborators\n *\n * @apiParam (RequestBody) {String} email Email address to add. If the user is\n *  not registered with Strider, we will send them an invite. If they are already\n *  registered, they will receive a notification of access.\n * @apiParam (RequestBody) {Number} access=0 Access level to grant to the\n *  new collaborator. This can be `0`, for read only access, or `2` for admin access.\n */\n.post(middleware.requireBody(['email']), function addCollab(req, res) {\n  var project = `${req.params.org}/${req.params.repo}`;\n  var accessLevel = req.body.access || 0;\n  var email = req.body.email;\n\n  api.add(project, email, accessLevel, req.user, function (err, existed, alreadyInvited) {\n    if (err) return res.status(500).send(`Failed to add collaborator: ${err.message}`);\n    if (existed) return res.send({created: true, message: 'Collaborator added'});\n\n    if (!alreadyInvited) return res.send({\n      created: false,\n      message: `An invite was sent to ${email}. They will become a collaborator when they create an account.`\n    });\n\n    res.send({\n      created: false,\n      message: `An invitation email has already been sent to ${email}. They will become a collaborator when they create an account.`\n    });\n  });\n})\n\n/**\n * @api {delete} /:org/:repo/collaborators Delete Collaborator\n * @apiUse ProjectReference\n * @apiPermission ProjectAdmin\n * @apiDescription Remove a collaborator from a repository/project.\n * @apiName DeleteCollaborator\n * @apiGroup Collaborators\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X DELETE -d '{\"email\":\"old_guy@strider-cd.com\"}' http://localhost/api/strider-cd/strider/collaborators\n *\n * @apiParam (RequestBody) {String} email Email address to remove from the repo/project.\n */\n.delete(middleware.requireBody(['email']), function delCollab(req, res) {\n  var project = `${req.params.org}/${req.params.repo}`;\n  var email = req.body.email;\n\n  if (req.project.creator.email.toLowerCase() === email.toLowerCase()) {\n    return res.status(400).send('Cannot remove the project creator');\n  }\n\n  if (req.user.email.toLowerCase() === email.toLowerCase()) {\n    return res.status(400).send('Cannot remove yourself');\n  }\n\n  api.del(project, email, function (err) {\n    if (err) return res.status(500).send(err.message);\n    res.send({status: 'removed'});\n  });\n});\n\nmodule.exports = router;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/collaborators/api.js":"'use strict';\n\nvar _ = require('lodash');\nvar crypto = require('crypto');\nvar base32 = require('thirty-two');\nvar mail = require('../../email');\nvar models = require('../../models');\nvar User = models.User;\nvar InviteCode = models.InviteCode;\n\nmodule.exports = {\n  add: add,\n  del: del\n};\n\nfunction updateInvite(invite, collaboration, done) {\n  var found = _.find(invite.collaborations, function (c) {\n    return c.project === collaboration.project;\n  });\n  // There is already an outstanding invite to this user, just push these additional perms onto the collaborations\n  // list and send another email. We only push if they have not already been added to the invite.\n  if (!found) {\n    invite.update({$push: {collaborations: collaboration}}, function (err) {\n      if (err) return done(err);\n      // Invite updated, should probably send another email to recipient.\n      return done(null, false, false);\n    });\n  } else {\n    return done(null, false, true);\n  }\n}\n\nfunction sendInvite(inviter, email, collaboration, done) {\n  var random = crypto.randomBytes(5).toString('hex');\n  var invite_code = base32.encode(random);\n  var invite = new InviteCode({\n    code: invite_code,\n    emailed_to: email,\n    created_timestamp: new Date(),\n    collaborations: [collaboration]\n  });\n\n  invite.save(function (err) {\n    if (err) return done(err);\n    // Invite created, send email to recipient.\n    mail.sendInviteCollaboratorNewUser(inviter, email, invite_code, collaboration.project);\n    return done(null, false, false);\n  });\n\n}\n\n// done(err, userExisted, inviteExisted)\nfunction add(project, email, accessLevel, inviter, done) {\n  User.findOne({email: email}, function (err, user) {\n    if (err) {\n      return done(err);\n    }\n\n    if (user) {\n      var p = _.find(user.projects, function (p) {\n        return p.name === project.toLowerCase();\n      });\n      if (p) {\n        return done('user already a collaborator', true);\n      }\n      User.update({email: email}, {\n        $push: {\n          'projects': {\n            name: project.toLowerCase(),\n            display_name: project,\n            access_level: accessLevel\n          }\n        }\n      }, function (err) {\n        if (err) return done(err, true);\n        done(null, true);\n      });\n    } else {\n      var collaboration = {\n        project: project,\n        invited_by: inviter._id,\n        access_level: accessLevel\n      };\n      InviteCode.findOne({emailed_to: email, consumed_timestamp: null}, function (err, invite) {\n        if (err) return done(err);\n        if (invite) {\n          return updateInvite(invite, collaboration, done);\n        }\n        sendInvite(inviter, email, collaboration, done);\n      });\n    }\n  });\n}\n\nfunction del(project, email, done) {\n  User.update({email: email, 'projects.name': project.toLowerCase()},\n    {$pull: {'projects': {'name': project.toLowerCase()}}}, done);\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/api/branches.js":"'use strict';\n\nvar express = require('express');\nvar Project = require('../../models').Project;\nvar middleware = require('../../middleware');\nvar router = express.Router();\nvar requireBody = middleware.requireBody;\nvar root = router.route('/');\n\n/**\n * @api {post} /:org/:repo/branches Add Branch\n * @apiUse ProjectReference\n * @apiPermission ProjectAdmin\n * @apiDescription Add a new branch for a project.\n * @apiName AddBranch\n * @apiGroup Branch\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X POST -d name=newbranch http://localhost/api/strider-cd/strider/branches\n *\n * @apiParam (RequestBody) {String} name The name of the new branch\n * @apiParam (RequestBody) {String} cloneName The name of the cloned branch\n */\nroot.post(requireBody(['name']), function (req, res) {\n  if (req.body.cloneName) {\n    req.project.cloneBranch(req.body.name, req.body.cloneName, function (err, branch) {\n      res.send({created: true, message: 'Branch cloned', branch: branch});\n    });\n  } else {\n    req.project.addBranch(req.body.name, function (err, branch) {\n      if (err) return res.status(500).send(err.message);\n      res.send({created: true, message: 'Branch added', branch: branch});\n    });\n  }\n});\n\n/**\n * @api {put} /:org/:repo/branches Reorder Branches\n * @apiUse ProjectReference\n * @apiPermission ProjectAdmin\n * @apiDescription Updates the branch order for a project.\n * @apiName ReorderBranches\n * @apiGroup Branch\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X PUT -d branches=master,testing http://localhost/api/strider-cd/strider/branches\n *\n * @apiParam (RequestBody) {String} branches The new branch order, comma delimited\n */\nroot.put(requireBody(['branches']), function (req, res) {\n  var branches = req.body.branches;\n  var query = {_id: req.project._id};\n  var update = {'$set': {branches: branches}};\n\n  Project.update(query, update, function (err) {\n    if (err) return res.status(500).send(err.message);\n\n    res.send({status: 'updated', message: 'Branch order updated'});\n  });\n});\n\n/**\n * @api {delete} /:org/:repo/branches Delete Branch\n * @apiUse ProjectReference\n * @apiPermission ProjectAdmin\n * @apiDescription Deletes a branch from a project\n * @apiName DeleteBranch\n * @apiGroup Branch\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X DELETE -d name=mybranch http://localhost/api/strider-cd/strider/branches\n *\n * @apiParam (RequestBody) {String} name The name of the branch to delete\n */\nroot.delete(requireBody(['name']), function (req, res) {\n  var name = req.body.name;\n  var query = {_id: req.project._id};\n  var update = {'$pull': {branches: {name: name}}};\n\n  if (name.toLowerCase() === 'master') {\n    return res.status(400).send('Cannot remove the master branch');\n  }\n\n  Project.update(query, update, function (err) {\n    if (err) return res.status(500).send(err.message);\n    res.send({status: 'removed'});\n  });\n\n});\n\nmodule.exports = router;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/api/jobs.js":"'use strict';\n\nvar common = require('../../common');\nvar debug = require('debug')('strider:routes:api:jobs');\nvar jobs = require('../../jobs');\nvar utils = require('../../utils');\n\nvar TEST_ONLY = 'TEST_ONLY';\nvar TEST_AND_DEPLOY = 'TEST_AND_DEPLOY';\n\n/**\n * @api {post} /:org/:repo/start Start Job\n * @apiUse ProjectReference\n * @apiDescription Executes a strider test and, optionally, deployment.\n * @apiName StartJob\n * @apiGroup Job\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X POST http://localhost/api/strider-cd/strider/start\n *\n * @apiParam (RequestBody) {String} type=\"TEST_ONLY\" Denotes the type of job to run.\n * This can be \"TEST_ONLY\", which indicates that only the test stages of the job should\n * be executed or \"TEST_AND_DEPLOY\", which indicates that all stages should be executed.\n * @apiParam (RequestBody) {String} branch=\"master\" Indicates which branch configuration\n * should be executed.\n * @apiParam (RequestBody) {String} message=\"Manually Retesting/Redeploying\" An\n * optional message to include as the title of the execution.\n */\nexports.jobsStart = function (req, res) {\n  var type = req.body.type || TEST_ONLY;\n  var branch = req.body.branch || 'master';\n  var message = req.body.message;\n  var now = new Date();\n  var trigger;\n  var job;\n  var Project = common.context.models.Project;\n\n  Project.findOne({name: req.project.name}, function (err, project) {\n    if (err || !project) {\n      return res.json(404);\n    }\n\n    trigger = {\n      type: 'manual',\n      author: {\n        id: req.user._id,\n        email: req.user.email,\n        image: utils.gravatar(req.user.email)\n      },\n      timestamp: now,\n      source: {type: 'UI', page: req.body.page || 'unknown'}\n    };\n\n\n    if (message) {\n      trigger.message = message;\n    } else {\n      if (type === TEST_AND_DEPLOY)\n        trigger.message = 'Manually Redeploying';\n      else\n        trigger.message = 'Manually Retesting';\n    }\n\n    job = {\n      type: type,\n      user_id: req.user._id,\n      project: req.project.name,\n      ref: {branch: branch},\n      trigger: trigger,\n      created: now\n    };\n    common.emitter.emit('job.prepare', job);\n    res.json(job);\n  });\n\n\n};\n\n/**\n * @api {get} /api/jobs Get Latest Jobs\n * @apiDescription Return JSON object containing the most recent build status for each configured repo\n * This function is used to build the main dashboard status page.\n * The result is separated into `{public: [], yours: []}`.\n *\n * Note: the private ones are just ones that the current user is a collaborator\n * on and are not necessarily private\n * @apiName GetJobs\n * @apiGroup Job\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X GET http://localhost/api/jobs\n */\nexports.jobs = function (req, res) {\n  debug('api.jobs');\n  res.setHeader('Content-Type', 'application/json');\n  res.statusCode = 200;\n\n  jobs.latestJobs(req.user, function (err, jobs) {\n    res.send(JSON.stringify(jobs, null, '\\t'));\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/api/repo.js":"'use strict';\n\n/*\n * Repo-specific actions - such as deactivation, deletion etc.\n * routes/api/repo.js\n */\n\nvar async = require('async');\nvar common = require('../../common');\nvar debug = require('debug')('strider:routes:api:repo');\nvar Job = require('../../models').Job;\nvar Project = require('../../models').Project;\nvar ssh = require('./../../ssh');\nvar User = require('../../models').User;\nvar utils = require('../../utils');\n\nfunction makePlugins(plugins) {\n  var configs = [];\n  var plugin;\n\n  for (var i = 0; i < plugins.length; i++) {\n    plugin = common.extensions.job[plugins[i]];\n\n    if (!plugin) return false;\n\n    var config = utils.defaultSchema(plugin);\n\n    configs.push({\n      id: plugins[i],\n      enabled: true,\n      config: config\n    });\n  }\n\n  return configs;\n}\n\n/**\n * @api {delete} /:org/:repo/cache Clear Cache\n * @apiUse ProjectReference\n * @apiPermission ProjectAdmin\n * @apiDescription Clears/invalidates the cache for a project.\n * @apiName ClearCache\n * @apiGroup Repo\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X DELETE http://localhost/api/strider-cd/strider/cache\n */\nexports.clearCache = function (req, res) {\n  clearProjectCache(req.project, function (err, result) {\n    if (err) {\n      return res.status(500).send('failed to clear cache');\n    }\n\n    if (result) {\n      res.send(result);\n    } else {\n      res.sendStatus(204);\n    }\n  });\n};\n\nfunction clearProjectCache(project, cb) {\n  var runners = [];\n  var tasks = [];\n\n  project.branches.forEach(function (branch) {\n    var nonMasterMirrored = branch.name !== 'master' && branch.mirror_master;\n\n    if (nonMasterMirrored || runners.indexOf(branch.runner.id) !== -1) {\n      return;\n    }\n\n    runners.push(branch.runner.id);\n  });\n\n  runners.forEach(function (rid) {\n    var runner = common.extensions.runner[rid];\n\n    debug(rid, common.extensions.runner, project);\n    if (!runner || !runner.clearCache) return;\n    tasks.push(runner.clearCache.bind(runner, project));\n  });\n\n  if (!tasks.length) {\n    return cb(undefined, 'No runners supported cache clearing');\n  }\n\n  async.parallel(tasks, cb);\n}\n\n/**\n * @api {put} /:org Create Repo\n * @apiDescription Create a new project for a repo.\n * @apiName CreateRepo\n * @apiGroup Repo\n * @apiVersion 1.0.0\n *\n * @apiParam (RequestBody) {String} name The name of the new branch\n * @apiParam (RequestBody) {String} display_name Human-readable project name\n * @apiParam (RequestBody) {String} display_url The URL for the repo (e.g. Github homepage)\n * @apiParam (RequestBody) {Boolean} public=false Whether this project is public or not.\n * @apiParam (RequestBody) {Boolean} prefetch_config=true Whether the strider.json should be fetched in advance.\n * @apiParam (RequestBody) {String} account The ID of provider account\n * @apiParam (RequestBody) {String} repo_id The ID of the repo\n * @apiParam (RequestBody) {Object} provider A json object with 'id' and 'config' properties.\n */\nexports.createProject = function (req, res, next) {\n  if (req.params.org === 'auth') {\n    return next();\n  }\n\n  var name = `${req.params.org}/${req.params.repo}`;\n  debug(`Setting up new project \"${name}\"...`);\n\n  var display_name = req.body.display_name;\n  var display_url = req.body.display_url;\n  var isPublic = req.body.public === 'true' || req.body.public === '1';\n  var prefetch_config = true;\n  var project_type = req.body.project_type || 'node.js';\n  if (req.body.prefetch_config === 'false' || req.body.prefetch_config === '0') {\n    prefetch_config = false;\n  }\n  var provider = req.body.provider;\n\n  function error(code, str) {\n    return res.status(code).json({\n      results: [],\n      status: 'error',\n      errors: [{code: code, reason: str}]\n    });\n  }\n\n  if (!display_name) {\n    return error(400, 'display_name is required');\n  }\n\n  if (!provider || !provider.id) {\n    return error(400, 'provider.id is required');\n  }\n\n  if (common.extensions.provider[provider.id].hosted) {\n    if (!provider.account) {\n      return error(400, 'provider.account is required');\n    }\n\n    if (!provider.repo_id) {\n      return error(400, 'provider.repo_id is required');\n    }\n  }\n\n  if (!provider.config) {\n    provider.config = utils.defaultSchema(provider.config);\n  }\n\n  if (!common.project_types[project_type]) {\n    return error(400, 'Invalid project type specified');\n  }\n\n  var plugins = makePlugins(common.project_types[project_type].plugins);\n  if (!plugins) {\n    return error(400, 'Project type specified is not available; one or more required plugins is not installed');\n  }\n\n  function projectResult(err, project) {\n    if (project) {\n      debug(`User ${req.user.email} tried to create project for repo ${name}, but it already exists`);\n\n      return error(409, 'project already exists');\n    }\n\n    return ssh.generateKeyPair(`${name}-${req.user.email}`, createProjectWithKey);\n  }\n\n  function createProjectWithKey(err, privkey, pubkey) {\n    if (err) return error(500, 'Failed to generate ssh keypair');\n\n    var project = {\n      name: name,\n      display_name: display_name,\n      display_url: display_url,\n      public: isPublic,\n      prefetch_config: prefetch_config,\n      creator: req.user._id,\n      provider: provider,\n      branches: [\n        {\n          name: 'master',\n          active: true,\n          mirror_master: false,\n          deploy_on_green: true,\n          deploy_on_pull_request: false,\n          pubkey: pubkey,\n          privkey: privkey,\n          plugins: plugins,\n          runner: {\n            id: 'simple-runner',\n            config: {pty: false}\n          }\n        },\n        {\n          name: '*',\n          mirror_master: true\n        }\n      ]\n    };\n\n    var plugin = common.extensions.provider[provider.id];\n    if (!plugin.hosted || !plugin.setupRepo) {\n      return Project.create(project, projectCreated);\n    }\n\n    debug(`Setting up repository \"${project.name}\" with provider \"${provider.id}\"...`);\n    plugin.setupRepo(req.user.account(provider).config, provider.config, project, function (err, config) {\n      if (err) {\n        debug(`Setting up repository \"${project.name}\" failed!`, err.status, err.message);\n        return error(500, `Failed to setup repo: ${err.message}`);\n      }\n      project.provider.config = config;\n      Project.create(project, projectCreated);\n    });\n  }\n\n  function projectCreated(err, p) {\n    if (err) {\n      debug(`Error creating repo ${name} for user ${req.user.email}: ${err}`);\n      debug(err.stack);\n      return error(500, 'internal server error');\n    }\n    // Project object created, add to User object\n    User.update({_id: req.user._id}, {\n      $push: {\n        projects: {\n          name: name,\n          display_name: p.display_name,\n          access_level: 2\n        }\n      }\n    }, function (err, num) {\n      if (err || !num) debug('Failed to give the creator repo access...');\n\n      return res.json({\n        project: {\n          _id: p._id,\n          name: p.name,\n          display_name: p.display_name\n        },\n        results: [{code: 200, message: 'project created'}],\n        status: 'ok',\n        errors: []\n      });\n    });\n  }\n\n  name = name.toLowerCase().replace(/ /g, '-');\n  Project.findOne({name: name}, projectResult);\n};\n\n/**\n * @api {delete} /:org/:repo Delete Repo\n * @apiUse ProjectReference\n * @apiPermission ProjectAdmin\n * @apiDescription Deletes a repository/project. Also archives all jobs (marks as archived in DB which makes them hidden).\n * @apiName DeleteRepo\n * @apiGroup Repo\n * @apiVersion 1.0.0\n *\n * @apiExample {curl} CURL Example:\n *    curl -X DELETE http://localhost/api/strider-cd/strider\n */\nexports.deleteProject = function (req, res) {\n  async.parallel([\n    function (next) {\n      var provider = req.project.provider;\n      var plugin = common.extensions.provider[provider.id];\n      if (!plugin.hosted || !plugin.teardownRepo) return next();\n      plugin.teardownRepo(req.project.creator.account(provider).config, provider.config, req.project, function (err) {\n        if (err) debug('Error while tearing down repo', req.project.name, provider.id, err);\n        next();\n      });\n    },\n    req.project.remove.bind(req.project),\n    function (next) {\n      clearProjectCache(req.project, function (error) {\n        next(error);\n      });\n    },\n    function (next) {\n      var now = new Date();\n\n      Job.update({project: req.project.name},\n        {$set: {archived: now}},\n        {multi: true}, next);\n    }\n  ], function (err) {\n    if (err) {\n      debug('repo.delete_index() - Error deleting repo config for url %s by user %s: %s', req.project.name, req.user.email, err);\n      return res.status(500).send(`Failed to delete project: ${err.message}`);\n    }\n    var r = {\n      errors: [],\n      status: 'ok',\n      results: []\n    };\n    res.send(JSON.stringify(r, null, '\\t'));\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/ssh.js":"'use strict';\n\nvar debug = require('debug')('strider:ssh');\nvar NodeRSA = require('node-rsa');\nvar sshpk = require('sshpk');\n\n/**\n * Generates an RSA/SSH keypair.\n * @param comment {string} The comment to put on the public key.\n * @param callback\n */\nexports.generateKeyPair = function (comment, callback) {\n  debug('Generating SSH key pair...');\n  try {\n    var key = new NodeRSA();\n    key.generateKeyPair();\n    var privateKeyPem = key.exportKey('pkcs1-private-pem');\n    var publicKeyPem = key.exportKey('pkcs1-public-pem');\n    var publicKey = sshpk.parseKey(publicKeyPem, 'pem');\n    publicKey.comment = comment;\n\n    callback(null, privateKeyPem, publicKey.toString());\n\n  } catch (error) {\n    callback(error);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/api/config.js":"'use strict';\n\nvar common = require('../../common');\nvar debug = require('debug')('strider:routes:api:config');\nvar ssh = require('./../../ssh');\n\nvar cache = {};\n\nmodule.exports = {\n  keygen: keygen,\n  cacheConfig: cacheConfig,\n  server: server\n};\n\nfunction keygen(req, res) {\n  var branch = req.project.branch(req.query.branch);\n\n  if (!branch) return res.status(404).send('Branch not found');\n\n  ssh.generateKeyPair(`${req.project.name} - stridercd`, function (err, priv, pub) {\n    if (err) return res.status(500).send('Failed to generate keypair');\n\n    branch.privkey = priv;\n    branch.pubkey = pub;\n\n    req.project.save(function (err) {\n      if (err) return res.status(500).send('Failed to save project');\n      res.send({\n        privkey: priv,\n        pubkey: pub\n      });\n    });\n  });\n}\n\nfunction cacheConfig(loader, next) {\n  loader.initConfig(function (err, jstext, csstext, configs) {\n    if (err) return next(err);\n\n    cache['config'] = {\n      js: jstext,\n      css: csstext\n    };\n\n    debug('loaded config pages');\n    common.pluginConfigs = configs;\n\n    loader.initUserConfig(function (err, jstext, csstext, configs) {\n      if (err) return next(err);\n\n      cache['account'] = {\n        js: jstext,\n        css: csstext\n      };\n\n      debug('loaded account config pages');\n      common.userConfigs = configs;\n\n      loader.initStatusBlocks(function (err, jstext, csstext, blocks) {\n        if (err) return next(err);\n\n        cache['status'] = {\n          js: jstext,\n          css: csstext\n        };\n\n        debug('loaded plugin status blocks');\n        common.statusBlocks = blocks;\n        next();\n      });\n    });\n  });\n}\n\nfunction server(name, which) {\n  return function (req, res) {\n    res.set('Content-type', `text/${(which === 'css' ? 'css' : 'javascript')}`);\n\n    if (!cache['config']) {\n      return res.status(500).send('looks like config was not compiled correctly');\n    }\n\n    res.send(cache[name][which]);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/models/upgrade/index.js":"'use strict';\n\nvar async = require('async');\nvar models = require('../');\n\n// done(err)\nmodule.exports = {\n  ensure: ensure,\n  isNeeded: isNeeded,\n  upgrade: upgrade,\n  isFreshDb: isFreshDb,\n  needConfigObj: needConfigObj\n};\n\nvar upgrades = {\n  0: require('./from0to1'),\n  1: require('./from1to2')\n};\n\nfunction ensure(version, done) {\n  isNeeded(version, function (err, needed, oldv, newv, config) {\n    if (err) return done(err);\n    if (!needed) return done();\n    if (process.env.STRIDER_DB_UPGRADE !== 'yes') {\n      console.error('Your Strider database needs to be upgraded!\\n');\n      console.log('Please:');\n      console.log('1) Backup your database');\n      console.log('2) Re-run setting environment variable:\\n');\n      console.log('STRIDER_DB_UPGRADE=yes');\n      console.log('e.g. $ env STRIDER_DB_UPGRADE=yes npm start');\n      process.exit(0);\n    } else {\n      console.log('STRIDER_DB_UPGRADE is set to yes');\n      console.log('Updating database from version %d to %d', oldv, newv);\n      upgrade(oldv, newv, function (err) {\n        if (err) return done(err);\n        config.save(done);\n      });\n    }\n  });\n}\n\nfunction upgrade(oldv, newv, done) {\n  var tasks = [];\n  for (var i = oldv; i < newv; i++) {\n    tasks.push(upgrades[i]);\n  }\n  async.series(tasks, done);\n}\n\nfunction isNeeded(version, done) {\n  models.User.find({}, function (err, users) {\n    models.Config.find({}, function (err, configs) {\n      if (err) return done(err);\n      if (configs && configs.length > 1) {\n        return done(new Error('Multiple `Config`s found in the database. Only one is allowed'));\n      }\n      if (!configs || configs.length === 0) {\n        var config = new models.Config({version: 0});\n        if (!users || !users.length) config.version = version;\n        return config.save(function () {\n          done(null, false);\n        });\n      } else {\n        config = configs[0];\n      }\n      if (config.version >= version) {\n        return done(null, false);\n      }\n      var oldversion = config.version;\n      config.version = version;\n      done(err, true, oldversion, version, config);\n    });\n  });\n}\n\nfunction isFreshDb(cb) {\n  models.User.count(function (err, res) {\n    if (err) throw err;\n    if (res === 0) {\n      return cb(null, true);\n    }\n    return cb('there are users.', false);\n  });\n}\n\nfunction needConfigObj(cb) {\n  models.Config.count(function (err, res) {\n    if (err) throw err;\n    if (res === 0) {\n      return cb(null, true);\n    }\n    return cb(`there are ${res}configs.`, false);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/models/upgrade/from0to1.js":"'use strict';\n\nvar models = require('../');\nvar Job = models.Job;\nvar User = models.User;\nvar Project = models.Project;\n\nvar async = require('async');\n\nvar utils = require('../../utils');\n\nmodule.exports = function (done) {\n  upgradeUsers(function (err) {\n    if (err) return done(err);\n    upgradeJobs(done);\n  });\n};\n\nfunction upgradeJobs(done) {\n  Job.collection.find({}, function (err, cursor) {\n    if (err) return done(err);\n    cursor.toArray(function (err, jobs) {\n      if (err) return done(err);\n      console.log('converting', jobs.length, 'jobs');\n      var tasks = [];\n      jobs.forEach(function (job) {\n        tasks.push(function (next) {\n          upgradeJob(job, next);\n        });\n      });\n      async.series(tasks, done);\n    });\n  });\n}\n\nfunction upgradeJob(job, done) {\n  Job.findById(job._id).lean().exec(function (err, mjob) {\n    if (err) return done(err);\n    mjob.user_id = job._owner;\n    mjob.project = makeName(job.repo_url);\n    mjob.ref = {\n      branch: 'master'\n    };\n    if (job.github_commit_info) {\n      mjob.ref.id = job.github_commit_info.id;\n    }\n    mjob.std = {\n      out: job.stdout || '',\n      err: job.stderr || '',\n      merged: job.stdmerged || ''\n    };\n    mjob.created = job.created_timestamp;\n    mjob.finished = job.finished_timestamp;\n    mjob.queued = mjob.created;\n    mjob.started = mjob.created;\n    mjob.duration = mjob.finished ? mjob.finished.getTime() - mjob.created.getTime() : 0;\n    mjob.archived = job.archived_timestamp;\n    mjob.trigger = makeTrigger(job, job.github_commit_info);\n    mjob.plugin_data = {};\n    if (job.tasks && job.tasks.length) {\n      mjob.plugin_data.sauce = job.tasks;\n    }\n    killAttrs(mjob, ['created_timestamp', 'finished_timestamp', 'archived_timestamp', '_owner', 'repo_url', 'stdout', 'stderr', 'stdmerged', 'tasks']);\n    mjob.phases = {\n      environment: {\n        commands: []\n      },\n      prepare: {\n        commands: []\n      },\n      test: {\n        finished: mjob.finished,\n        duration: mjob.duration,\n        exitCode: mjob.test_exitcode,\n        commands: [{\n          started: mjob.started,\n          duration: mjob.duration,\n          command: 'Legacy job output',\n          out: mjob.std.out,\n          err: mjob.std.err,\n          merged: mjob.std.merged\n        }]\n      },\n      deploy: {\n        commands: []\n      },\n      cleanup: {\n        commands: []\n      }\n    };\n    Job.collection.update({_id: job._id}, mjob, done);\n    console.log('done job', job._id);\n  });\n}\n\nfunction makeTrigger(job, commit) {\n  if (!commit) {\n    return {\n      type: 'manual',\n      author: {\n        id: job._owner\n        // TODO get more info about the user? Like email, gravatar, etc\n      },\n      message: job.type === 'TEST_AND_DEPLOY' ? 'Redeploy' : 'Retest',\n      timestamp: job.created_timestamp,\n      source: {type: 'UI', page: 'Unknown'}\n    };\n  }\n  commit.author.image = utils.gravatar(commit.author.email);\n  return {\n    type: 'commit',\n    author: commit.author,\n    message: commit.message,\n    timestamp: commit.timestamp,\n    url: `${job.repo_url}/commit/${commit.id}`,\n    source: {type: 'plugin', plugin: 'github'}\n  };\n}\n\nfunction upgradeUsers(done) {\n  User.collection.find({}, function (err, cursor) {\n    if (err) return done(err);\n    cursor.toArray(function (err, users) {\n      if (err) return done(err);\n      console.log('converting users', users.length);\n      var tasks = [];\n      users.forEach(function (user) {\n        tasks.push(function (next) {\n          upgradeUser(user, next);\n        });\n      });\n      async.series(tasks, done);\n    });\n  });\n}\n\nfunction makeGithubRepos(user) {\n  if (!user.github) return [];\n  var github = user.github_metadata[user.github.id].repos;\n  var repos = [];\n  for (var i = 0; i < github.length; i++) {\n    repos.push({\n      id: `${github[i].id}`,\n      name: github[i].full_name && github[i].full_name.toLowerCase(),\n      display_name: github[i].full_name,\n      group: github[i].owner.login,\n      display_url: github[i].html_url,\n      config: {\n        url: `git://${github[i].clone_url.split('//')[1]}`,\n        owner: github[i].owner.login,\n        repo: github[i].name,\n        auth: {\n          type: 'https'\n        }\n      }\n    });\n  }\n  return repos;\n}\n\n// remove attributes from a model\nfunction killAttrs(model, attrs) {\n  for (var i = 0; i < attrs.length; i++) {\n    delete model[attrs[i]];\n  }\n}\n\nfunction makeHerokuAccounts(user) {\n  if (!user.heroku || !user.heroku.length) return {accounts: [], apps: {}};\n  var keys = {};\n  var accounts = [];\n  var caches = {};\n  var apps = {};\n  user.heroku.forEach(function (account) {\n    var aid = account.account_id.split('@')[0];\n    if (keys[account.api_key]) {\n      aid = keys[account.api_key];\n    } else {\n      caches[account.api_key] = [];\n    }\n    apps[account.account_id] = {\n      id: account.account_id.split('@')[0].split('-')[1],\n      name: account.app,\n      account: aid,\n      git_url: `git@heroku.com:${account.app}.git`,\n      web_url: `http://${account.app}.herokuapp.com/`\n    };\n    caches[account.api_key].push(apps[account.account_id]);\n    if (keys[account.api_key]) {\n      return;\n    }\n    keys[account.api_key] = aid;\n    accounts.push({\n      id: aid,\n      api_key: account.api_key,\n      email: aid,\n      privkey: account.privkey,\n      pubkey: account.pubkey,\n      cache: caches[account.api_key]\n    });\n  });\n  return {\n    accounts: accounts,\n    apps: apps\n  };\n}\n\n\nfunction upgradeUser(user, done) {\n  User.findById(user._id).lean().exec(function (err, mongUser) {\n    var heroku = makeHerokuAccounts(user);\n    mongUser.accounts = [];\n    if (user.github && user.github.id) {\n      mongUser.accounts.push({\n        provider: 'github',\n        id: user.github.id,\n        display_url: `https://github.com/${user.github.login}`,\n        title: user.github.login,\n        config: convertGithub(user),\n        cache: makeGithubRepos(user)\n      });\n    }\n    mongUser.jobplugins = {\n      heroku: {\n        accounts: heroku.accounts\n      }\n    };\n    mongUser.projects = [];\n    killAttrs(mongUser, ['github', 'github_config', 'github_metadata', 'dotcloud_config', 'heroku']);\n    var projects = [];\n    if (user.github_config && user.github_config.length > 0) {\n      for (var i = 0; i < user.github_config.length; i++) {\n        var repo_config = user.github_config[i];\n        var name = makeName(repo_config.display_url);\n        mongUser.projects.push({name: name.toLowerCase(), display_name: name, access_level: 2});\n        projects.push(makeProject(name, repo_config, user, heroku));\n      }\n    }\n    Project.create(projects, function (err) {\n      if (err) return done(err);\n      User.collection.update({_id: mongUser._id}, mongUser, done);\n    });\n    console.log('projects', projects.length, user._id);\n  });\n}\n\nfunction makeName(url) {\n  return url.split('/').slice(-2).join('/').split('.')[0];\n}\n\nfunction makeProvider(name, repo, user) {\n  // TODO: how do I know if it's not github?\n  var parts = name.split('/');\n  var repos = user.github_metadata[user.github.id].repos;\n  var url = `git://${repo.display_url.split('//')[1]}.git`;\n  var id = null;\n  for (var i = 0; i < repos.length; i++) {\n    if (repos[i].html_url === repo.display_url) {\n      id = repos[i].id;\n      url = `git://${repos[i].git_url.split('//')[1]}`;\n      break;\n    }\n  }\n  return {\n    id: 'github',\n    repo_id: id,\n    account: user.github.id,\n    config: {\n      url: url,\n      owner: parts[0],\n      repo: parts[1],\n      auth: {\n        type: 'https'\n        // with no username specified,\n      }\n    }\n  };\n}\n\n// plugins that we need:\n// node\n//\n// Optional:\n// browserstack\n// webhooks\n// heroku\n// custom\n// env\n// jelly\n// qunit\n// sauce\n\nvar checkPlugins = {\n  sauce: function (repo) {\n    if (!repo.sauce_access_key) return;\n    return {\n      access_key: repo.sauce_access_key,\n      username: repo.sauce_username,\n      browsers: repo.sauce_browsers\n    };\n  },\n  qunit: function (repo) {\n    if (!repo.qunit_file) return;\n    return {\n      file: repo.qunit_file,\n      path: repo.qunit_path\n    };\n  },\n  jelly: function (repo) {\n    if (!repo.jelly_payload) return;\n    return {\n      url: repo.jelly_url,\n      port: repo.jelly_port,\n      payload: repo.jelly_payload,\n      static: repo.jelly_static,\n      static_dir: repo.jelly_static_dir\n    };\n  },\n  env: function (repo) {\n    return repo.env;\n  },\n  custom: function (repo) {\n    return repo.custom;\n  },\n  heroku: function (repo, user, heroku) {\n    if (!repo.prod_deploy_target || repo.prod_deploy_target.provider !== 'heroku') return;\n    var account_id = repo.prod_deploy_target.account_id;\n    return {app: heroku.apps[account_id]};\n  },\n  webhooks: function (repo) {\n    if (!repo.webhooks || !repo.webhooks.length) return;\n    var hooks = [];\n    var hook;\n    for (var i = 0; i < repo.webhooks.length; i++) {\n      hook = repo.webhooks[i];\n      hooks.push({\n        id: hook._id,\n        url: hook.url,\n        secret: hook.secret,\n        format: '',\n        trigger: 'job.done'\n      });\n    }\n    return hooks;\n  },\n  browserstack: function (repo) {\n    if (!repo.browserstack_api_key) return;\n    return {\n      apiKey: repo.browserstack_api_key,\n      username: repo.browserstack_username,\n      password: repo.browserstack_password,\n      browsers: repo.browserstack_browsers\n    };\n  }\n};\n\nfunction makePlugins(repo, user, heroku) {\n  var plugins = [{\n    id: 'node',\n    enabled: true,\n    config: {\n      test: 'npm install',\n      runtime: 'whatever'\n    }\n  }];\n  Object.keys(checkPlugins).forEach(function (name) {\n    var config = checkPlugins[name](repo, user, heroku);\n    if (!config) return;\n    plugins.push({\n      id: name,\n      enabled: true,\n      config: config\n    });\n  });\n  return plugins;\n}\n\nfunction makeBranch(repo, user, heroku) {\n  return {\n    active: repo.active,\n    name: 'master',\n    mirror_master: false,\n    deploy_on_green: repo.prod_deploy_target && repo.prod_deploy_target.deploy_on_green,\n    deploy_on_pull_request: false,\n    pubkey: repo.pubkey,\n    privkey: repo.privkey,\n    plugins: makePlugins(repo, user, heroku),\n    plugin_data: {},\n    runner: {\n      id: 'simple-runner',\n      config: {\n        pty: false\n      }\n    }\n  };\n}\n\nfunction makeProject(name, repo, user, heroku) {\n  return {\n    name: name.toLowerCase(),\n    secret: repo.secret,\n    public: repo.public,\n    display_name: name,\n    display_url: repo.display_url,\n    creator: user._id,\n    branches: [makeBranch(repo, user, heroku)],\n    provider: makeProvider(name, repo, user),\n  };\n}\n\nfunction convertGithub(user) {\n  if (!user.github) return {};\n  var g = user.github;\n  return {\n    accessToken: g.accessToken,\n    login: g.login,\n    email: g.email,\n    gravatarId: g.gravatarId,\n    name: g.name\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/models/upgrade/from1to2.js":"'use strict';\n\nvar models = require('../');\nvar Project = models.Project;\n\nmodule.exports = function (done) {\n  var newBranch = {\n    name: '*',\n    mirror_master: true\n  };\n\n  var update = {$push: {branches: newBranch}};\n  var options = {multi: true};\n\n  Project.update({}, update, options, done);\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/utils/load-extensions.js":"'use strict';\n\nvar apiConfig = require('../routes/api/config');\nvar app = require('../app');\nvar async = require('async');\nvar common = require('../common');\nvar debug = require('debug')('strider:load-extensions');\nvar pluginTemplates = require('../plugin-templates');\nvar slashes = require('connect-slashes');\n\nfunction loadExtensions(loader, extdir, context, appInstance, cb) {\n  loader.collectExtensions(extdir, function (err) {\n    if (err) return cb(err);\n\n    async.parallel([\n      function (next) {\n        loader.initWebAppExtensions(context, function (err, webapps) {\n          if (err) return next(err);\n\n          common.extensions = webapps;\n          debug('initalized webapps');\n\n          for (var type in webapps) {\n            debug(`Found ${type} plugins:`);\n            for (var id in webapps[type]) {\n              debug(`  - ${id}`);\n            }\n          }\n\n          next();\n        });\n      },\n\n      function (next) {\n        loader.initTemplates(function (err, templates) {\n          if (err) return next(err);\n\n          for (var name in templates) {\n            pluginTemplates.registerTemplate(name, templates[name]);\n          }\n\n          debug('loaded templates');\n          next();\n        });\n      },\n\n      function (next) {\n        loader.initStaticDirs(appInstance, function () {\n          debug('initialized static directories');\n          next();\n        });\n      },\n\n      function (next) {\n        apiConfig.cacheConfig(loader, next);\n      }\n    ], function (err) {\n      if (err) {\n        debug(err);\n        debug('Failed to load plugins');\n        return cb(err, appInstance);\n      }\n\n      debug('loaded plugins');\n      appInstance.use(slashes(true, true));\n      app.run(appInstance);\n      cb(null, appInstance);\n    });\n  });\n}\n\nmodule.exports = loadExtensions;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/utils/kill-zombies.js":"'use strict';\n\nvar debug = require('debug')('strider:kill-zombies');\nvar Job = require('../models/job');\n\nmodule.exports = function killZombies(done) {\n  debug('Marking zombie jobs as finished...');\n\n  Job.update({\n    archived: null,\n    finished: null\n  }, {\n    $set: {\n      finished: new Date(),\n      errored: true\n    }\n  }, {\n    multi: true\n  }, function (err, count) {\n    if (err) throw err;\n    debug('%d zombie jobs marked as finished', count.nModified);\n    done();\n  }\n  );\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/utils/register-panel.js":"'use strict';\n\nvar debug = require('debug')('strider:register-panel');\n\n// ### Register panel\n//\n// A panel is simply a snippet of HTML associated with a given key.\n// Strider will output panels registered for specific template.\n//\nmodule.exports = function setupRegisterPanel(common) {\n  return function registerPanel(key, value) {\n    // Nothing yet registered for this panel\n    key = value.id;\n    debug('!! registerPanel', key);\n\n    if (common.extensions[key] === undefined) {\n      common.extensions[key] = { panel: value };\n    } else {\n      if (common.extensions[key].panel) {\n        debug('!!', key, common.extensions[key], value);\n        throw `Multiple Panels for ${key}`;\n      }\n\n      common.extensions[key].panel = value;\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/shim.js":"'use strict';\n\nmodule.exports = {\n  jquery: {\n    exports: 'jQuery'\n  },\n  bootstrap: {\n    depends: {\n      jquery: 'jQuery'\n    }\n  },\n  sortable: {\n    exports: 'Sortable'\n  },\n  ngSortableDirective: {\n    exports: 'ngSortableDirective',\n    depends: {\n      angular: 'angular',\n      sortable: 'Sortable'\n    }\n  },\n  'ui-bootstrap': {\n    depends: {\n      angular: 'angular'\n    }\n  },\n  md5: {\n    exports: 'md5'\n  },\n  bootbox: {\n    exports: 'bootbox'\n  },\n  codemirror: {\n    exports: 'CodeMirror'\n  },\n  'codemirror-shell': {\n    depends: {\n      codemirror: 'CodeMirror'\n    }\n  },\n  'ui-codemirror': {\n    depends: {\n      angular: 'angular',\n      codemirror: 'CodeMirror',\n      'codemirror-shell': null\n    }\n  },\n  timeago: {\n    depends: {\n      jquery: 'jQuery'\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/api_data.js":"define({ \"api\": [\r  {\r    \"type\": \"post\",\r    \"url\": \"/account/email\",\r    \"title\": \"Change Email\",\r    \"description\": \"<p>Changes the email address for the <em>active</em> user (the API user).</p>\",\r    \"name\": \"ChangeEmail\",\r    \"group\": \"Account\",\r    \"version\": \"1.0.0\",\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"email\",\r            \"description\": \"<p>The new email address. This must be a VALID email address.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/account.js\",\r    \"groupTitle\": \"Account\"\r  },\r  {\r    \"type\": \"post\",\r    \"url\": \"/account/password\",\r    \"title\": \"Change Password\",\r    \"description\": \"<p>Changes the password for the <em>active</em> user (the API user).</p>\",\r    \"name\": \"ChangePassword\",\r    \"group\": \"Account\",\r    \"version\": \"1.0.0\",\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"size\": \"6..\",\r            \"optional\": false,\r            \"field\": \"password\",\r            \"description\": \"<p>The new password, which must be at least 6 characters long.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/account.js\",\r    \"groupTitle\": \"Account\"\r  },\r  {\r    \"type\": \"delete\",\r    \"url\": \"/account/:provider/:id\",\r    \"title\": \"Delete Provider Account\",\r    \"description\": \"<p>Deletes a provider account for the <em>active</em> user (the API user).</p>\",\r    \"name\": \"DeleteAccount\",\r    \"group\": \"Account\",\r    \"version\": \"1.0.0\",\r    \"parameter\": {\r      \"fields\": {\r        \"Parameter\": [\r          {\r            \"group\": \"Parameter\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"provider\",\r            \"description\": \"<p>Type of provider, e.g. github</p>\"\r          },\r          {\r            \"group\": \"Parameter\",\r            \"type\": \"Number\",\r            \"optional\": false,\r            \"field\": \"id\",\r            \"description\": \"<p>Unique provider identification</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/account.js\",\r    \"groupTitle\": \"Account\"\r  },\r  {\r    \"type\": \"put\",\r    \"url\": \"/account/:provider/:id\",\r    \"title\": \"Update Provider Account\",\r    \"description\": \"<p>Updates a provider account for the <em>active</em> user (the API user).</p>\",\r    \"name\": \"UpdateAccount\",\r    \"group\": \"Account\",\r    \"version\": \"1.0.0\",\r    \"parameter\": {\r      \"fields\": {\r        \"Parameter\": [\r          {\r            \"group\": \"Parameter\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"provider\",\r            \"description\": \"<p>Type of provider, e.g. github</p>\"\r          },\r          {\r            \"group\": \"Parameter\",\r            \"type\": \"Number\",\r            \"optional\": false,\r            \"field\": \"id\",\r            \"description\": \"<p>Unique provider identification</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/account.js\",\r    \"groupTitle\": \"Account\"\r  },\r  {\r    \"type\": \"get\",\r    \"url\": \"/admin/users\",\r    \"title\": \"Get All Users\",\r    \"permission\": [\r      {\r        \"name\": \"GlobalAdmin\",\r        \"title\": \"You must have admin privileges in Strider (globally) in order to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Retrieves a list of all Strider users.</p>\",\r    \"name\": \"GetUsers\",\r    \"group\": \"Admin\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X GET http://localhost/admin/users\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"filename\": \"lib/routes/api/admin/index.js\",\r    \"groupTitle\": \"Admin\"\r  },\r  {\r    \"type\": \"post\",\r    \"url\": \"/admin/invite/revoke\",\r    \"title\": \"Revoke Invite\",\r    \"permission\": [\r      {\r        \"name\": \"GlobalAdmin\",\r        \"title\": \"You must have admin privileges in Strider (globally) in order to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Revokes a previously sent Strider invitation.</p>\",\r    \"name\": \"RevokeInvite\",\r    \"group\": \"Admin\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X POST -d invite_code=xoxox http://localhost/invite/revoke\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"invite_code\",\r            \"description\": \"<p>The invite code/token of the invite being revoked.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/admin/index.js\",\r    \"groupTitle\": \"Admin\"\r  },\r  {\r    \"type\": \"post\",\r    \"url\": \"/admin/invite/new\",\r    \"title\": \"Send Invite\",\r    \"permission\": [\r      {\r        \"name\": \"GlobalAdmin\",\r        \"title\": \"You must have admin privileges in Strider (globally) in order to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Create &amp; email a new Strider invite.</p>\",\r    \"name\": \"SendInvite\",\r    \"group\": \"Admin\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X POST -d invite_code=xoxox -d email=new_guy@strider-cd.com http://localhost/invite/new\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"invite_code\",\r            \"description\": \"<p>The invite code/token to use in the invitation</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"email\",\r            \"description\": \"<p>The email address of the new user being invited</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/admin/index.js\",\r    \"groupTitle\": \"Admin\"\r  },\r  {\r    \"type\": \"post\",\r    \"url\": \"/:org/:repo/branches\",\r    \"title\": \"Add Branch\",\r    \"permission\": [\r      {\r        \"name\": \"ProjectAdmin\",\r        \"title\": \"You must have admin privileges on the corresponding RepoConfig to be able to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Add a new branch for a project.</p>\",\r    \"name\": \"AddBranch\",\r    \"group\": \"Branch\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X POST -d name=newbranch http://localhost/api/strider-cd/strider/branches\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"name\",\r            \"description\": \"<p>The name of the new branch</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"cloneName\",\r            \"description\": \"<p>The name of the cloned branch</p>\"\r          }\r        ],\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/branches.js\",\r    \"groupTitle\": \"Branch\"\r  },\r  {\r    \"type\": \"delete\",\r    \"url\": \"/:org/:repo/branches\",\r    \"title\": \"Delete Branch\",\r    \"permission\": [\r      {\r        \"name\": \"ProjectAdmin\",\r        \"title\": \"You must have admin privileges on the corresponding RepoConfig to be able to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Deletes a branch from a project</p>\",\r    \"name\": \"DeleteBranch\",\r    \"group\": \"Branch\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X DELETE -d name=mybranch http://localhost/api/strider-cd/strider/branches\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"name\",\r            \"description\": \"<p>The name of the branch to delete</p>\"\r          }\r        ],\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/branches.js\",\r    \"groupTitle\": \"Branch\"\r  },\r  {\r    \"type\": \"put\",\r    \"url\": \"/:org/:repo/branches\",\r    \"title\": \"Reorder Branches\",\r    \"permission\": [\r      {\r        \"name\": \"ProjectAdmin\",\r        \"title\": \"You must have admin privileges on the corresponding RepoConfig to be able to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Updates the branch order for a project.</p>\",\r    \"name\": \"ReorderBranches\",\r    \"group\": \"Branch\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X PUT -d branches=master,testing http://localhost/api/strider-cd/strider/branches\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"branches\",\r            \"description\": \"<p>The new branch order, comma delimited</p>\"\r          }\r        ],\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/branches.js\",\r    \"groupTitle\": \"Branch\"\r  },\r  {\r    \"type\": \"post\",\r    \"url\": \"/:org/:repo/collaborators\",\r    \"title\": \"Add Collaborator\",\r    \"permission\": [\r      {\r        \"name\": \"ProjectAdmin\",\r        \"title\": \"You must have admin privileges on the corresponding RepoConfig to be able to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Add a new collaborator to a repository/project.</p>\",\r    \"name\": \"AddCollaborator\",\r    \"group\": \"Collaborators\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X GET -d '{\\\"email\\\":\\\"new_guy@strider-cd.com\\\", \\\"access\\\":2}' http://localhost/api/strider-cd/strider/collaborators\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"email\",\r            \"description\": \"<p>Email address to add. If the user is not registered with Strider, we will send them an invite. If they are already registered, they will receive a notification of access.</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"Number\",\r            \"optional\": false,\r            \"field\": \"access\",\r            \"defaultValue\": \"0\",\r            \"description\": \"<p>Access level to grant to the new collaborator. This can be <code>0</code>, for read only access, or <code>2</code> for admin access.</p>\"\r          }\r        ],\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/collaborators/index.js\",\r    \"groupTitle\": \"Collaborators\"\r  },\r  {\r    \"type\": \"delete\",\r    \"url\": \"/:org/:repo/collaborators\",\r    \"title\": \"Delete Collaborator\",\r    \"permission\": [\r      {\r        \"name\": \"ProjectAdmin\",\r        \"title\": \"You must have admin privileges on the corresponding RepoConfig to be able to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Remove a collaborator from a repository/project.</p>\",\r    \"name\": \"DeleteCollaborator\",\r    \"group\": \"Collaborators\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X DELETE -d '{\\\"email\\\":\\\"old_guy@strider-cd.com\\\"}' http://localhost/api/strider-cd/strider/collaborators\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"email\",\r            \"description\": \"<p>Email address to remove from the repo/project.</p>\"\r          }\r        ],\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/collaborators/index.js\",\r    \"groupTitle\": \"Collaborators\"\r  },\r  {\r    \"type\": \"get\",\r    \"url\": \"/:org/:repo/collaborators\",\r    \"title\": \"Get Collaborators\",\r    \"description\": \"<p>Gets a list of collaborators for a project</p>\",\r    \"name\": \"GetCollaborators\",\r    \"group\": \"Collaborators\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X GET http://localhost/api/strider-cd/strider/collaborators\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"filename\": \"lib/routes/collaborators/index.js\",\r    \"groupTitle\": \"Collaborators\",\r    \"parameter\": {\r      \"fields\": {\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    }\r  },\r  {\r    \"type\": \"get\",\r    \"url\": \"/api/jobs\",\r    \"title\": \"Get Latest Jobs\",\r    \"description\": \"<p>Return JSON object containing the most recent build status for each configured repo This function is used to build the main dashboard status page. The result is separated into <code>{public: [], yours: []}</code>.</p> <p>Note: the private ones are just ones that the current user is a collaborator on and are not necessarily private</p>\",\r    \"name\": \"GetJobs\",\r    \"group\": \"Job\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X GET http://localhost/api/jobs\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"filename\": \"lib/routes/api/jobs.js\",\r    \"groupTitle\": \"Job\"\r  },\r  {\r    \"type\": \"post\",\r    \"url\": \"/:org/:repo/start\",\r    \"title\": \"Start Job\",\r    \"description\": \"<p>Executes a strider test and, optionally, deployment.</p>\",\r    \"name\": \"StartJob\",\r    \"group\": \"Job\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X POST http://localhost/api/strider-cd/strider/start\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"type\",\r            \"defaultValue\": \"TEST_ONLY\",\r            \"description\": \"<p>Denotes the type of job to run. This can be &quot;TEST_ONLY&quot;, which indicates that only the test stages of the job should be executed or &quot;TEST_AND_DEPLOY&quot;, which indicates that all stages should be executed.</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"branch\",\r            \"defaultValue\": \"master\",\r            \"description\": \"<p>Indicates which branch configuration should be executed.</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"message\",\r            \"defaultValue\": \"Manually Retesting/Redeploying\",\r            \"description\": \"<p>An optional message to include as the title of the execution.</p>\"\r          }\r        ],\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/jobs.js\",\r    \"groupTitle\": \"Job\"\r  },\r  {\r    \"type\": \"get\",\r    \"url\": \"/:org/:repo/provider\",\r    \"title\": \"Get Project Provider\",\r    \"description\": \"<p>Get the provider config for the specified project</p>\",\r    \"name\": \"GetProjectProvider\",\r    \"group\": \"Provider\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X GET http://localhost:3000/strider-cd/strider/provider\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"filename\": \"lib/routes/provider.js\",\r    \"groupTitle\": \"Provider\",\r    \"parameter\": {\r      \"fields\": {\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    }\r  },\r  {\r    \"type\": \"post\",\r    \"url\": \"/:org/:repo/provider\",\r    \"title\": \"Update Project Provider\",\r    \"description\": \"<p>Update a project's provider</p>\",\r    \"name\": \"UpdateProjectProvider\",\r    \"group\": \"Provider\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X POST http://localhost:3000/strider-cd/strider/provider\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"filename\": \"lib/routes/provider.js\",\r    \"groupTitle\": \"Provider\",\r    \"parameter\": {\r      \"fields\": {\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    }\r  },\r  {\r    \"type\": \"delete\",\r    \"url\": \"/:org/:repo/cache\",\r    \"title\": \"Clear Cache\",\r    \"permission\": [\r      {\r        \"name\": \"ProjectAdmin\",\r        \"title\": \"You must have admin privileges on the corresponding RepoConfig to be able to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Clears/invalidates the cache for a project.</p>\",\r    \"name\": \"ClearCache\",\r    \"group\": \"Repo\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X DELETE http://localhost/api/strider-cd/strider/cache\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"filename\": \"lib/routes/api/repo.js\",\r    \"groupTitle\": \"Repo\",\r    \"parameter\": {\r      \"fields\": {\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    }\r  },\r  {\r    \"type\": \"put\",\r    \"url\": \"/:org\",\r    \"title\": \"Create Repo\",\r    \"description\": \"<p>Create a new project for a repo.</p>\",\r    \"name\": \"CreateRepo\",\r    \"group\": \"Repo\",\r    \"version\": \"1.0.0\",\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"name\",\r            \"description\": \"<p>The name of the new branch</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"display_name\",\r            \"description\": \"<p>Human-readable project name</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"display_url\",\r            \"description\": \"<p>The URL for the repo (e.g. Github homepage)</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"Boolean\",\r            \"optional\": false,\r            \"field\": \"public\",\r            \"defaultValue\": \"false\",\r            \"description\": \"<p>Whether this project is public or not.</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"Boolean\",\r            \"optional\": false,\r            \"field\": \"prefetch_config\",\r            \"defaultValue\": \"true\",\r            \"description\": \"<p>Whether the strider.json should be fetched in advance.</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"account\",\r            \"description\": \"<p>The ID of provider account</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo_id\",\r            \"description\": \"<p>The ID of the repo</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"Object\",\r            \"optional\": false,\r            \"field\": \"provider\",\r            \"description\": \"<p>A json object with 'id' and 'config' properties.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/repo.js\",\r    \"groupTitle\": \"Repo\"\r  },\r  {\r    \"type\": \"delete\",\r    \"url\": \"/:org/:repo\",\r    \"title\": \"Delete Repo\",\r    \"permission\": [\r      {\r        \"name\": \"ProjectAdmin\",\r        \"title\": \"You must have admin privileges on the corresponding RepoConfig to be able to use this endpoint.\",\r        \"description\": \"\"\r      }\r    ],\r    \"description\": \"<p>Deletes a repository/project. Also archives all jobs (marks as archived in DB which makes them hidden).</p>\",\r    \"name\": \"DeleteRepo\",\r    \"group\": \"Repo\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X DELETE http://localhost/api/strider-cd/strider\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"filename\": \"lib/routes/api/repo.js\",\r    \"groupTitle\": \"Repo\",\r    \"parameter\": {\r      \"fields\": {\r        \"Request URL Parameters\": [\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"org\",\r            \"description\": \"<p>The organization name for the project.  This is usually a GitHub user or organization name (e.g. &quot;strider&quot; in &quot;strider-cd/strider&quot;) but may vary from one project provider to another. (as another example, in GitLab this refers to the repository's &quot;group&quot;).</p>\"\r          },\r          {\r            \"group\": \"RequestUrl\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"repo\",\r            \"description\": \"<p>The project's repository name.</p>\"\r          }\r        ]\r      }\r    }\r  },\r  {\r    \"type\": \"post\",\r    \"url\": \"/api/session\",\r    \"title\": \"Create New Session\",\r    \"description\": \"<p>Creates a new user session after validating an email address and password pair.</p>\",\r    \"name\": \"CreateSession\",\r    \"group\": \"Session\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X POST -d email=me@me.com -d password=mypass http://localhost/api/session\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"parameter\": {\r      \"fields\": {\r        \"Request Body Parameters\": [\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"email\",\r            \"description\": \"<p>The email address to login as (which is used as the username).</p>\"\r          },\r          {\r            \"group\": \"RequestBody\",\r            \"type\": \"String\",\r            \"optional\": false,\r            \"field\": \"password\",\r            \"description\": \"<p>The user's password.</p>\"\r          }\r        ]\r      }\r    },\r    \"filename\": \"lib/routes/api/session.js\",\r    \"groupTitle\": \"Session\"\r  },\r  {\r    \"type\": \"get\",\r    \"url\": \"/api/session\",\r    \"title\": \"Get Session\",\r    \"description\": \"<p>Gets the current session information</p>\",\r    \"name\": \"GetSession\",\r    \"group\": \"Session\",\r    \"version\": \"1.0.0\",\r    \"examples\": [\r      {\r        \"title\": \"CURL Example:\",\r        \"content\": \"curl -X GET http://localhost/api/session\",\r        \"type\": \"curl\"\r      }\r    ],\r    \"filename\": \"lib/routes/api/session.js\",\r    \"groupTitle\": \"Session\"\r  }\r] });\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/api_project.js":"define({\r  \"name\": \"strider\",\r  \"version\": \"1.0.0\",\r  \"description\": \"Strider API\",\r  \"apidoc\": \"0.2.0\",\r  \"sampleUrl\": false,\r  \"generator\": {\r    \"name\": \"apidoc\",\r    \"time\": \"2017-02-18T17:20:45.844Z\",\r    \"url\": \"http://apidocjs.com\",\r    \"version\": \"0.16.1\"\r  }\r});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/client/app.js":"'use strict';\n\nrequire('bootstrap');\n\nvar $ = require('jquery');\nvar _ = require('lodash');\nvar angular = require('angular');\nvar $navbar = $('.navbar');\n\nrequire('angular-route');\n\n$navbar.find('li').removeClass('active');\n$navbar.find(`a[href=\"${global.location.pathname}\"]`)\n  .parent().addClass('active');\n$('#layout-header').hide();\n$('#invite-box').height($('#signup-box').height());\n\n// Third party\nrequire('ui-bootstrap');\nrequire('ui-codemirror');\n\n// Modules\nrequire('./account');\nrequire('./config');\nrequire('./plugin-manager');\nrequire('./job-status');\nrequire('./dashboard');\nrequire('./projects');\n\n// Shared?\nrequire('./alerts');\nrequire('./ansi');\nrequire('./moment');\n\nvar app = angular.module('app', [\n  'config',\n  'account',\n  'plugin-manager',\n  'job-status',\n  'dashboard',\n  'projects'\n]);\n\n// For access from plugins, need a better way\nglobal.app = app;\nglobal.$ = $;\nglobal.angular = angular;\nglobal._ = _;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/swig-filters.js":"'use strict';\n\nmodule.exports = {\n  scriptjson: function (input) {\n    return JSON.stringify(input).replace(/<\\//g, '<\\\\/');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/swig-tags.js":"'use strict';\n\n// Plugin block is the tag used to specify that the\n// contents can be overridden by extensions.\nfunction pluginBlock(indent, parser) {\n  var template = this.args[0];\n  var output = '';\n\n  // Register that the template is needed, for 1st pass;\n  output += `_context._striderRegister.push('${template}');\\n`;\n\n\n  // Generate code to see if pluginTemplates has block\n  output += `var _pg = _context._striderBlocks['${template}'];\\n`;\n  output += 'if (_pg){ ';\n  output += '_output += _pg;';\n  output += '} else {\\n';\n  output += parser.compile.call(this, `${indent} `);\n  output += '}\\n';\n\n  return output;\n}\npluginBlock.ends = true;\n\nmodule.exports = {\n  tags: {\n    pluginblock: pluginBlock\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/ca.js":"define({\n    ca: {\n        'Allowed values:'             : 'Valors permesos:',\n        'Compare all with predecessor': 'Comparar tot amb versió anterior',\n        'compare changes to:'         : 'comparar canvis amb:',\n        'compared to'                 : 'comparat amb',\n        'Default value:'              : 'Valor per defecte:',\n        'Description'                 : 'Descripció',\n        'Field'                       : 'Camp',\n        'General'                     : 'General',\n        'Generated with'              : 'Generat amb',\n        'Name'                        : 'Nom',\n        'No response values.'         : 'Sense valors en la resposta.',\n        'optional'                    : 'opcional',\n        'Parameter'                   : 'Paràmetre',\n        'Permission:'                 : 'Permisos:',\n        'Response'                    : 'Resposta',\n        'Send'                        : 'Enviar',\n        'Send a Sample Request'       : 'Enviar una petició d\\'exemple',\n        'show up to version:'         : 'mostrar versió:',\n        'Size range:'                 : 'Tamany de rang:',\n        'Type'                        : 'Tipus',\n        'url'                         : 'url'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/de.js":"define({\n    de: {\n        'Allowed values:'             : 'Erlaubte Werte:',\n        'Compare all with predecessor': 'Vergleiche alle mit ihren Vorgängern',\n        'compare changes to:'         : 'vergleiche Änderungen mit:',\n        'compared to'                 : 'verglichen mit',\n        'Default value:'              : 'Standardwert:',\n        'Description'                 : 'Beschreibung',\n        'Field'                       : 'Feld',\n        'General'                     : 'Allgemein',\n        'Generated with'              : 'Erstellt mit',\n        'Name'                        : 'Name',\n        'No response values.'         : 'Keine Rückgabewerte.',\n        'optional'                    : 'optional',\n        'Parameter'                   : 'Parameter',\n        'Permission:'                 : 'Berechtigung:',\n        'Response'                    : 'Antwort',\n        'Send'                        : 'Senden',\n        'Send a Sample Request'       : 'Eine Beispielanfrage senden',\n        'show up to version:'         : 'zeige bis zur Version:',\n        'Size range:'                 : 'Größenbereich:',\n        'Type'                        : 'Typ',\n        'url'                         : 'url'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/es.js":"define({\n    es: {\n        'Allowed values:'             : 'Valores permitidos:',\n        'Compare all with predecessor': 'Comparar todo con versión anterior',\n        'compare changes to:'         : 'comparar cambios con:',\n        'compared to'                 : 'comparado con',\n        'Default value:'              : 'Valor por defecto:',\n        'Description'                 : 'Descripción',\n        'Field'                       : 'Campo',\n        'General'                     : 'General',\n        'Generated with'              : 'Generado con',\n        'Name'                        : 'Nombre',\n        'No response values.'         : 'Sin valores en la respuesta.',\n        'optional'                    : 'opcional',\n        'Parameter'                   : 'Parámetro',\n        'Permission:'                 : 'Permisos:',\n        'Response'                    : 'Respuesta',\n        'Send'                        : 'Enviar',\n        'Send a Sample Request'       : 'Enviar una petición de ejemplo',\n        'show up to version:'         : 'mostrar a versión:',\n        'Size range:'                 : 'Tamaño de rango:',\n        'Type'                        : 'Tipo',\n        'url'                         : 'url'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/fr.js":"define({\n    fr: {\n        'Allowed values:'             : 'Valeurs autorisées :',\n        'Compare all with predecessor': 'Tout comparer avec ...',\n        'compare changes to:'         : 'comparer les changements à :',\n        'compared to'                 : 'comparer à',\n        'Default value:'              : 'Valeur par défaut :',\n        'Description'                 : 'Description',\n        'Field'                       : 'Champ',\n        'General'                     : 'Général',\n        'Generated with'              : 'Généré avec',\n        'Name'                        : 'Nom',\n        'No response values.'         : 'Aucune valeur de réponse.',\n        'optional'                    : 'optionnel',\n        'Parameter'                   : 'Paramètre',\n        'Permission:'                 : 'Permission :',\n        'Response'                    : 'Réponse',\n        'Send'                        : 'Envoyer',\n        'Send a Sample Request'       : 'Envoyer une requête représentative',\n        'show up to version:'         : 'Montrer à partir de la version :',\n        'Size range:'                 : 'Ordre de grandeur :',\n        'Type'                        : 'Type',\n        'url'                         : 'url'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/it.js":"define({\n    it: {\n        'Allowed values:'             : 'Valori permessi:',\n        'Compare all with predecessor': 'Confronta tutto con versioni precedenti',\n        'compare changes to:'         : 'confronta modifiche con:',\n        'compared to'                 : 'confrontato con',\n        'Default value:'              : 'Valore predefinito:',\n        'Description'                 : 'Descrizione',\n        'Field'                       : 'Campo',\n        'General'                     : 'Generale',\n        'Generated with'              : 'Creato con',\n        'Name'                        : 'Nome',\n        'No response values.'         : 'Nessnu valore di risposta.',\n        'optional'                    : 'opzionale',\n        'Parameter'                   : 'Parametro',\n        'Permission:'                 : 'Permessi:',\n        'Response'                    : 'Risposta',\n        'Send'                        : 'Invia',\n        'Send a Sample Request'       : 'Invia una richiesta di esempio',\n        'show up to version:'         : 'visualizza la versione:',\n        'Size range:'                 : 'Intervallo dimensione:',\n        'Type'                        : 'Tipo',\n        'url'                         : 'url'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/locale.js":"define([\n    './locales/ca.js',\n    './locales/de.js',\n    './locales/es.js',\n    './locales/fr.js',\n    './locales/it.js',\n    './locales/nl.js',\n    './locales/pl.js',\n    './locales/pt_br.js',\n    './locales/ru.js',\n    './locales/zh.js',\n    './locales/zh_cn.js'\n], function() {\n    var langId = (navigator.language || navigator.userLanguage).toLowerCase().replace('-', '_');\n    var language = langId.substr(0, 2);\n    var locales = {};\n\n    for (index in arguments) {\n        for (property in arguments[index])\n            locales[property] = arguments[index][property];\n    }\n    if ( ! locales['en'])\n        locales['en'] = {};\n\n    if ( ! locales[langId] && ! locales[language])\n        language = 'en';\n\n    var locale = (locales[langId] ? locales[langId] : locales[language]);\n\n    function __(text) {\n        var index = locale[text];\n        if (index === undefined)\n            return text;\n        return index;\n    };\n\n    function setLanguage(language) {\n        locale = locales[language];\n    }\n\n    return {\n        __         : __,\n        locales    : locales,\n        locale     : locale,\n        setLanguage: setLanguage\n    };\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/nl.js":"define({\n    nl: {\n        'Allowed values:'             : 'Toegestane waarden:',\n        'Compare all with predecessor': 'Vergelijk alle met voorgaande versie',\n        'compare changes to:'         : 'vergelijk veranderingen met:',\n        'compared to'                 : 'vergelijk met',\n        'Default value:'              : 'Standaard waarde:',\n        'Description'                 : 'Omschrijving',\n        'Field'                       : 'Veld',\n        'General'                     : 'Algemeen',\n        'Generated with'              : 'Gegenereerd met',\n        'Name'                        : 'Naam',\n        'No response values.'         : 'Geen response waardes.',\n        'optional'                    : 'optioneel',\n        'Parameter'                   : 'Parameter',\n        'Permission:'                 : 'Permissie:',\n        'Response'                    : 'Antwoorden',\n        'Send'                        : 'Sturen',\n        'Send a Sample Request'       : 'Stuur een sample aanvragen',\n        'show up to version:'         : 'toon tot en met versie:',\n        'Size range:'                 : 'Maatbereik:',\n        'Type'                        : 'Type',\n        'url'                         : 'url'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/pl.js":"define({\n    pl: {\n        'Allowed values:'             : 'Dozwolone wartości:',\n        'Compare all with predecessor': 'Porównaj z poprzednimi wersjami',\n        'compare changes to:'         : 'porównaj zmiany do:',\n        'compared to'                 : 'porównaj do:',\n        'Default value:'              : 'Wartość domyślna:',\n        'Description'                 : 'Opis',\n        'Field'                       : 'Pole',\n        'General'                     : 'Generalnie',\n        'Generated with'              : 'Wygenerowano z',\n        'Name'                        : 'Nazwa',\n        'No response values.'         : 'Brak odpowiedzi.',\n        'optional'                    : 'opcjonalny',\n        'Parameter'                   : 'Parametr',\n        'Permission:'                 : 'Uprawnienia:',\n        'Response'                    : 'Odpowiedź',\n        'Send'                        : 'Wyślij',\n        'Send a Sample Request'       : 'Wyślij przykładowe żądanie',\n        'show up to version:'         : 'pokaż do wersji:',\n        'Size range:'                 : 'Zakres rozmiaru:',\n        'Type'                        : 'Typ',\n        'url'                         : 'url'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/pt_br.js":"define({\n    'pt_br': {\n        'Allowed values:'             : 'Valores permitidos:',\n        'Compare all with predecessor': 'Compare todos com antecessores',\n        'compare changes to:'         : 'comparar alterações com:',\n        'compared to'                 : 'comparado com',\n        'Default value:'              : 'Valor padrão:',\n        'Description'                 : 'Descrição',\n        'Field'                       : 'Campo',\n        'General'                     : 'Geral',\n        'Generated with'              : 'Gerado com',\n        'Name'                        : 'Nome',\n        'No response values.'         : 'Sem valores de resposta.',\n        'optional'                    : 'opcional',\n        'Parameter'                   : 'Parâmetro',\n        'Permission:'                 : 'Permissão:',\n        'Response'                    : 'Resposta',\n        'Send'                        : 'Enviar',\n        'Send a Sample Request'       : 'Enviar um Exemplo de Pedido',\n        'show up to version:'         : 'aparecer para a versão:',\n        'Size range:'                 : 'Faixa de tamanho:',\n        'Type'                        : 'Tipo',\n        'url'                         : 'url'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/ru.js":"define({\n    ru: {\n        'Allowed values:'             : 'Допустимые значения:',\n        'Compare all with predecessor': 'Сравнить с предыдущей версией',\n        'compare changes to:'         : 'сравнить с:',\n        'compared to'                 : 'в сравнении с',\n        'Default value:'              : 'По умолчанию:',\n        'Description'                 : 'Описание',\n        'Field'                       : 'Название',\n        'General'                     : 'Общая информация',\n        'Generated with'              : 'Сгенерировано с помощью',\n        'Name'                        : 'Название',\n        'No response values.'         : 'Нет значений для ответа.',\n        'optional'                    : 'необязательный',\n        'Parameter'                   : 'Параметр',\n        'Permission:'                 : 'Разрешено:',\n        'Response'                    : 'Ответ',\n        'Send'                        : 'Отправить',\n        'Send a Sample Request'       : 'Отправить тестовый запрос',\n        'show up to version:'         : 'показать версию:',\n        'Size range:'                 : 'Ограничения:',\n        'Type'                        : 'Тип',\n        'url'                         : 'URL'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/zh_cn.js":"define({\n    'zh_cn': {\n        'Allowed values:'             : '允许值:',\n        'Compare all with predecessor': '与所有较早的比较',\n        'compare changes to:'         : '将当前版本与指定版本比较:',\n        'compared to'                 : '相比于',\n        'Default value:'              : '默认值:',\n        'Description'                 : '描述',\n        'Field'                       : '字段',\n        'General'                     : '概要',\n        'Generated with'              : '基于',\n        'Name'                        : '名称',\n        'No response values.'         : '无返回值.',\n        'optional'                    : '可选',\n        'Parameter'                   : '参数',\n        'Permission:'                 : '权限:',\n        'Response'                    : '返回',\n        'Send'                        : '发送',\n        'Send a Sample Request'       : '发送示例请求',\n        'show up to version:'         : '显示到指定版本:',\n        'Size range:'                 : '取值范围:',\n        'Type'                        : '类型',\n        'url'                         : '网址'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/locales/zh.js":"define({\n    zh: {\n        'Allowed values​​:'             : '允許值:',\n        'Compare all with predecessor': '預先比較所有',\n        'compare changes to:'         : '比較變更:',\n        'compared to'                 : '對比',\n        'Default value:'              : '默認值:',\n        'Description'                 : '描述',\n        'Field'                       : '字段',\n        'General'                     : '概括',\n        'Generated with'              : '生成工具',\n        'Name'                        : '名稱',\n        'No response values​​.'         : '無對應資料.',\n        'optional'                    : '選項',\n        'Parameter'                   : '參數',\n        'Permission:'                 : '允許:',\n        'Response'                    : '回應',\n        'Send'                        : '發送',\n        'Send a Sample Request'       : '發送試用需求',\n        'show up to version:'         : '顯示到版本:',\n        'Size range:'                 : '尺寸範圍:',\n        'Type'                        : '類型',\n        'url'                         : '網址'\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/utils/handlebars_helper.js":"define([\n    'locales',\n    'handlebars',\n    'diffMatchPatch'\n], function(locale, Handlebars, DiffMatchPatch) {\n\n    /**\n     * start/stop timer for simple performance check.\n     */\n    var timer;\n    Handlebars.registerHelper('startTimer', function(text) {\n        timer = new Date();\n        return '';\n    });\n\n    Handlebars.registerHelper('stopTimer', function(text) {\n        console.log(new Date() - timer);\n        return '';\n    });\n\n    /**\n     * Return localized Text.\n     * @param string text\n     */\n    Handlebars.registerHelper('__', function(text) {\n        return locale.__(text);\n    });\n\n    /**\n     * Console log.\n     * @param mixed obj\n     */\n    Handlebars.registerHelper('cl', function(obj) {\n        console.log(obj);\n        return '';\n    });\n\n    /**\n     * Replace underscore with space.\n     * @param string text\n     */\n    Handlebars.registerHelper('underscoreToSpace', function(text) {\n        return text.replace(/(_+)/g, ' ');\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('assign', function(name) {\n        if(arguments.length > 0) {\n            var type = typeof(arguments[1]);\n            var arg = null;\n            if(type === 'string' || type === 'number' || type === 'boolean') arg = arguments[1];\n            Handlebars.registerHelper(name, function() { return arg; });\n        }\n        return '';\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('nl2br', function(text) {\n        return _handlebarsNewlineToBreak(text);\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('if_eq', function(context, options) {\n        var compare = context;\n        // Get length if context is an object\n        if (context instanceof Object && ! (options.hash.compare instanceof Object))\n             compare = Object.keys(context).length;\n\n        if (compare === options.hash.compare)\n            return options.fn(this);\n\n        return options.inverse(this);\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('if_gt', function(context, options) {\n        var compare = context;\n        // Get length if context is an object\n        if (context instanceof Object && ! (options.hash.compare instanceof Object))\n             compare = Object.keys(context).length;\n\n        if(compare > options.hash.compare)\n            return options.fn(this);\n\n        return options.inverse(this);\n    });\n\n    /**\n     *\n     */\n    var templateCache = {};\n    Handlebars.registerHelper('subTemplate', function(name, sourceContext) {\n        if ( ! templateCache[name])\n            templateCache[name] = Handlebars.compile($('#template-' + name).html());\n\n        var template = templateCache[name];\n        var templateContext = $.extend({}, this, sourceContext.hash);\n        return new Handlebars.SafeString( template(templateContext) );\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('toLowerCase', function(value) {\n        return (value && typeof value === 'string') ? value.toLowerCase() : '';\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('splitFill', function(value, splitChar, fillChar) {\n        var splits = value.split(splitChar);\n        return new Array(splits.length).join(fillChar) + splits[splits.length - 1];\n    });\n\n    /**\n     * Convert Newline to HTML-Break (nl2br).\n     *\n     * @param {String} text\n     * @returns {String}\n     */\n    function _handlebarsNewlineToBreak(text) {\n        return ('' + text).replace(/([^>\\r\\n]?)(\\r\\n|\\n\\r|\\r|\\n)/g, '$1' + '<br>' + '$2');\n    }\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('each_compare_list_field', function(source, compare, options) {\n        var fieldName = options.hash.field;\n        var newSource = [];\n        if (source) {\n            source.forEach(function(entry) {\n                var values = entry;\n                values['key'] = entry[fieldName];\n                newSource.push(values);\n            });\n        }\n\n        var newCompare = [];\n        if (compare) {\n            compare.forEach(function(entry) {\n                var values = entry;\n                values['key'] = entry[fieldName];\n                newCompare.push(values);\n            });\n        }\n        return _handlebarsEachCompared('key', newSource, newCompare, options);\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('each_compare_keys', function(source, compare, options) {\n        var newSource = [];\n        if (source) {\n            var sourceFields = Object.keys(source);\n            sourceFields.forEach(function(name) {\n                var values = {};\n                values['value'] = source[name];\n                values['key'] = name;\n                newSource.push(values);\n            });\n        }\n\n        var newCompare = [];\n        if (compare) {\n            var compareFields = Object.keys(compare);\n            compareFields.forEach(function(name) {\n                var values = {};\n                values['value'] = compare[name];\n                values['key'] = name;\n                newCompare.push(values);\n            });\n        }\n        return _handlebarsEachCompared('key', newSource, newCompare, options);\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('each_compare_field', function(source, compare, options) {\n        return _handlebarsEachCompared('field', source, compare, options);\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('each_compare_title', function(source, compare, options) {\n        return _handlebarsEachCompared('title', source, compare, options);\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('reformat', function(source, type){\n        if (type == 'json')\n            try {\n               return JSON.stringify(JSON.parse(source.trim()),null, \"    \");\n            } catch(e) {\n\n            }\n        return source\n    });\n\n    /**\n     *\n     */\n    Handlebars.registerHelper('showDiff', function(source, compare, options) {\n        var ds = '';\n        if(source === compare) {\n            ds = source;\n        } else {\n            if( ! source)\n                return compare;\n\n            if( ! compare)\n                return source;\n\n            var d = diffMatchPatch.diff_main(compare, source);\n            diffMatchPatch.diff_cleanupSemantic(d);\n            ds = diffMatchPatch.diff_prettyHtml(d);\n            ds = ds.replace(/&para;/gm, '');\n        }\n        if(options === 'nl2br')\n            ds = _handlebarsNewlineToBreak(ds);\n\n        return ds;\n    });\n\n    /**\n     *\n     */\n    function _handlebarsEachCompared(fieldname, source, compare, options)\n    {\n        var dataList = [];\n        var index = 0;\n        if(source) {\n            source.forEach(function(sourceEntry) {\n                var found = false;\n                if (compare) {\n                    compare.forEach(function(compareEntry) {\n                        if(sourceEntry[fieldname] === compareEntry[fieldname]) {\n                            var data = {\n                                typeSame: true,\n                                source: sourceEntry,\n                                compare: compareEntry,\n                                index: index\n                            };\n                            dataList.push(data);\n                            found = true;\n                            index++;\n                        }\n                    });\n                }\n                if ( ! found) {\n                    var data = {\n                        typeIns: true,\n                        source: sourceEntry,\n                        index: index\n                    };\n                    dataList.push(data);\n                    index++;\n                }\n            });\n        }\n\n        if (compare) {\n            compare.forEach(function(compareEntry) {\n                var found = false;\n                if (source) {\n                    source.forEach(function(sourceEntry) {\n                        if(sourceEntry[fieldname] === compareEntry[fieldname])\n                            found = true;\n                    });\n                }\n                if ( ! found) {\n                    var data = {\n                        typeDel: true,\n                        compare: compareEntry,\n                        index: index\n                    };\n                    dataList.push(data);\n                    index++;\n                }\n            });\n        }\n\n        var ret = '';\n        var length = dataList.length;\n        for (var index in dataList) {\n            if(index == (length - 1))\n                dataList[index]['_last'] = true;\n            ret = ret + options.fn(dataList[index]);\n        }\n        return ret;\n    }\n\n    var diffMatchPatch = new DiffMatchPatch();\n\n    /**\n     * Overwrite Colors\n     */\n    DiffMatchPatch.prototype.diff_prettyHtml = function(diffs) {\n      var html = [];\n      var pattern_amp = /&/g;\n      var pattern_lt = /</g;\n      var pattern_gt = />/g;\n      var pattern_para = /\\n/g;\n      for (var x = 0; x < diffs.length; x++) {\n        var op = diffs[x][0];    // Operation (insert, delete, equal)\n        var data = diffs[x][1];  // Text of change.\n        var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n            .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n        switch (op) {\n          case DIFF_INSERT:\n            html[x] = '<ins>' + text + '</ins>';\n            break;\n          case DIFF_DELETE:\n            html[x] = '<del>' + text + '</del>';\n            break;\n          case DIFF_EQUAL:\n            html[x] = '<span>' + text + '</span>';\n            break;\n        }\n      }\n      return html.join('');\n    };\n\n    // Exports\n    return Handlebars;\n});\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/apidocs/utils/send_sample_request.js":"define([\r\n  'jquery'\r\n], function($) {\r\n\r\n  var initDynamic = function() {\r\n      // Button send\r\n      $(\".sample-request-send\").off(\"click\");\r\n      $(\".sample-request-send\").on(\"click\", function(e) {\r\n          e.preventDefault();\r\n          var $root = $(this).parents(\"article\");\r\n          var group = $root.data(\"group\");\r\n          var name = $root.data(\"name\");\r\n          var version = $root.data(\"version\");\r\n          sendSampleRequest(group, name, version, $(this).data(\"sample-request-type\"));\r\n      });\r\n\r\n      // Button clear\r\n      $(\".sample-request-clear\").off(\"click\");\r\n      $(\".sample-request-clear\").on(\"click\", function(e) {\r\n          e.preventDefault();\r\n          var $root = $(this).parents(\"article\");\r\n          var group = $root.data(\"group\");\r\n          var name = $root.data(\"name\");\r\n          var version = $root.data(\"version\");\r\n          clearSampleRequest(group, name, version);\r\n      });\r\n  }; // initDynamic\r\n\r\n  function sendSampleRequest(group, name, version, type)\r\n  {\r\n      var $root = $('article[data-group=\"' + group + '\"][data-name=\"' + name + '\"][data-version=\"' + version + '\"]');\r\n\r\n      // Optional header\r\n      var header = {};\r\n      $root.find(\".sample-request-header:checked\").each(function(i, element) {\r\n          var group = $(element).data(\"sample-request-header-group-id\");\r\n          $root.find(\"[data-sample-request-header-group=\\\"\" + group + \"\\\"]\").each(function(i, element) {\r\n            var key = $(element).data(\"sample-request-header-name\");\r\n            var value = element.value;\r\n            if ( ! element.optional && element.defaultValue !== '') {\r\n                value = element.defaultValue;\r\n            }\r\n            header[key] = value;\r\n          });\r\n      });\r\n\r\n      // create JSON dictionary of parameters\r\n      var param = {};\r\n      var paramType = {};\r\n      $root.find(\".sample-request-param:checked\").each(function(i, element) {\r\n          var group = $(element).data(\"sample-request-param-group-id\");\r\n          $root.find(\"[data-sample-request-param-group=\\\"\" + group + \"\\\"]\").each(function(i, element) {\r\n            var key = $(element).data(\"sample-request-param-name\");\r\n            var value = element.value;\r\n            if ( ! element.optional && element.defaultValue !== '') {\r\n                value = element.defaultValue;\r\n            }\r\n            param[key] = value;\r\n            paramType[key] = $(element).next().text();\r\n          });\r\n      });\r\n\r\n      // grab user-inputted URL\r\n      var url = $root.find(\".sample-request-url\").val();\r\n\r\n      // Insert url parameter\r\n      var pattern = pathToRegexp(url, null);\r\n      var matches = pattern.exec(url);\r\n      for (var i = 1; i < matches.length; i++) {\r\n          var key = matches[i].substr(1);\r\n          if (param[key] !== undefined) {\r\n              url = url.replace(matches[i], encodeURIComponent(param[key]));\r\n\r\n              // remove URL parameters from list\r\n              delete param[key];\r\n          }\r\n      } // for\r\n\r\n      $root.find(\".sample-request-response\").fadeTo(250, 1);\r\n      $root.find(\".sample-request-response-json\").html(\"Loading...\");\r\n      refreshScrollSpy();\r\n\r\n      _.each( param, function( val, key ) {\r\n          var t = paramType[ key ].toLowerCase();\r\n          if ( t === 'object' || t === 'array' ) {\r\n              try {\r\n                  param[ key ] = JSON.parse( val );\r\n              } catch (e) {\r\n              }\r\n          }\r\n      });\r\n\r\n      // send AJAX request, catch success or error callback\r\n      var ajaxRequest = {\r\n          url        : url,\r\n          headers    : header,\r\n          data       : param,\r\n          type       : type.toUpperCase(),\r\n          success    : displaySuccess,\r\n          error      : displayError\r\n      };\r\n\r\n      $.ajax(ajaxRequest);\r\n\r\n\r\n      function displaySuccess(data, status, jqXHR) {\r\n          var jsonResponse;\r\n          try {\r\n              jsonResponse = JSON.parse(jqXHR.responseText);\r\n              jsonResponse = JSON.stringify(jsonResponse, null, 4);\r\n          } catch (e) {\r\n              jsonResponse = data;\r\n          }\r\n          $root.find(\".sample-request-response-json\").html(jsonResponse);\r\n          refreshScrollSpy();\r\n      };\r\n\r\n      function displayError(jqXHR, textStatus, error) {\r\n          var message = \"Error \" + jqXHR.status + \": \" + error;\r\n          var jsonResponse;\r\n          try {\r\n              jsonResponse = JSON.parse(jqXHR.responseText);\r\n              jsonResponse = JSON.stringify(jsonResponse, null, 4);\r\n          } catch (e) {\r\n              jsonResponse = escape(jqXHR.responseText);\r\n          }\r\n\r\n          if (jsonResponse)\r\n              message += \"<br>\" + jsonResponse;\r\n\r\n          // flicker on previous error to make clear that there is a new response\r\n          if($root.find(\".sample-request-response\").is(\":visible\"))\r\n              $root.find(\".sample-request-response\").fadeTo(1, 0.1);\r\n\r\n          $root.find(\".sample-request-response\").fadeTo(250, 1);\r\n          $root.find(\".sample-request-response-json\").html(message);\r\n          refreshScrollSpy();\r\n      };\r\n  }\r\n\r\n  function clearSampleRequest(group, name, version)\r\n  {\r\n      var $root = $('article[data-group=\"' + group + '\"][data-name=\"' + name + '\"][data-version=\"' + version + '\"]');\r\n\r\n      // hide sample response\r\n      $root.find(\".sample-request-response-json\").html(\"\");\r\n      $root.find(\".sample-request-response\").hide();\r\n\r\n      // reset value of parameters\r\n      $root.find(\".sample-request-param\").each(function(i, element) {\r\n          element.value = \"\";\r\n      });\r\n\r\n      // restore default URL\r\n      var $urlElement = $root.find(\".sample-request-url\");\r\n      $urlElement.val($urlElement.prop(\"defaultValue\"));\r\n\r\n      refreshScrollSpy();\r\n  }\r\n\r\n  function refreshScrollSpy()\r\n  {\r\n      $('[data-spy=\"scroll\"]').each(function () {\r\n          $(this).scrollspy(\"refresh\");\r\n      });\r\n  }\r\n\r\n  function escapeHtml(str) {\r\n      var div = document.createElement(\"div\");\r\n      div.appendChild(document.createTextNode(str));\r\n      return div.innerHTML;\r\n  }\r\n\r\n  /**\r\n   * Exports.\r\n   */\r\n  return {\r\n      initDynamic: initDynamic\r\n  };\r\n\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/client/utils/interpolate.js":"'use strict';\n\nmodule.exports = function ($interpolateProvider) {\n  $interpolateProvider.startSymbol('[[');\n  $interpolateProvider.endSymbol(']]');\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/client/utils/job-data-monitor.js":"'use strict';\n\nvar _ = require('lodash');\nvar JobMonitor = require('./job-monitor');\nvar SKELS = require('./skels');\n\nfunction JobDataMonitor() {\n  JobMonitor.apply(this, arguments);\n}\n\n_.extend(JobDataMonitor.prototype, JobMonitor.prototype, {});\n\nJobDataMonitor.prototype.statuses = _.extend({}, JobMonitor.prototype.statuses, {\n  'phase.done': function (data) {\n    this.phases[data.phase].finished = data.time;\n    this.phases[data.phase].duration = data.elapsed;\n    this.phases[data.phase].exitCode = data.code;\n    if (['prepare', 'environment', 'cleanup'].indexOf(data.phase) !== -1) {\n      this.phases[data.phase].collapsed = true;\n    }\n    if (data.phase === 'test') this.test_status = data.code;\n    if (data.phase === 'deploy') this.deploy_status = data.code;\n    if (!data.next || !this.phases[data.next]) return;\n    this.phase = data.next;\n    this.phases[data.next].started = data.time;\n  },\n  'command.comment': function (data) {\n    var phase = this.phases[this.phase];\n    var command = _.extend({}, SKELS.command);\n    command.command = data.comment;\n    command.comment = true;\n    command.plugin = data.plugin;\n    command.finished = data.time;\n    phase.commands.push(command);\n  },\n  'command.start': function (data) {\n    var phase = this.phases[this.phase];\n    var command = _.extend({}, SKELS.command, data);\n    command.started = data.time;\n    phase.commands.push(command);\n  },\n  'command.done': function (data) {\n    var phase = this.phases[this.phase];\n    var command = phase.commands[phase.commands.length - 1];\n    command.finished = data.time;\n    command.duration = data.elapsed;\n    command.exitCode = data.exitCode;\n    command.merged = command._merged;\n  },\n  'stdout': function (text) {\n    var command = ensureCommand(this.phases[this.phase]);\n    command.out += text;\n    command._merged += text;\n    this.std.out += text;\n    this.std.merged += text;\n    this.std.merged_latest = text;\n  },\n  'stderr': function (text) {\n    var command = ensureCommand(this.phases[this.phase]);\n    command.err += text;\n    command._merged += text;\n    this.std.err += text;\n    this.std.merged += text;\n    this.std.merged_latest = text;\n  }\n});\n\nfunction ensureCommand(phase) {\n  var command = phase.commands[phase.commands.length - 1];\n  if (!command || typeof(command.finished) !== 'undefined') {\n    command = _.extend({}, SKELS.command);\n    phase.commands.push(command);\n  }\n  return command;\n}\n\nmodule.exports = JobDataMonitor;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/client/utils/job-monitor.js":"'use strict';\n\nvar _ = require('lodash');\nvar PHASES = require('./phases');\n\n// The Job Monitor:\n// - update jobs based on browser events\n//\n\nfunction JobMonitor(socket, changed) {\n  this.sock = socket;\n  this.changed = changed;\n  this.waiting = {};\n  this.listen();\n}\n\nJobMonitor.prototype = {\n  emits: {\n    getUnknown: 'dashboard:unknown'\n  },\n  events: {\n    'job.new': function (job, access) {\n      this.addJob(job[0], access);\n      this.changed();\n    },\n    'job.done': function (job, access) {\n      this.addJob(job[0], access);\n      this.changed();\n    }\n  },\n  job: function () {\n    throw new Error('You must override this');\n  },\n  addJob: function () {\n    throw new Error('You must implement');\n  },\n  listen: function () {\n    var handler;\n    for (var event in this.events) {\n      handler = this.events[event];\n      if ('string' === typeof handler) handler = this[handler];\n      this.sock.on(event, handler.bind(this));\n    }\n    for (var status in this.statuses) {\n      this.sock.on(`job.status.${status}`, this.update.bind(this, status));\n    }\n  },\n  // access: 'yours', 'public', 'admin'\n  update: function (event, args, access, dontchange) {\n    var id = args.shift();\n    var job = this.job(id, access);\n    var handler = this.statuses[event];\n    if (!job) return this.unknown(id, event, args, access);\n    if (!handler) return;\n    if ('string' === typeof handler) {\n      job.status = handler;\n    } else {\n      handler.apply(job, args);\n    }\n    if (!dontchange) this.changed();\n  },\n  unknown: function (id, event, args, access) {\n    args = [id].concat(args);\n    if (this.waiting[id]) {\n      return this.waiting[id].push([event, args, access]);\n    }\n    this.waiting[id] = [[event, args, access]];\n    this.sock.emit(this.emits.getUnknown, id, this.gotUnknown.bind(this));\n  },\n  gotUnknown: function (job) {\n    if (!this.waiting[job._id]) return console.warn('Got unknownjob:response but wan\\'t waiting for it...');\n    var access = this.waiting[job._id][0][2];\n    if (job.status === 'submitted') {\n      job.status = 'running';\n      job.started = new Date();\n    }\n    // job.phase = job.phase || 'environment';\n    this.addJob(job, access);\n    // TODO: this.update searches for the job again. optimize\n    for (var i = 0; i < this.waiting[job._id]; i++) {\n      this.update.apply(this, this.waiting[i].concat([true]));\n    }\n    delete this.waiting[job._id];\n    this.changed();\n  },\n  statuses: {\n    'started': function (time) {\n      this.started = time;\n      this.phase = 'environment';\n      this.status = 'running';\n    },\n    'errored': function (error) {\n      this.error = error;\n      this.status = 'errored';\n    },\n    'canceled': 'errored',\n    'phase.done': function (data) {\n      this.phase = PHASES.indexOf(data.phase) + 1;\n    },\n    // this is just so we'll trigger the \"unknown job\" lookup sooner on the dashboard\n    'stdout': function () {\n    },\n    'stderr': function () {\n    },\n    'warning': function (warning) {\n      if (!this.warnings) {\n        this.warnings = [];\n      }\n      this.warnings.push(warning);\n    },\n    'plugin-data': function (data) {\n      var path = data.path ? [data.plugin].concat(data.path.split('.')) : [data.plugin];\n      var last = path.pop();\n      var method = data.method || 'replace';\n      var parent;\n      parent = path.reduce(function (obj, attr) {\n        return obj[attr] || (obj[attr] = {});\n      }, this.plugin_data || (this.plugin_data = {}));\n      if (method === 'replace') {\n        parent[last] = data.data;\n      } else if (method === 'push') {\n        if (!parent[last]) {\n          parent[last] = [];\n        }\n        parent[last].push(data.data);\n      } else if (method === 'extend') {\n        if (!parent[last]) {\n          parent[last] = {};\n        }\n        _.extend(parent[last], data.data);\n      } else {\n        console.error('Invalid \"plugin data\" method received from plugin', data.plugin, data.method, data);\n      }\n    }\n  }\n};\n\nmodule.exports = JobMonitor;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/client/utils/phases.js":"'use strict';\n\nmodule.exports = ['environment', 'prepare', 'test', 'deploy', 'cleanup'];\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/client/utils/skels.js":"'use strict';\n\nvar PHASES = require('./phases');\n\nvar SKELS = {\n  job: {\n    id: null,\n    data: null,\n    phases: {},\n    phase: PHASES[0],\n    queued: null,\n    started: null,\n    finished: null,\n    test_status: null,\n    deploy_status: null,\n    plugin_data: {},\n    warnings: [],\n    std: {\n      out: '',\n      err: '',\n      merged: '',\n      merged_latest: ''\n    }\n  },\n  command: {\n    out: '',\n    err: '',\n    merged: '',\n    _merged: '',\n    started: null,\n    command: '',\n    plugin: ''\n  },\n  phase: {\n    finished: null,\n    exitCode: null,\n    commands: []\n  }\n};\n\nmodule.exports = SKELS;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/client/utils/ng-sortable-directive.js":"'use strict';\n\nvar _ = require('lodash');\nvar $ = require('jquery');\nvar Sortable = require('sortable');\n\nmodule.exports = function ($parse) {\n  return {\n    compile: function ($element, attr) {\n      var opts = {};\n      var onAdd = null;\n      var onRemove = null;\n      var groupName = attr['ngSortableGroup'];\n      var onUpdate = attr['ngSortable'] || attr['ngSortableUpdate'];\n      var dataSource = attr['ngSortableSource'];\n      var model = attr['ngModel'];\n\n      if (groupName) {\n        if (!dataSource)\n          throw new Error('Use of a group requires specifying a data source via ng-sortable-source');\n        onAdd = attr['ngSortableAdded'];\n        onRemove = attr['ngSortableRemoved'];\n      }\n      var key = attr['ngSortableKey'] || '_id';\n      return function (scope, element) {\n        function bind(fnStr) {\n          var fn = $parse(fnStr)(scope);\n          return function (event) {\n            scope.$apply(function () {\n              var data = event.type === 'update' ? model : dataSource;\n              var list = _.cloneDeep($parse(data)(scope));\n              var $el = $(event.target);\n              var id = $($el).attr('ng-sortable-id');\n              var oldIndex = null;\n              var newIndex = $el.index();\n              if (!id) throw new Error('No ng-sortable-id on element.');\n              var target = _.find(list, function (b, i) {\n                oldIndex = i;\n                return b[key] === id;\n              });\n              if (!target) {\n                // this requirement can go away if we set IDs ourself during compiletime\n                // but generally you'll have an ID to give\n                throw new Error('Could not locate target element. Did you forget to set attribute data-ng-sortable-id on your repeated HTML elements?');\n              }\n              if (event.type === 'update') {\n                list.splice(oldIndex, 1);\n                list.splice(newIndex, 0, target);\n                fn(list);\n              } else if (event.type === 'add') {\n                fn(target, newIndex, event);\n              }\n            });\n          };\n        }\n        if (onUpdate)  opts.onUpdate = bind(onUpdate);\n        if (groupName) opts.group = groupName;\n        if (onAdd)     opts.onAdd = bind(onAdd);\n        if (onRemove)  opts.onRemove = bind(onRemove);\n        if (onUpdate)  opts.onUpdate = bind(onUpdate);\n\n        scope.sortable = new Sortable(element.get(0), opts);\n      };\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/client/utils/post.js":"'use strict';\n\nvar $ = require('jquery');\n\nfunction post(url, data, done) {\n  $.ajax({\n    url: url,\n    type: 'POST',\n    data: data,\n    dataType: 'json',\n    success: function () {\n      done(null);\n    },\n    error: function (xhr, ts, e) {\n      if (xhr && xhr.responseText) {\n        var data = $.parseJSON(xhr.responseText);\n        e = data.errors[0];\n      }\n      done(e);\n    }\n  });\n}\n\nmodule.exports = post;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/client/utils/status-classes.js":"'use strict';\n\nmodule.exports = {\n  passed: 'fa-check-circle success-text',\n  failed: 'fa-exclamation-circle failure-text',\n  running: 'fa-circle-o-notch fa-spin running-text',\n  submitted: 'fa-clock-o waiting-text',\n  errored: 'fa-minus-circle error-text'\n};\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/lib/routes/account.js":"'use strict';\n\nvar express = require('express');\nvar pjson = require('../../package.json');\nvar utils = require('../utils');\nvar common = require('../common');\nvar router = express.Router();\n\n/*\n * GET /account - account settings page\n */\nrouter.get('/', function (req, res) {\n  var hosted = {};\n  var providers = common.userConfigs.provider;\n\n  for (var id in providers) {\n    if (common.extensions.provider[id].hosted) {\n      hosted[id] = providers[id];\n    }\n  }\n\n  res.format({\n    html: function () {\n      res.render('account.html', {\n        user: utils.sanitizeUser(req.user.toJSON()),\n        providers: hosted,\n        userConfigs: common.userConfigs,\n        flash: req.flash('account'),\n        version: pjson.version\n      });\n    },\n    json: function () {\n      res.send({\n        user: utils.sanitizeUser(req.user.toJSON()),\n        providers: hosted,\n        userConfigs: common.userConfigs\n      });\n    }\n  });\n});\n\nmodule.exports = router;\n","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/public/libs/ui-bootstrap.js":"angular.module(\"ui.bootstrap\", [\"ui.bootstrap.buttons\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.pagination\",\"ui.bootstrap.rating\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.bindHtml\",\"ui.bootstrap.typeahead\"]);\nangular.module('ui.bootstrap.buttons', [])\n\n  .constant('buttonConfig', {\n    activeClass:'active',\n    toggleEvent:'click'\n  })\n\n  .directive('btnRadio', ['buttonConfig', function (buttonConfig) {\n  var activeClass = buttonConfig.activeClass || 'active';\n  var toggleEvent = buttonConfig.toggleEvent || 'click';\n\n  return {\n\n    require:'ngModel',\n    link:function (scope, element, attrs, ngModelCtrl) {\n\n      //model -> UI\n      ngModelCtrl.$render = function () {\n        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n      };\n\n      //ui->model\n      element.bind(toggleEvent, function () {\n        if (!element.hasClass(activeClass)) {\n          scope.$apply(function () {\n            ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n    }\n  };\n}])\n\n  .directive('btnCheckbox', ['buttonConfig', function (buttonConfig) {\n\n  var activeClass = buttonConfig.activeClass || 'active';\n  var toggleEvent = buttonConfig.toggleEvent || 'click';\n\n  return {\n    require:'ngModel',\n    link:function (scope, element, attrs, ngModelCtrl) {\n\n      function getTrueValue() {\n        var trueValue = scope.$eval(attrs.btnCheckboxTrue);\n        return angular.isDefined(trueValue) ? trueValue : true;\n      }\n\n      function getFalseValue() {\n        var falseValue = scope.$eval(attrs.btnCheckboxFalse);\n        return angular.isDefined(falseValue) ? falseValue : false;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function () {\n        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.bind(toggleEvent, function () {\n        scope.$apply(function () {\n          ngModelCtrl.$setViewValue(element.hasClass(activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n}]);\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$position', ['$document', '$window', function ($document, $window) {\n\n    function getStyle(el, cssprop) {\n      if (el.currentStyle) { //IE\n        return el.currentStyle[cssprop];\n      } else if ($window.getComputedStyle) {\n        return $window.getComputedStyle(el)[cssprop];\n      }\n      // finally try and get inline style\n      return el.style[cssprop];\n    }\n\n    /**\n     * Checks if a given element is statically positioned\n     * @param element - raw DOM element\n     */\n    function isStaticPositioned(element) {\n      return (getStyle(element, \"position\") || 'static' ) === 'static';\n    }\n\n    /**\n     * returns the closest, non-statically positioned parentOffset of a given element\n     * @param element\n     */\n    var parentOffsetEl = function (element) {\n      var docDomEl = $document[0];\n      var offsetParent = element.offsetParent || docDomEl;\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docDomEl;\n    };\n\n    return {\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/\n       */\n      position: function (element) {\n        var elBCR = this.offset(element);\n        var offsetParentBCR = { top: 0, left: 0 };\n        var offsetParentEl = parentOffsetEl(element[0]);\n        if (offsetParentEl != $document[0]) {\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n        }\n\n        return {\n          width: element.prop('offsetWidth'),\n          height: element.prop('offsetHeight'),\n          top: elBCR.top - offsetParentBCR.top,\n          left: elBCR.left - offsetParentBCR.left\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/\n       */\n      offset: function (element) {\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: element.prop('offsetWidth'),\n          height: element.prop('offsetHeight'),\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft  || $document[0].documentElement.scrollLeft)\n        };\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.position'])\n\n.constant('datepickerConfig', {\n  dayFormat: 'dd',\n  monthFormat: 'MMMM',\n  yearFormat: 'yyyy',\n  dayHeaderFormat: 'EEE',\n  dayTitleFormat: 'MMMM yyyy',\n  monthTitleFormat: 'yyyy',\n  showWeeks: true,\n  startingDay: 0,\n  yearRange: 20,\n  minDate: null,\n  maxDate: null\n})\n\n.controller('DatepickerController', ['$scope', '$attrs', 'dateFilter', 'datepickerConfig', function($scope, $attrs, dateFilter, dtConfig) {\n  var format = {\n    day:        getValue($attrs.dayFormat,        dtConfig.dayFormat),\n    month:      getValue($attrs.monthFormat,      dtConfig.monthFormat),\n    year:       getValue($attrs.yearFormat,       dtConfig.yearFormat),\n    dayHeader:  getValue($attrs.dayHeaderFormat,  dtConfig.dayHeaderFormat),\n    dayTitle:   getValue($attrs.dayTitleFormat,   dtConfig.dayTitleFormat),\n    monthTitle: getValue($attrs.monthTitleFormat, dtConfig.monthTitleFormat)\n  },\n  startingDay = getValue($attrs.startingDay,      dtConfig.startingDay),\n  yearRange =   getValue($attrs.yearRange,        dtConfig.yearRange);\n\n  this.minDate = dtConfig.minDate ? new Date(dtConfig.minDate) : null;\n  this.maxDate = dtConfig.maxDate ? new Date(dtConfig.maxDate) : null;\n\n  function getValue(value, defaultValue) {\n    return angular.isDefined(value) ? $scope.$parent.$eval(value) : defaultValue;\n  }\n\n  function getDaysInMonth( year, month ) {\n    return new Date(year, month, 0).getDate();\n  }\n\n  function getDates(startDate, n) {\n    var dates = new Array(n);\n    var current = startDate, i = 0;\n    while (i < n) {\n      dates[i++] = new Date(current);\n      current.setDate( current.getDate() + 1 );\n    }\n    return dates;\n  }\n\n  function makeDate(date, format, isSelected, isSecondary) {\n    return { date: date, label: dateFilter(date, format), selected: !!isSelected, secondary: !!isSecondary };\n  }\n\n  this.modes = [\n    {\n      name: 'day',\n      getVisibleDates: function(date, selected) {\n        var year = date.getFullYear(), month = date.getMonth(), firstDayOfMonth = new Date(year, month, 1);\n        var difference = startingDay - firstDayOfMonth.getDay(),\n        numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n        firstDate = new Date(firstDayOfMonth), numDates = 0;\n\n        if ( numDisplayedFromPreviousMonth > 0 ) {\n          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );\n          numDates += numDisplayedFromPreviousMonth; // Previous\n        }\n        numDates += getDaysInMonth(year, month + 1); // Current\n        numDates += (7 - numDates % 7) % 7; // Next\n\n        var days = getDates(firstDate, numDates), labels = new Array(7);\n        for (var i = 0; i < numDates; i ++) {\n          var dt = new Date(days[i]);\n          days[i] = makeDate(dt, format.day, (selected && selected.getDate() === dt.getDate() && selected.getMonth() === dt.getMonth() && selected.getFullYear() === dt.getFullYear()), dt.getMonth() !== month);\n        }\n        for (var j = 0; j < 7; j++) {\n          labels[j] = dateFilter(days[j].date, format.dayHeader);\n        }\n        return { objects: days, title: dateFilter(date, format.dayTitle), labels: labels };\n      },\n      compare: function(date1, date2) {\n        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );\n      },\n      split: 7,\n      step: { months: 1 }\n    },\n    {\n      name: 'month',\n      getVisibleDates: function(date, selected) {\n        var months = new Array(12), year = date.getFullYear();\n        for ( var i = 0; i < 12; i++ ) {\n          var dt = new Date(year, i, 1);\n          months[i] = makeDate(dt, format.month, (selected && selected.getMonth() === i && selected.getFullYear() === year));\n        }\n        return { objects: months, title: dateFilter(date, format.monthTitle) };\n      },\n      compare: function(date1, date2) {\n        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );\n      },\n      split: 3,\n      step: { years: 1 }\n    },\n    {\n      name: 'year',\n      getVisibleDates: function(date, selected) {\n        var years = new Array(yearRange), year = date.getFullYear(), startYear = parseInt((year - 1) / yearRange, 10) * yearRange + 1;\n        for ( var i = 0; i < yearRange; i++ ) {\n          var dt = new Date(startYear + i, 0, 1);\n          years[i] = makeDate(dt, format.year, (selected && selected.getFullYear() === dt.getFullYear()));\n        }\n        return { objects: years, title: [years[0].label, years[yearRange - 1].label].join(' - ') };\n      },\n      compare: function(date1, date2) {\n        return date1.getFullYear() - date2.getFullYear();\n      },\n      split: 5,\n      step: { years: yearRange }\n    }\n  ];\n\n  this.isDisabled = function(date, mode) {\n    var currentMode = this.modes[mode || 0];\n    return ((this.minDate && currentMode.compare(date, this.minDate) < 0) || (this.maxDate && currentMode.compare(date, this.maxDate) > 0) || ($scope.dateDisabled && $scope.dateDisabled({date: date, mode: currentMode.name})));\n  };\n}])\n\n.directive( 'datepicker', ['dateFilter', '$parse', 'datepickerConfig', '$log', function (dateFilter, $parse, datepickerConfig, $log) {\n  return {\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/datepicker/datepicker.html',\n    scope: {\n      dateDisabled: '&'\n    },\n    require: ['datepicker', '?^ngModel'],\n    controller: 'DatepickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModel = ctrls[1];\n\n      if (!ngModel) {\n        return; // do nothing if no ng-model\n      }\n\n      // Configuration parameters\n      var mode = 0, selected = new Date(), showWeeks = datepickerConfig.showWeeks;\n\n      if (attrs.showWeeks) {\n        scope.$parent.$watch($parse(attrs.showWeeks), function(value) {\n          showWeeks = !! value;\n          updateShowWeekNumbers();\n        });\n      } else {\n        updateShowWeekNumbers();\n      }\n\n      if (attrs.min) {\n        scope.$parent.$watch($parse(attrs.min), function(value) {\n          datepickerCtrl.minDate = value ? new Date(value) : null;\n          refill();\n        });\n      }\n      if (attrs.max) {\n        scope.$parent.$watch($parse(attrs.max), function(value) {\n          datepickerCtrl.maxDate = value ? new Date(value) : null;\n          refill();\n        });\n      }\n\n      function updateShowWeekNumbers() {\n        scope.showWeekNumbers = mode === 0 && showWeeks;\n      }\n\n      // Split array into smaller arrays\n      function split(arr, size) {\n        var arrays = [];\n        while (arr.length > 0) {\n          arrays.push(arr.splice(0, size));\n        }\n        return arrays;\n      }\n\n      function refill( updateSelected ) {\n        var date = null, valid = true;\n\n        if ( ngModel.$modelValue ) {\n          date = new Date( ngModel.$modelValue );\n\n          if ( isNaN(date) ) {\n            valid = false;\n            $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n          } else if ( updateSelected ) {\n            selected = date;\n          }\n        }\n        ngModel.$setValidity('date', valid);\n\n        var currentMode = datepickerCtrl.modes[mode], data = currentMode.getVisibleDates(selected, date);\n        angular.forEach(data.objects, function(obj) {\n          obj.disabled = datepickerCtrl.isDisabled(obj.date, mode);\n        });\n\n        ngModel.$setValidity('date-disabled', (!date || !datepickerCtrl.isDisabled(date)));\n\n        scope.rows = split(data.objects, currentMode.split);\n        scope.labels = data.labels || [];\n        scope.title = data.title;\n      }\n\n      function setMode(value) {\n        mode = value;\n        updateShowWeekNumbers();\n        refill();\n      }\n\n      ngModel.$render = function() {\n        refill( true );\n      };\n\n      scope.select = function( date ) {\n        if ( mode === 0 ) {\n          var dt = new Date( ngModel.$modelValue );\n          dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );\n          ngModel.$setViewValue( dt );\n          refill( true );\n        } else {\n          selected = date;\n          setMode( mode - 1 );\n        }\n      };\n      scope.move = function(direction) {\n        var step = datepickerCtrl.modes[mode].step;\n        selected.setMonth( selected.getMonth() + direction * (step.months || 0) );\n        selected.setFullYear( selected.getFullYear() + direction * (step.years || 0) );\n        refill();\n      };\n      scope.toggleMode = function() {\n        setMode( (mode + 1) % datepickerCtrl.modes.length );\n      };\n      scope.getWeekNumber = function(row) {\n        return ( mode === 0 && scope.showWeekNumbers && row.length === 7 ) ? getISO8601WeekNumber(row[0].date) : null;\n      };\n\n      function getISO8601WeekNumber(date) {\n        var checkDate = new Date(date);\n        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n        var time = checkDate.getTime();\n        checkDate.setMonth(0); // Compare with Jan 1\n        checkDate.setDate(1);\n        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n      }\n    }\n  };\n}])\n\n.constant('datepickerPopupConfig', {\n  dateFormat: 'yyyy-MM-dd',\n  closeOnDateSelection: true\n})\n\n.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'datepickerPopupConfig',\nfunction ($compile, $parse, $document, $position, dateFilter, datepickerPopupConfig) {\n  return {\n    restrict: 'EA',\n    require: 'ngModel',\n    link: function(originalScope, element, attrs, ngModel) {\n\n      var closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n      var dateFormat = attrs.datepickerPopup || datepickerPopupConfig.dateFormat;\n\n     // create a child scope for the datepicker directive so we are not polluting original scope\n      var scope = originalScope.$new();\n      originalScope.$on('$destroy', function() {\n        scope.$destroy();\n      });\n\n      var getIsOpen, setIsOpen;\n      if ( attrs.isOpen ) {\n        getIsOpen = $parse(attrs.isOpen);\n        setIsOpen = getIsOpen.assign;\n\n        originalScope.$watch(getIsOpen, function updateOpen(value) {\n          scope.isOpen = !! value;\n        });\n      }\n      scope.isOpen = getIsOpen ? getIsOpen(originalScope) : false; // Initial state\n\n      function setOpen( value ) {\n        if (setIsOpen) {\n          setIsOpen(originalScope, !!value);\n        } else {\n          scope.isOpen = !!value;\n        }\n      }\n\n      var documentClickBind = function(event) {\n        if (scope.isOpen && event.target !== element[0]) {\n          scope.$apply(function() {\n            setOpen(false);\n          });\n        }\n      };\n\n      var elementFocusBind = function() {\n        scope.$apply(function() {\n          setOpen( true );\n        });\n      };\n\n      // popup element used to display calendar\n      var popupEl = angular.element('<datepicker-popup-wrap><datepicker></datepicker></datepicker-popup-wrap>');\n      popupEl.attr({\n        'ng-model': 'date',\n        'ng-change': 'dateSelection()'\n      });\n      var datepickerEl = popupEl.find('datepicker');\n      if (attrs.datepickerOptions) {\n        datepickerEl.attr(angular.extend({}, originalScope.$eval(attrs.datepickerOptions)));\n      }\n\n      // TODO: reverse from dateFilter string to Date object\n      function parseDate(viewValue) {\n        if (!viewValue) {\n          ngModel.$setValidity('date', true);\n          return null;\n        } else if (angular.isDate(viewValue)) {\n          ngModel.$setValidity('date', true);\n          return viewValue;\n        } else if (angular.isString(viewValue)) {\n          var date = new Date(viewValue);\n          if (isNaN(date)) {\n            ngModel.$setValidity('date', false);\n            return undefined;\n          } else {\n            ngModel.$setValidity('date', true);\n            return date;\n          }\n        } else {\n          ngModel.$setValidity('date', false);\n          return undefined;\n        }\n      }\n      ngModel.$parsers.unshift(parseDate);\n\n      // Inner change\n      scope.dateSelection = function() {\n        ngModel.$setViewValue(scope.date);\n        ngModel.$render();\n\n        if (closeOnDateSelection) {\n          setOpen( false );\n        }\n      };\n\n      element.bind('input change keyup', function() {\n        scope.$apply(function() {\n          updateCalendar();\n        });\n      });\n\n      // Outter change\n      ngModel.$render = function() {\n        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';\n        element.val(date);\n\n        updateCalendar();\n      };\n\n      function updateCalendar() {\n        scope.date = ngModel.$modelValue;\n        updatePosition();\n      }\n\n      function addWatchableAttribute(attribute, scopeProperty, datepickerAttribute) {\n        if (attribute) {\n          originalScope.$watch($parse(attribute), function(value){\n            scope[scopeProperty] = value;\n          });\n          datepickerEl.attr(datepickerAttribute || scopeProperty, scopeProperty);\n        }\n      }\n      addWatchableAttribute(attrs.min, 'min');\n      addWatchableAttribute(attrs.max, 'max');\n      if (attrs.showWeeks) {\n        addWatchableAttribute(attrs.showWeeks, 'showWeeks', 'show-weeks');\n      } else {\n        scope.showWeeks = true;\n        datepickerEl.attr('show-weeks', 'showWeeks');\n      }\n      if (attrs.dateDisabled) {\n        datepickerEl.attr('date-disabled', attrs.dateDisabled);\n      }\n\n      function updatePosition() {\n        scope.position = $position.position(element);\n        scope.position.top = scope.position.top + element.prop('offsetHeight');\n      }\n\n      var documentBindingInitialized = false, elementFocusInitialized = false;\n      scope.$watch('isOpen', function(value) {\n        if (value) {\n          updatePosition();\n          $document.bind('click', documentClickBind);\n          if(elementFocusInitialized) {\n            element.unbind('focus', elementFocusBind);\n          }\n          element[0].focus();\n          documentBindingInitialized = true;\n        } else {\n          if(documentBindingInitialized) {\n            $document.unbind('click', documentClickBind);\n          }\n          element.bind('focus', elementFocusBind);\n          elementFocusInitialized = true;\n        }\n\n        if ( setIsOpen ) {\n          setIsOpen(originalScope, value);\n        }\n      });\n\n      var $setModelValue = $parse(attrs.ngModel).assign;\n\n      scope.today = function() {\n        $setModelValue(originalScope, new Date());\n      };\n      scope.clear = function() {\n        $setModelValue(originalScope, null);\n      };\n\n      element.after($compile(popupEl)(scope));\n    }\n  };\n}])\n\n.directive('datepickerPopupWrap', [function() {\n  return {\n    restrict:'E',\n    replace: true,\n    transclude: true,\n    templateUrl: 'template/datepicker/popup.html',\n    link:function (scope, element, attrs) {\n      element.bind('click', function(event) {\n        event.preventDefault();\n        event.stopPropagation();\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pagination', [])\n\n.controller('PaginationController', ['$scope', '$attrs', '$parse', '$interpolate', function ($scope, $attrs, $parse, $interpolate) {\n  var self = this;\n\n  this.init = function(defaultItemsPerPage) {\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = defaultItemsPerPage;\n    }\n  };\n\n  this.noPrevious = function() {\n    return this.page === 1;\n  };\n  this.noNext = function() {\n    return this.page === $scope.totalPages;\n  };\n\n  this.isActive = function(page) {\n    return this.page === page;\n  };\n\n  this.calculateTotalPages = function() {\n    return this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n  };\n\n  this.getAttributeValue = function(attribute, defaultValue, interpolate) {\n    return angular.isDefined(attribute) ? (interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute)) : defaultValue;\n  };\n\n  this.render = function() {\n    this.page = parseInt($scope.page, 10) || 1;\n    $scope.pages = this.getPages(this.page, $scope.totalPages);\n  };\n\n  $scope.selectPage = function(page) {\n    if ( ! self.isActive(page) && page > 0 && page <= $scope.totalPages) {\n      $scope.page = page;\n      $scope.onSelectPage({ page: page });\n    }\n  };\n\n  $scope.$watch('totalItems', function() {\n    $scope.totalPages = self.calculateTotalPages();\n  });\n\n  $scope.$watch('totalPages', function(value) {\n    if ( $attrs.numPages ) {\n      $scope.numPages = value; // Readonly variable\n    }\n\n    if ( self.page > value ) {\n      $scope.selectPage(value);\n    } else {\n      self.render();\n    }\n  });\n\n  $scope.$watch('page', function() {\n    self.render();\n  });\n}])\n\n.constant('paginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true\n})\n\n.directive('pagination', ['$parse', 'paginationConfig', function($parse, config) {\n  return {\n    restrict: 'EA',\n    scope: {\n      page: '=',\n      totalItems: '=',\n      onSelectPage:' &',\n      numPages: '='\n    },\n    controller: 'PaginationController',\n    templateUrl: 'template/pagination/pagination.html',\n    replace: true,\n    link: function(scope, element, attrs, paginationCtrl) {\n\n      // Setup configuration parameters\n      var maxSize,\n      boundaryLinks  = paginationCtrl.getAttributeValue(attrs.boundaryLinks,  config.boundaryLinks      ),\n      directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks     ),\n      firstText      = paginationCtrl.getAttributeValue(attrs.firstText,      config.firstText,     true),\n      previousText   = paginationCtrl.getAttributeValue(attrs.previousText,   config.previousText,  true),\n      nextText       = paginationCtrl.getAttributeValue(attrs.nextText,       config.nextText,      true),\n      lastText       = paginationCtrl.getAttributeValue(attrs.lastText,       config.lastText,      true),\n      rotate         = paginationCtrl.getAttributeValue(attrs.rotate,         config.rotate);\n\n      paginationCtrl.init(config.itemsPerPage);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive, isDisabled) {\n        return {\n          number: number,\n          text: text,\n          active: isActive,\n          disabled: isDisabled\n        };\n      }\n\n      paginationCtrl.getPages = function(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );\n\n        // recompute if maxSize\n        if ( isMaxSized ) {\n          if ( rotate ) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, paginationCtrl.isActive(number), false);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if ( isMaxSized && ! rotate ) {\n          if ( startPage > 1 ) {\n            var previousPageSet = makePage(startPage - 1, '...', false, false);\n            pages.unshift(previousPageSet);\n          }\n\n          if ( endPage < totalPages ) {\n            var nextPageSet = makePage(endPage + 1, '...', false, false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        // Add previous & next links\n        if (directionLinks) {\n          var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());\n          pages.unshift(previousPage);\n\n          var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());\n          pages.push(nextPage);\n        }\n\n        // Add first & last links\n        if (boundaryLinks) {\n          var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());\n          pages.unshift(firstPage);\n\n          var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());\n          pages.push(lastPage);\n        }\n\n        return pages;\n      };\n    }\n  };\n}])\n\n.constant('pagerConfig', {\n  itemsPerPage: 10,\n  previousText: '« Previous',\n  nextText: 'Next »',\n  align: true\n})\n\n.directive('pager', ['pagerConfig', function(config) {\n  return {\n    restrict: 'EA',\n    scope: {\n      page: '=',\n      totalItems: '=',\n      onSelectPage:' &',\n      numPages: '='\n    },\n    controller: 'PaginationController',\n    templateUrl: 'template/pagination/pager.html',\n    replace: true,\n    link: function(scope, element, attrs, paginationCtrl) {\n\n      // Setup configuration parameters\n      var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),\n      nextText         = paginationCtrl.getAttributeValue(attrs.nextText,     config.nextText,     true),\n      align            = paginationCtrl.getAttributeValue(attrs.align,        config.align);\n\n      paginationCtrl.init(config.itemsPerPage);\n\n      // Create page object used in template\n      function makePage(number, text, isDisabled, isPrevious, isNext) {\n        return {\n          number: number,\n          text: text,\n          disabled: isDisabled,\n          previous: ( align && isPrevious ),\n          next: ( align && isNext )\n        };\n      }\n\n      paginationCtrl.getPages = function(currentPage) {\n        return [\n          makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false),\n          makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true)\n        ];\n      };\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.rating', [])\n\n.constant('ratingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null\n})\n\n.controller('RatingController', ['$scope', '$attrs', '$parse', 'ratingConfig', function($scope, $attrs, $parse, ratingConfig) {\n\n  this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max;\n  this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n  this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\n  this.createDefaultRange = function(len) {\n    var defaultStateObject = {\n      stateOn: this.stateOn,\n      stateOff: this.stateOff\n    };\n\n    var states = new Array(len);\n    for (var i = 0; i < len; i++) {\n      states[i] = defaultStateObject;\n    }\n    return states;\n  };\n\n  this.normalizeRange = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i].stateOn = states[i].stateOn || this.stateOn;\n      states[i].stateOff = states[i].stateOff || this.stateOff;\n    }\n    return states;\n  };\n\n  // Get objects used in template\n  $scope.range = angular.isDefined($attrs.ratingStates) ?  this.normalizeRange(angular.copy($scope.$parent.$eval($attrs.ratingStates))): this.createDefaultRange(this.maxRange);\n\n  $scope.rate = function(value) {\n    if ( $scope.readonly || $scope.value === value) {\n      return;\n    }\n\n    $scope.value = value;\n  };\n\n  $scope.enter = function(value) {\n    if ( ! $scope.readonly ) {\n      $scope.val = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.val = angular.copy($scope.value);\n    $scope.onLeave();\n  };\n\n  $scope.$watch('value', function(value) {\n    $scope.val = value;\n  });\n\n  $scope.readonly = false;\n  if ($attrs.readonly) {\n    $scope.$parent.$watch($parse($attrs.readonly), function(value) {\n      $scope.readonly = !!value;\n    });\n  }\n}])\n\n.directive('rating', function() {\n  return {\n    restrict: 'EA',\n    scope: {\n      value: '=',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'RatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true\n  };\n});\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('timepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  showMeridian: true,\n  meridians: ['AM', 'PM'],\n  readonlyInput: false,\n  mousewheel: true\n})\n\n.directive('timepicker', ['$parse', '$log', 'timepickerConfig', function ($parse, $log, timepickerConfig) {\n  return {\n    restrict: 'EA',\n    require:'?^ngModel',\n    replace: true,\n    scope: {},\n    templateUrl: 'template/timepicker/timepicker.html',\n    link: function(scope, element, attrs, ngModel) {\n      if ( !ngModel ) {\n        return; // do nothing if no ng-model\n      }\n\n      var selected = new Date(), meridians = timepickerConfig.meridians;\n\n      var hourStep = timepickerConfig.hourStep;\n      if (attrs.hourStep) {\n        scope.$parent.$watch($parse(attrs.hourStep), function(value) {\n          hourStep = parseInt(value, 10);\n        });\n      }\n\n      var minuteStep = timepickerConfig.minuteStep;\n      if (attrs.minuteStep) {\n        scope.$parent.$watch($parse(attrs.minuteStep), function(value) {\n          minuteStep = parseInt(value, 10);\n        });\n      }\n\n      // 12H / 24H mode\n      scope.showMeridian = timepickerConfig.showMeridian;\n      if (attrs.showMeridian) {\n        scope.$parent.$watch($parse(attrs.showMeridian), function(value) {\n          scope.showMeridian = !!value;\n\n          if ( ngModel.$error.time ) {\n            // Evaluate from template\n            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n            if (angular.isDefined( hours ) && angular.isDefined( minutes )) {\n              selected.setHours( hours );\n              refresh();\n            }\n          } else {\n            updateTemplate();\n          }\n        });\n      }\n\n      // Get scope.hours in 24H mode if valid\n      function getHoursFromTemplate ( ) {\n        var hours = parseInt( scope.hours, 10 );\n        var valid = ( scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n        if ( !valid ) {\n          return undefined;\n        }\n\n        if ( scope.showMeridian ) {\n          if ( hours === 12 ) {\n            hours = 0;\n          }\n          if ( scope.meridian === meridians[1] ) {\n            hours = hours + 12;\n          }\n        }\n        return hours;\n      }\n\n      function getMinutesFromTemplate() {\n        var minutes = parseInt(scope.minutes, 10);\n        return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;\n      }\n\n      function pad( value ) {\n        return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;\n      }\n\n      // Input elements\n      var inputs = element.find('input'), hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);\n\n      // Respond on mousewheel spin\n      var mousewheel = (angular.isDefined(attrs.mousewheel)) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel;\n      if ( mousewheel ) {\n\n        var isScrollingUp = function(e) {\n          if (e.originalEvent) {\n            e = e.originalEvent;\n          }\n          //pick correct delta variable depending on event\n          var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n          return (e.detail || delta > 0);\n        };\n\n        hoursInputEl.bind('mousewheel wheel', function(e) {\n          scope.$apply( (isScrollingUp(e)) ? scope.incrementHours() : scope.decrementHours() );\n          e.preventDefault();\n        });\n\n        minutesInputEl.bind('mousewheel wheel', function(e) {\n          scope.$apply( (isScrollingUp(e)) ? scope.incrementMinutes() : scope.decrementMinutes() );\n          e.preventDefault();\n        });\n      }\n\n      scope.readonlyInput = (angular.isDefined(attrs.readonlyInput)) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput;\n      if ( ! scope.readonlyInput ) {\n\n        var invalidate = function(invalidHours, invalidMinutes) {\n          ngModel.$setViewValue( null );\n          ngModel.$setValidity('time', false);\n          if (angular.isDefined(invalidHours)) {\n            scope.invalidHours = invalidHours;\n          }\n          if (angular.isDefined(invalidMinutes)) {\n            scope.invalidMinutes = invalidMinutes;\n          }\n        };\n\n        scope.updateHours = function() {\n          var hours = getHoursFromTemplate();\n\n          if ( angular.isDefined(hours) ) {\n            selected.setHours( hours );\n            refresh( 'h' );\n          } else {\n            invalidate(true);\n          }\n        };\n\n        hoursInputEl.bind('blur', function(e) {\n          if ( !scope.validHours && scope.hours < 10) {\n            scope.$apply( function() {\n              scope.hours = pad( scope.hours );\n            });\n          }\n        });\n\n        scope.updateMinutes = function() {\n          var minutes = getMinutesFromTemplate();\n\n          if ( angular.isDefined(minutes) ) {\n            selected.setMinutes( minutes );\n            refresh( 'm' );\n          } else {\n            invalidate(undefined, true);\n          }\n        };\n\n        minutesInputEl.bind('blur', function(e) {\n          if ( !scope.invalidMinutes && scope.minutes < 10 ) {\n            scope.$apply( function() {\n              scope.minutes = pad( scope.minutes );\n            });\n          }\n        });\n      } else {\n        scope.updateHours = angular.noop;\n        scope.updateMinutes = angular.noop;\n      }\n\n      ngModel.$render = function() {\n        var date = ngModel.$modelValue ? new Date( ngModel.$modelValue ) : null;\n\n        if ( isNaN(date) ) {\n          ngModel.$setValidity('time', false);\n          $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n        } else {\n          if ( date ) {\n            selected = date;\n          }\n          makeValid();\n          updateTemplate();\n        }\n      };\n\n      // Call internally when we know that model is valid.\n      function refresh( keyboardChange ) {\n        makeValid();\n        ngModel.$setViewValue( new Date(selected) );\n        updateTemplate( keyboardChange );\n      }\n\n      function makeValid() {\n        ngModel.$setValidity('time', true);\n        scope.invalidHours = false;\n        scope.invalidMinutes = false;\n      }\n\n      function updateTemplate( keyboardChange ) {\n        var hours = selected.getHours(), minutes = selected.getMinutes();\n\n        if ( scope.showMeridian ) {\n          hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system\n        }\n        scope.hours =  keyboardChange === 'h' ? hours : pad(hours);\n        scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);\n        scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n      }\n\n      function addMinutes( minutes ) {\n        var dt = new Date( selected.getTime() + minutes * 60000 );\n        selected.setHours( dt.getHours(), dt.getMinutes() );\n        refresh();\n      }\n\n      scope.incrementHours = function() {\n        addMinutes( hourStep * 60 );\n      };\n      scope.decrementHours = function() {\n        addMinutes( - hourStep * 60 );\n      };\n      scope.incrementMinutes = function() {\n        addMinutes( minuteStep );\n      };\n      scope.decrementMinutes = function() {\n        addMinutes( - minuteStep );\n      };\n      scope.toggleMeridian = function() {\n        addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );\n      };\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.bindHtml', [])\n\n  .directive('bindHtmlUnsafe', function () {\n    return function (scope, element, attr) {\n      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);\n      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {\n        element.html(value || '');\n      });\n    };\n  });\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('typeaheadParser', ['$parse', function ($parse) {\n\n  //                      00000111000000000000022200000000000000003333333333333330000000000044000\n  var TYPEAHEAD_REGEXP = /^\\s*(.*?)(?:\\s+as\\s+(.*?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+(.*)$/;\n\n  return {\n    parse:function (input) {\n\n      var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;\n      if (!match) {\n        throw new Error(\n          \"Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'\" +\n            \" but got '\" + input + \"'.\");\n      }\n\n      return {\n        itemName:match[3],\n        source:$parse(match[4]),\n        viewMapper:$parse(match[2] || match[1]),\n        modelMapper:$parse(match[1])\n      };\n    }\n  };\n}])\n\n  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',\n    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {\n\n  var HOT_KEYS = [9, 13, 27, 38, 40];\n\n  return {\n    require:'ngModel',\n    link:function (originalScope, element, attrs, modelCtrl) {\n\n      //SUPPORTED ATTRIBUTES (OPTIONS)\n\n      //minimal no of characters that needs to be entered before typeahead kicks-in\n      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;\n\n      //minimal wait time after last character typed before typehead kicks-in\n      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n      //should it restrict model values to the ones selected from the popup only?\n      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n      //binding to a variable that indicates if matches are being retrieved asynchronously\n      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n      //a callback executed when a match is selected\n      var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n      //INTERNAL VARIABLES\n\n      //model setter executed upon match selection\n      var $setModelValue = $parse(attrs.ngModel).assign;\n\n      //expressions used by typeahead\n      var parserResult = typeaheadParser.parse(attrs.typeahead);\n\n\n      //pop-up element used to display matches\n      var popUpEl = angular.element('<typeahead-popup></typeahead-popup>');\n      popUpEl.attr({\n        matches: 'matches',\n        active: 'activeIdx',\n        select: 'select(activeIdx)',\n        query: 'query',\n        position: 'position'\n      });\n      //custom item template\n      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n      }\n\n      //create a child scope for the typeahead directive so we are not polluting original scope\n      //with typeahead-specific data (matches, query etc.)\n      var scope = originalScope.$new();\n      originalScope.$on('$destroy', function(){\n        scope.$destroy();\n      });\n\n      var resetMatches = function() {\n        scope.matches = [];\n        scope.activeIdx = -1;\n      };\n\n      var getMatchesAsync = function(inputValue) {\n\n        var locals = {$viewValue: inputValue};\n        isLoadingSetter(originalScope, true);\n        $q.when(parserResult.source(scope, locals)).then(function(matches) {\n\n          //it might happen that several async queries were in progress if a user were typing fast\n          //but we are interested only in responses that correspond to the current view value\n          if (inputValue === modelCtrl.$viewValue) {\n            if (matches.length > 0) {\n\n              scope.activeIdx = 0;\n              scope.matches.length = 0;\n\n              //transform labels\n              for(var i=0; i<matches.length; i++) {\n                locals[parserResult.itemName] = matches[i];\n                scope.matches.push({\n                  label: parserResult.viewMapper(scope, locals),\n                  model: matches[i]\n                });\n              }\n\n              scope.query = inputValue;\n              //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n              //due to other elements being rendered\n              scope.position = $position.position(element);\n              scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n            } else {\n              resetMatches();\n            }\n            isLoadingSetter(originalScope, false);\n          }\n        }, function(){\n          resetMatches();\n          isLoadingSetter(originalScope, false);\n        });\n      };\n\n      resetMatches();\n\n      //we need to propagate user's query so we can higlight matches\n      scope.query = undefined;\n\n      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later \n      var timeoutPromise;\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function (inputValue) {\n\n        resetMatches();\n        if (inputValue && inputValue.length >= minSearch) {\n          if (waitTime > 0) {\n            if (timeoutPromise) {\n              $timeout.cancel(timeoutPromise);//cancel previous timeout\n            }\n            timeoutPromise = $timeout(function () {\n              getMatchesAsync(inputValue);\n            }, waitTime);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        }\n\n        if (isEditable) {\n          return inputValue;\n        } else {\n          modelCtrl.$setValidity('editable', false);\n          return undefined;\n        }\n      });\n\n      modelCtrl.$formatters.push(function (modelValue) {\n\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        if (inputFormatter) {\n\n          locals['$model'] = modelValue;\n          return inputFormatter(originalScope, locals);\n\n        } else {\n\n          //it might happen that we don't have enough info to properly render input value\n          //we need to check for this situation and simply return model value if we can't apply custom formatting\n          locals[parserResult.itemName] = modelValue;\n          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n          locals[parserResult.itemName] = undefined;\n          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;\n        }\n      });\n\n      scope.select = function (activeIdx) {\n        //called from within the $digest() cycle\n        var locals = {};\n        var model, item;\n\n        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n        model = parserResult.modelMapper(originalScope, locals);\n        $setModelValue(originalScope, model);\n        modelCtrl.$setValidity('editable', true);\n\n        onSelectCallback(originalScope, {\n          $item: item,\n          $model: model,\n          $label: parserResult.viewMapper(originalScope, locals)\n        });\n\n        resetMatches();\n\n        //return focus to the input element if a mach was selected via a mouse click event\n        element[0].focus();\n      };\n\n      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n      element.bind('keydown', function (evt) {\n\n        //typeahead is open and an \"interesting\" key was pressed\n        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n          return;\n        }\n\n        evt.preventDefault();\n\n        if (evt.which === 40) {\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n          scope.$digest();\n\n        } else if (evt.which === 38) {\n          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;\n          scope.$digest();\n\n        } else if (evt.which === 13 || evt.which === 9) {\n          scope.$apply(function () {\n            scope.select(scope.activeIdx);\n          });\n\n        } else if (evt.which === 27) {\n          evt.stopPropagation();\n\n          resetMatches();\n          scope.$digest();\n        }\n      });\n\n      // Keep reference to click handler to unbind it.\n      var dismissClickHandler = function (evt) {\n        if (element[0] !== evt.target) {\n          resetMatches();\n          scope.$digest();\n        }\n      };\n\n      $document.bind('click', dismissClickHandler);\n\n      originalScope.$on('$destroy', function(){\n        $document.unbind('click', dismissClickHandler);\n      });\n\n      element.after($compile(popUpEl)(scope));\n    }\n  };\n\n}])\n\n  .directive('typeaheadPopup', function () {\n    return {\n      restrict:'E',\n      scope:{\n        matches:'=',\n        query:'=',\n        active:'=',\n        position:'=',\n        select:'&'\n      },\n      replace:true,\n      // Hardcode this path until this is fixed: https://github.com/decipherinc/angular-tags/issues/16#issuecomment-26614629\n      templateUrl:'/ui-bootstrap/template/typeahead/typeahead-popup.html',\n      link:function (scope, element, attrs) {\n\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function () {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function (matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function (matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function (activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  })\n\n  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {\n    return {\n      restrict:'E',\n      scope:{\n        index:'=',\n        match:'=',\n        query:'='\n      },\n      link:function (scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){\n           element.replaceWith($compile(tplContent.trim())(scope));\n        });\n      }\n    };\n  }])\n\n  .filter('typeaheadHighlight', function() {\n\n    function escapeRegexp(queryToEscape) {\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n    }\n\n    return function(matchItem, query) {\n      return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;\n    };\n  });","/home/travis/build/npmtest/node-npmtest-strider/node_modules/strider/public/libs/ui-codemirror.js":"/*global angular, CodeMirror, Error*/\n/**\n * Binds a CodeMirror widget to a <textarea> element.\n */\nangular.module('ui.codemirror', [])\n  .constant('uiCodemirrorConfig', {})\n  .directive('uiCodemirror', ['uiCodemirrorConfig', '$timeout', function (uiCodemirrorConfig, $timeout) {\n    'use strict';\n\n    var events = [\"cursorActivity\", \"viewportChange\", \"gutterClick\", \"focus\", \"blur\", \"scroll\", \"update\"];\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function (scope, elm, attrs, ngModel) {\n        var options, opts, onChange, deferCodeMirror, codeMirror;\n\n        if (elm[0].type !== 'textarea') {\n          throw new Error('uiCodemirror3 can only be applied to a textarea element');\n        }\n\n        options = uiCodemirrorConfig.codemirror || {};\n        opts = angular.extend({}, options, scope.$eval(attrs.uiCodemirror));\n\n        onChange = function (aEvent) {\n          return function (instance, changeObj) {\n            var newValue = instance.getValue();\n            if (newValue !== ngModel.$viewValue) {\n              ngModel.$setViewValue(newValue);\n            }\n            if (typeof aEvent === \"function\") {\n              aEvent(instance, changeObj);\n            }\n            if (!scope.$$phase) {\n              scope.$apply();\n            }\n          };\n        };\n\n        deferCodeMirror = function () {\n          codeMirror = CodeMirror.fromTextArea(elm[0], opts);\n\n          // Refresh codemirror externally this way...\n          //$('[ui-codemirror]').trigger('refresh')\n          elm.on('refresh', function () {\n            codeMirror.refresh()\n          });\n\n          if (angular.isDefined(scope[attrs.uiCodemirror])) {\n            scope.$watch(attrs.uiCodemirror, function (newValues) {\n              for (var key in newValues) {\n                if (newValues.hasOwnProperty(key)) {\n                  codeMirror.setOption(key, newValues[key]);\n                }\n              }\n            }, true);\n          }\n\n          codeMirror.on(\"change\", onChange(opts.onChange));\n\n          for (var i = 0, n = events.length, aEvent; i < n; ++i) {\n            aEvent = opts[\"on\" + events[i].charAt(0).toUpperCase() + events[i].slice(1)];\n            if (aEvent === void 0) {\n              continue;\n            }\n            if (typeof aEvent !== \"function\") {\n              continue;\n            }\n            codeMirror.on(events[i], aEvent);\n          }\n\n          // CodeMirror expects a string, so make sure it gets one.\n          // This does not change the model.\n          ngModel.$formatters.push(function (value) {\n            if (angular.isUndefined(value) || value === null) {\n              return '';\n            }\n            else if (angular.isObject(value) || angular.isArray(value)) {\n              throw new Error('ui-codemirror cannot use an object or an array as a model');\n            }\n            return value;\n          });\n\n          // Override the ngModelController $render method, which is what gets called when the model is updated.\n          // This takes care of the synchronizing the codeMirror element with the underlying model, in the case that it is changed by something else.\n          ngModel.$render = function () {\n            codeMirror.setValue(ngModel.$viewValue);\n          };\n\n          if (!ngModel.$viewValue){\n            ngModel.$setViewValue(elm.text());\n            ngModel.$render();\n          }\n\n          // Watch ui-refresh and refresh the directive\n          if (attrs.uiRefresh) {\n            scope.$watch(attrs.uiRefresh, function (newVal, oldVal) {\n              // Skip the initial watch firing\n              if (newVal !== oldVal) {\n                $timeout(function () {\n                  codeMirror.refresh();\n                });\n              }\n            });\n          }\n\n          // onLoad callback\n          if (angular.isFunction(opts.onLoad)) {\n            opts.onLoad(codeMirror);\n          }\n        };\n\n        $timeout(deferCodeMirror);\n\n      }\n    };\n  }]);\n"}